{"meta":{"title":"Azure's BLOG","subtitle":"Maker & Developer","description":"“所有的事情，所有身外的期望，所有的骄傲，所有的对困难和失败的恐惧。这些东西在死亡面前立刻消失的无影无踪，只剩下真正重要的东西。” —— Steve Jobs","author":"Sky Azure","url":"http://onlyorange.top","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-02-13T12:47:13.720Z","updated":"2020-02-13T12:47:13.720Z","comments":true,"path":"404.html","permalink":"http://onlyorange.top/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-02-13T12:39:15.599Z","updated":"2020-02-13T12:39:15.599Z","comments":true,"path":"about/index.html","permalink":"http://onlyorange.top/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-02-13T09:59:29.863Z","updated":"2020-02-13T09:59:29.863Z","comments":true,"path":"categories/index.html","permalink":"http://onlyorange.top/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-02-13T13:12:26.844Z","updated":"2020-02-13T13:12:26.844Z","comments":true,"path":"friends/index.html","permalink":"http://onlyorange.top/friends/index.html","excerpt":"","text":"这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有标签","date":"2020-02-13T13:41:09.304Z","updated":"2020-02-13T13:41:09.304Z","comments":true,"path":"tags/index.html","permalink":"http://onlyorange.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Win10和Manjaro双系统记录","slug":"Win10和Manjaro双系统记录","date":"2020-02-13T03:21:02.000Z","updated":"2020-02-13T09:03:39.887Z","comments":true,"path":"2020/02/13/Win10和Manjaro双系统记录/","link":"","permalink":"http://onlyorange.top/2020/02/13/Win10和Manjaro双系统记录/","excerpt":"疫情不能出门那就折腾win10和manjaro双系统吧！","text":"疫情不能出门那就折腾win10和manjaro双系统吧！ 一、准备工作 硬件信息 UEFI+GPT 的架构 128G SSD(已装win10) + 1T HDD 启动相关设置并分配空间 禁用快速启动 电源选项 &gt; 选择电源按钮的功能 &gt; 更改当前不可用的设置 &gt; 关机设置 &gt; [取消勾选] 启用快速启动 &gt; 保存修改 禁用安全启动(Secure Boot) 如果你想在 Win 10 的电脑上双引导 Linux ，安全机制会阻止这样做。所以需要禁用 UEFI 安全引导，以支持 Linux 的双系统启动。进入bios中将安全启动关闭 为Linux从HDD中划分80G未分配空间 准备操作系统 因为我的win10驱动出了问题，直接重装 Win10：LTSC 1909 OneDrive镜像 百度网盘镜像 Linux：Manjaro KDE Plasma 18.1.5 官方镜像 win系统推荐镜像下载地址：Windsys大量精简优化版本可供下载 二、安装系统 Windows10安装 制作PE系统(这里推荐微PE)到U盘 U盘启动进入PE，使用PG格式化C盘 打开Winouws安装器，选择镜像文件，选择安装驱动器盘为C: ,选择引导驱动器盘为EFI分区盘符一般默认为Z:。挂载盘符随便选一个。 确定，重启即可进入系统 Manjaro安装 使用镜像制作U盘启动盘(推荐Rufus、Etcher) 开始安装 CPU 独显 driver Intel 无 free/intel Intel AMD free Intel NVDIA no free AMD NVDIA no free AMD 无 free 选择手动分区，选择80G未分配空间 未分区磁盘72G，挂载点根节点/，文件系统ext4 EFI分区100M，挂载点/boot/efi，文件系统fat32，内容：保留 未分区磁盘8G，挂载点swap RAM大小 推荐的交换空间 &lt;=2G 2倍RAM 2G-8G =RAM &gt;8G 8G 三、rEFInd管理启动引导 进入manjaro，从官网下载压缩包并解压 在解压好的文件目录打开终端，执行./refind-install 调整refind配置文件，主题美化 调整启动顺序 Manjarosudo efibootmgr Win使用BOOTICE 注意事项： 如果Win10大版本更新后，发现引导界面消失，直接进入Win10，这时需要替换引导文件，调整启动顺序即可 使用Linux某发行版一段时间后，如果想使用其他发行版，请务必将之前的引导文件删除 如果Manjaro更新内核后无法进入win10，这是不可以直接修复Win10引导，这会格式化EFI分区。应修复Windows引导","categories":[],"tags":[]},{"title":"Manjaro配置命令","slug":"Manjaro配置命令","date":"2020-02-05T01:33:28.000Z","updated":"2020-02-12T07:19:49.428Z","comments":true,"path":"2020/02/05/Manjaro配置命令/","link":"","permalink":"http://onlyorange.top/2020/02/05/Manjaro配置命令/","excerpt":"Manjaro配置命令换源并更新系统1234567891011sudo pacman -Syysudo pacman-mirrors -i -c China -m ranksudo pacman -Syyusudo pacman -Sy vim # 安装vimsudo vim /etc/pacman.conf # 设定软件源分支# 增加[archlinuxcn]SigLevel = Optional TrustedOnlyServer =https://mirrors.ustc.edu.cn/archlinuxcn/$arch#sudo pacman -Syy &amp;&amp; sudo pacman -S archlinuxcn-keyring","text":"Manjaro配置命令换源并更新系统1234567891011sudo pacman -Syysudo pacman-mirrors -i -c China -m ranksudo pacman -Syyusudo pacman -Sy vim # 安装vimsudo vim /etc/pacman.conf # 设定软件源分支# 增加[archlinuxcn]SigLevel = Optional TrustedOnlyServer =https://mirrors.ustc.edu.cn/archlinuxcn/$arch#sudo pacman -Syy &amp;&amp; sudo pacman -S archlinuxcn-keyring 安装包pacman -Sy 将本地的包数据库与远程的仓库进行了同步pacman -Su 同步后的更新(与-Syu的差别是-Su只升级系统，-Syu除了升级系统还同步数据库） pacman -Syu 对整个系统进行更新pacman -S 包名 安装包pacman -Sy 包名 同步数据库后安装包pacman -Sv 包名 在显示一些操作信息后执行安装pacman -U 安装本地包,其扩展名为 pkg.tar.gzpacman -U http://www.example.com/repo/example.pkg.tar.xz 安装一个远程包（不在 pacman 配置的源里面） 删除包pacman -R 包名 该命令将只删除包，保留其全部已经安装的依赖关系pacman -Rs 包名 在删除包的同时，删除其所有没有被其他已安装软件包使用的依赖关系pacman -Rsc 包名 在删除包的同时，删除所有依赖这个软件包的程序pacman -Rd 包名 在删除包时不检查依赖 搜索包pacman -Ss 关键字：在仓库中搜索含关键字的包pacman -Qs 关键字： 搜索已安装的包pacman -Qi 包名：查看有关包的详尽信息pacman -Ql 包名：列出该包的文件 pacman -Sw 包名：只下载包，不安装pacman -Sc：清理未安装的包文件，包文件位于 /var/cache/pacman/pkg/ 目录pacman -Scc：清理所有的缓存文件 双系统统一时间12sudo timedatectl set-local-rtc true # 统一linux和Windows时间方案，调整linux为本地时间 安装搜狗输入法12345678910111213141516# 先安装中文语言包sudo pacman -Sy fcitx-im # 默认全部安装 sudo pacman -Sy fcitx-configtoolsudo pacman -Sy fcitx-sogoupinyinvim ~/.xprofile#export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=\"@im=fcitx\"#source ~/.xprofile#报错：sogou输入法异常！请删除～/.config/SougoPY并重启#尝试删除SouPY,SouPY.users,fcitx文件夹，依旧报错sogou-qimpanel # 报错sudo pacman -Sy fcitx-qt4 # 问题解决reboot 安装chrome Typora1234sudo pacman -Sy google-chormesudo pacman -Ss Typora # 查找Typora包sudo pacman -Sy Typora#yay -Sy depin-wine-tim 安装配置electron-ssr1234567sudo pacman -Ss electron-ssrsudo pacman -Sy electron-ssrsudo pacman -Ss proxychains # 全局模式无法使用请安装sudo pacman -Sy proxychains# 修改系统设置－网络－代理－使用系统代理/使用手动配置的代理服务器# HTTP代理：127.0.0.1:12333# SOCKS代理：127.0.0.1:1080 终端美化123456789101112131415161718sudo panman -Sy zsh # 默认已安装sudo vim /etc/passwd##修改user中/bin/bash为/bin/zsh#sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" # 安装oh-my-zshsudo vim ~/.zshrc#export ZSH=\"/home/azure/.oh-my-zsh\"#wget --no-check-certificate -O $ZSH_CUSTOM/themes/pi.zsh-theme https://raw.githubusercontent.com/tobyjamesthomas/pi/master/pi.zsh-theme # 下载Pi主题sudo vim ~/.zshrc#ZSH_THEME=\"pi\"# 重启终端即可 AUR助手1sudo pacman -Sy yay 配置SSH Key到Github12345678~git config --global user.email \"you@example.com\"git config --global user.name \"Your Name\"ssh-keygen -t rsa# 在github中添加～/.ssh/id_rsa.pubssh -T git@github.com# Hi 'user' You've successfully authenticated, but GitHub does not provide shell access. 安装hexo12345678sudo pacman -Sy nodejssudo pacman -Sy npmnode -v # v13.7.0npm -v # 6.13.6sudo npm或cnpm config set registry https://registry.npm.taobao.org # npm换淘宝源sudo npm install hexo-cli -g sudo npm install hexo --save hexo -v 清理12345sudo pacman -R $(pacman -Qdtq) # 清理系统中无用包sudo pacman -Scc # 清除已下载安装包du -t 100M /var # 查看日志垃圾journalctl --disk-usage # 查看日志垃圾sudo journalctl --vacuum-size=50M # 删除指定大小日志文件","categories":[{"name":"Linux","slug":"Linux","permalink":"http://onlyorange.top/categories/Linux/"}],"tags":[{"name":"Manjaro","slug":"Manjaro","permalink":"http://onlyorange.top/tags/Manjaro/"}]},{"title":"资格复审","slug":"资格复审","date":"2020-01-20T13:27:05.000Z","updated":"2020-02-11T09:17:59.689Z","comments":true,"path":"2020/01/20/资格复审/","link":"","permalink":"http://onlyorange.top/2020/01/20/资格复审/","excerpt":"北京选调生资格复审时间 流程 时间 地址/网址 资格复审 2020/02/03–2020/02/05 登录招录机关网站查询资格复审的时间及地点 面试名单公示 2020/02/10 北京市人力资源和社会保障局网站 调剂职位和符合调剂条件人员名单公示 2020/02/10 北京市人力资源和社会保障局网站 调剂报名 2020/02/11/9:00–2020/02/12/18:00 北京市人力资源和社会保障局网站 调剂资格审查 2020/02/13/9:00–2020/02/14/18:00 电话通知 调剂人选名单公示 2020/2/17 北京市人力资源和社会保障局网站 面试 2020/3/2–2020/3/8 未通知","text":"北京选调生资格复审时间 流程 时间 地址/网址 资格复审 2020/02/03–2020/02/05 登录招录机关网站查询资格复审的时间及地点 面试名单公示 2020/02/10 北京市人力资源和社会保障局网站 调剂职位和符合调剂条件人员名单公示 2020/02/10 北京市人力资源和社会保障局网站 调剂报名 2020/02/11/9:00–2020/02/12/18:00 北京市人力资源和社会保障局网站 调剂资格审查 2020/02/13/9:00–2020/02/14/18:00 电话通知 调剂人选名单公示 2020/2/17 北京市人力资源和社会保障局网站 面试 2020/3/2–2020/3/8 未通知 资格复审材料 网上打印的报名表 成绩通知书 身份证原件 报考职位资格要求的相关等级、资格证书原件（如要求才需要） 学生证 就业推荐表 校级以上“三好学生”“优秀学生干部”、校级一等以上“优秀学生”奖学金的获奖证书原件（若有需提交） 校级教务部门盖章的已修课程成绩单（选调生特有） 注意事项 由于资格复审未通过而产生面试人选空缺的职位，由招录机关按照该职位通过合格分数线人员成绩由高到低的顺序通知考生依次递补； 请考生登录招录机关网站查询资格复审的时间及地点，并保持报名时提供的联系电话畅通，及时参加资格复审； 资格复审当天本人不能到场的，可由他人代理进行现场资格复审，代理人须另携带本人身份证件。 确定首批面试人选根据考生现场资格复审情况和招考公告公布的计划录用人数与面试人选的比例，按照通过笔试合格分数线并且资格复审合格人员成绩从高到低的顺序，确定首批参加面试和专业能力测试的人选名单。该名单拟于2月10日在北京市人力资源和社会保障局网站公布。 关于调剂 什么情况下会有调剂岗位？ 首批参加面试和专业能力测试人选未达到招考公告公布的面试比例人数的招录职位为调剂职位，将采用调剂的办法补充面试人选。调剂职位和符合调剂条件人员名单将于2月10日在北京市人力资源和社会保障局网站统一公布。 你是否满足调剂？ 调剂在公共科目笔试内容相同（即指报考人员应答的是同一类试卷）的职位之间进行； 已进入首批面试人选名单的考生不得参加调剂； 只能申请一个调剂职位； 应当符合调剂职位规定的资格条件和要求； 笔试成绩应当达到拟调剂职位的合格分数线； 原报考选调生职位的考生在参加调剂时，既可申请调剂选调生职位，也可申请调剂到其他职位。（原报考非选调生职位的考生在参加调剂时，只能申请调剂非选调生职位）； 怎么报名参加调剂？ 调剂报名采用网络报名方式进行，2月11日9:00至2月12日18:00，考生可通过报名时的用户名和密码登录北京市人力资源和社会保障局网站，填报申请调剂的相关信息。考生对调剂职位所需专业、学历、学位、资格条件以及备注的内容等信息需要咨询时，请直接与招录机关联系。在提交调剂申请时间结束之前，考生可以重新选择申请调剂的职位。 考生可于2月12日18：00后打印《北京市各级机关2020年度考试录用公务员调剂报名表》。 调剂资格审查？ 调剂资格审查工作由各市级招录机关、区级公务员主管部门负责，调剂资格审查时间为2月13日9:00至2月14日18:00。 各市级招录机关、区级公务员主管部门将于2月13日根据调剂报名考生的笔试成绩，按照调剂职位空缺名额，由高到低电话通知进入调剂范围的考生参加调剂资格审查，调剂报名考生因笔试成绩相同超出职位空缺名额时，同时进入调剂资格审查。 进入调剂资格审查范围的考生须持《北京市各级机关2020年度考试录用公务员调剂报名表》等有关材料参加调剂资格审查，参加调剂资格审查须提供材料及注意事项与资格复审的要求一致。 调剂资格审查合格人数达到规定的调剂人数后，各市级招录机关、区级公务员主管部门不再对其他考生进行调剂资格审查。 调剂资格审查结束后，各市级招录机关、区级公务员主管部门根据调剂职位空缺名额，按照成绩由高到低确定调剂人选名单。调剂人选名单将于2月17日在北京市人力资源和社会保障局网站公布。 面试面试将于3月2日至3月8日进行，面试工作按照《公务员录用面试组织管理办法（试行）》由各市级招录机关、区级公务员主管部门统一组织。个别参加面试人数与录用计划数比例低于3：1的职位，参加面试人员面试成绩应达到其所在面试考官小组使用同一套面试题本面试的所有人员的平均分或者招录机关在面试公告中确定的面试合格分数线，方可进入体检和考察。 面试和专业能力测试结束后，将按照综合成绩从高到低的顺序确定进入体检和考察的人选。","categories":[],"tags":[]},{"title":"浙大数据结构笔记","slug":"浙大数据结构笔记","date":"2019-11-14T08:02:23.000Z","updated":"2020-01-08T13:18:06.212Z","comments":true,"path":"2019/11/14/浙大数据结构笔记/","link":"","permalink":"http://onlyorange.top/2019/11/14/浙大数据结构笔记/","excerpt":"Data Structures一、基本概念1.1 什么是数据结构1.1.1 其他定义 数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。 ——Sartaj Sahni 《数据结构、算法与应用》 数据结构是 ADT（Abstract Data Type，数据抽象类型）的物理实现。 ——Clifford A.Shaffer 《数据结构与算法分析》 数据结构（data structure）是计算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来最优效率的算法。 ——中文维基百科","text":"Data Structures一、基本概念1.1 什么是数据结构1.1.1 其他定义 数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。 ——Sartaj Sahni 《数据结构、算法与应用》 数据结构是 ADT（Abstract Data Type，数据抽象类型）的物理实现。 ——Clifford A.Shaffer 《数据结构与算法分析》 数据结构（data structure）是计算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来最优效率的算法。 ——中文维基百科 1.1.2 解决问题方法的效率 跟数组的组织方式有关 跟空间的利用效率有关 跟算法的巧妙程度有关 1.1.3 最终定义 数据对象在计算机中的组织方式 逻辑结构 物理存储结构 数据对象必定与一系列加在其上的操作相关联 完成这些操作所用的方法就是算法 1.1.4 抽象数据类型（Abstract Data Type） 数据类型 数据对象集 数据集合相关联的操作集 抽象：描述数据类型的方法不依赖于具体实现 与存放数据的机器无关 与数据存储的物理结构无关 与实现操作的算法和编程语言均无关 只描述数据对象集和相关操作集“是什么”，并不涉及“如何做到”的问题 1.2 什么是算法1.2.1 定义 一个有限指令集 ≥ 0 的输入 0 的输出 一定在有限步骤之后终止 每一条指令必须 有充分明确的目标，不可以有歧义 计算机能处理范围内 描述应不依赖于任何一种计算机语言以及具体的实现手段 1.2.2 描述算法的手段 空间复杂度 S(n) 根据算法写成的程序在执行时占用存储空间的长度 时间复杂度 T(n) 根据算法写成的程序在执行时耗费的时间的长度 1.2.3 评价 在分析一般算法的效率时，常常关注","categories":[{"name":"笔记","slug":"笔记","permalink":"http://onlyorange.top/categories/笔记/"}],"tags":[{"name":"Data Structures","slug":"Data-Structures","permalink":"http://onlyorange.top/tags/Data-Structures/"}]},{"title":"hexo博客美化","slug":"hexo博客美化","date":"2019-11-13T03:24:43.000Z","updated":"2020-02-12T05:27:07.195Z","comments":true,"path":"2019/11/13/hexo博客美化/","link":"","permalink":"http://onlyorange.top/2019/11/13/hexo博客美化/","excerpt":"","text":"Hexo博客个性化美化【01】主题的选择将NexT7.0换为Material X 下载主题源码到 themes/ 文件夹 1git clone https://github.com/xaoxuu/hexo-theme-material-x themes/material-x 然后安装必要的依赖包 1npm i -S hexo-generator-search hexo-generator-json-content hexo-renderer-less 修改站点配置文件 1theme: material-x","categories":[{"name":"blog","slug":"blog","permalink":"http://onlyorange.top/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://onlyorange.top/tags/hexo/"}]},{"title":"工作技能/经验","slug":"工作技能-经验","date":"2019-10-19T05:51:57.000Z","updated":"2020-01-08T13:18:06.212Z","comments":true,"path":"2019/10/19/工作技能-经验/","link":"","permalink":"http://onlyorange.top/2019/10/19/工作技能-经验/","excerpt":"嵌入式相关工作需要的技能经验列举嵌入式系统软件工程师__ 高通无线通信技术(中国)有限公司__北京 熟练掌握C/C++, Linux shell 编程语言，具有Python/Perl/Java/Makefile经验更佳； 熟悉Linux操作系统，驱动，内核开发。 例如以下领域，u-boot, PCIe/PCI, Ethernet, DDR, LCD,Camera, USB, and Power Management； 了解CPU架构，例如ARM，MIPS更佳； 了解机器学习更佳； 优秀的中英文沟通技巧； 快速学习能力； 基本的问题解决能力； 通信，计算机，电子等相关专业，本科及以上学历。 新零售技术事业群-嵌入式系统工程师__ 阿里巴巴集团__杭州工作职责： 参与工厂数字化改造方案中嵌入式IoT设备端的开发工作； 负责多个IoT设备系列的嵌入式端侧软件架构设计； 探索当前互联网主流框架与嵌入式IoT设备端侧架构的创新结合，如Flutter、Node.js等技术在嵌入式端侧的应用","text":"嵌入式相关工作需要的技能经验列举嵌入式系统软件工程师__ 高通无线通信技术(中国)有限公司__北京 熟练掌握C/C++, Linux shell 编程语言，具有Python/Perl/Java/Makefile经验更佳； 熟悉Linux操作系统，驱动，内核开发。 例如以下领域，u-boot, PCIe/PCI, Ethernet, DDR, LCD,Camera, USB, and Power Management； 了解CPU架构，例如ARM，MIPS更佳； 了解机器学习更佳； 优秀的中英文沟通技巧； 快速学习能力； 基本的问题解决能力； 通信，计算机，电子等相关专业，本科及以上学历。 新零售技术事业群-嵌入式系统工程师__ 阿里巴巴集团__杭州工作职责： 参与工厂数字化改造方案中嵌入式IoT设备端的开发工作； 负责多个IoT设备系列的嵌入式端侧软件架构设计； 探索当前互联网主流框架与嵌入式IoT设备端侧架构的创新结合，如Flutter、Node.js等技术在嵌入式端侧的应用 任职要求： 5年以上嵌入式开发经验，精通C/C++编程语言，熟悉面向对象编程和常用的设计模式，具有良好的编码规范； 精通Node.js、Python、Lua等脚本语言，熟悉设计模式，具备架构能力； 有各类工业现场协议对接经验的优先； 沟通能力强，有较强的自我驱动力和快速学习能力。责任心强，具备良好团队合作精神； 具备极客精神，熟练使用常见数据结构，算法，熟悉队列、消息、多线程、网络编程、事件机制等技术的应用； 追求优雅的工程实现和问题解决 加分项： 精通基于linux的底层系统构建，如uboot,kernel等在不同方案上的移植、优化； 熟悉MTK/RK/TI/NXP等一家或多家主控芯片的产品化引用； 具备技术产品的设计、架构和实现能力，有强烈的进取心推进产品化实现； 嵌入式软件开发工程师__ 天津深之蓝海洋设备科技有限公司__天津工作职责： STM32嵌入式软件开发。 任职要求： 本科及以上学历； 一年及以上嵌入式软件工作经验； 具有STM32嵌入式软件开发经验； 熟悉UCOSIIRTOS、FreeRTOS、RTX、RT-Thread至少一种嵌入式操作系统，具有掌握RTX、RT-Thread操作系统的优先考虑； 嵌入式软件工程师__ 科沃斯__苏州工作职责： 参与软件系统的方案设计，负责公司机器人产品软件开发； 不同平台下软件分析规划、功能模块开发和技术难点攻关； 负责软件设计、代码编写和调试； 负责相关技术文档的编写； 负责指导助理软件工程师的开发工作，提供技术支持。 任职要求： 精通C/C++语言，精通数据结构，具有良好的代码编写习惯； 熟悉MCU/ARM处理器架构，熟练掌握软件编译环境和软件调试工具； 熟练各种常用硬件接口和传感器设备的驱动开发和调试，有网络通信（wifi、蓝牙、Zigbee等）相关经验； 有一定的算法学习研究、分析设计能力，对机器人技术感兴趣，具有创新思维； 有较强的分析和解决问题能力，有持续自我学习的能力和意愿，善于沟通和逻辑表达 工作积极主动，具有团队协作能力，服从领导安排。 加分项： 有FreeRTOS开发经验者优先； 有软件底层开发经验者优先。 机器人导航算法开发__ 石头科技__北京工作职责: 负责开发机器人的行走，转向，脱困，避障等算法 职位要求： 三年以上C++编程经验，精通常用算法和数据结构 熟悉Linux编程和常用的调试工具 有室内定位和运动控制开发经验的优先 机器人系统软件开发__ 石头科技__北京工作职责: 负责开发优化机器人系统架构，系统升级和系统安全软件 职位要求: 三年以上C++编程经验，熟悉常用算法和数据结构 深入理解Linux操作系统，了解系统内核和文件系统 了解常用的设计模式 嵌入式系统工程师__ Calmcar(天瞳威视)__天津工作职责： 开发和优化基于DSP/ARM的视觉算法 配合硬件工程师及FPGA工程师完成相关的测试及接口定义 设计文档的整理、撰写及审核，做好转生产工作，确保产品的小批量、批量生产的顺利进行 任职要求： 计算机、电子通信等相关专业，具有相关项目开发3-5年经验 丰富的编程经验，C/C++ ，熟悉瑞萨、TI等平台 丰富的电子开发经验，Digital and Analog Design 熟悉DSP/ARM架构，能完成程序的移植及优化 具备较强的软件设计文档编写能力 工作认真负责，具有较强的承压能力 具有较强的沟通协调能力、学习能力以及良好的团队合作精神 加分项： 熟悉汽车电子，比如CAN，汽车线束 熟悉机器学习与模式识别技术 熟悉图像识别领域的常见工具，如OpenCV 熟悉CUDA 了解FMEA、Six Sigma流程 热爱汽车电子技术 FPGA工程师__ Calmcar(天瞳威视)__天津工作职责： 基于Xilinx和Altera FPGA平台的逻辑设计 对视觉产品进行FPGA方案设计、 编码、 仿真、 调试、 测试 机器视觉产品的算法设计、 仿真、 优化以及实现 基于ZYNQ SOC平台的图像算法的移植、 验证与实现 产品测试方案的设计， 完成产品测试流程 NVDIA开发 撰写详细的开发文档和测试文档 任职要求: 大学本科及以上学历，3-5年工作经验 测控技术与仪器、通讯工程、电子信息工程、自动化工程、计算机等相关专业 熟练掌握verilog语言，掌握C/C++语言 有SDSoC或PetaLinux开发经验者优先 熟悉Matlab或者Opencv图像仿真平台者优先 熟悉硬件电路开发者优先 高级嵌入式软件工程师(相机)__dji工作职责 负责相机核心功能模块的设计、开发与调试； 负责新技术的调研与难题攻关； 负责产品功能、性能及稳定性等方面的调优； 负责指导新员工的开发工作。 任职要求 计算机、电子相关专业毕业，本科及以上学历；5年以上嵌入式软件开发经验，熟悉软件开发流程，具有较强的软件设计和开发能力； 精通C语言、数据结构，具有良好的代码编写习惯； 精通基于ARM的嵌入式软件开发和调试，精通编译工具及调试工具的使用； 精通Linux或者任意一款主流嵌入式操作系统的移植、裁剪、驱动开发和应用开发； 具有很强的独立开发能力，以及问题分析、解决能力；具有一定的硬件知识，能看懂原理图；具有良好的沟通能力和团队合作精神，具有较强的抗压能力；有相机相关开发经验者优先。 高级嵌入式软件工程师(Android系统方向) __dji工作职责 负责Android系统ROM定制以及Android平台产品化开发； 负责系统UI裁剪和定制化开发，对Android HAL和Framework相关模块进行优化； 负责系统显示性能优化，提升产品体验； 根据公司的产品需求，开发相应的Framework服务及系统应用。 任职要求 统招本科及以上学历，计算机科学、电子工程、通信相关专业毕业； 5年以上Android系统开发经验，精通C/C++语言，熟悉Linux Kernel及驱动开发，了解Java编程； 熟悉Android系统框架，具备较强的开发、调试、性能优化能力，熟练使用Systrace、Traceview等工具； 熟悉Android系统的UI显示机制，有显示系统开发及性能调优的工作经验； 对ACodec、MediaCodec、OMX、SurfaceFlinger、HWC等有深入理解； 熟悉V4L2架构，熟悉Android系统的camera框架； 能熟练编写及阅读shell脚本，熟悉git版本管理工具，熟悉gerrit及jenkins环境者更佳； 具备丰富的Android手机产品系统开发经验者优先考虑； 能承担较大工作压力，工作认真负责，积极主动。 高级嵌入式软件优化工程师__dji工作职责 感知算法在嵌入式平台上的资源消耗评估，指导算法工程师按嵌入式平台的限制优化算法； 感知算法在嵌入式处理器上的软件移植，优化，集成，调试； 感知算法硬件加速器的驱动，集成，调试。 任职要求 硕士及以上学历，5年以上相关工作经验； 精通C/C++； 精通DSP或NEON代码优化；熟悉vector C或intrinsic C编程； 熟悉cache，DMA等memory优化技能。 嵌入式软件架构师__dji工作职责 收集并分析市场和产品需求，完成架构设计； 制定相关技术演进的roadmap，以及实施计划； 带领团队设计并开发复杂异构的操作系统以及多媒体系统解决方案，满足不同应用场景的需求； 设计要求高稳定性、低功耗、高性能、高安全性等的软硬件解决方案； 深入理解产品，参与产品的整个生命周期的开发过程，包括需求定义、设计、实现、测试、生产、售后等； 制定和改善软件的开发流程； 跟踪嵌入式领域最新的技术发展，对团队进行技术指导。 任职要求 EE，CE，CS或同等专业硕士及以上学位，6年以上相关开发经验，1年以上架构师经验； 深度参与至少1款产品的架构设计，对于设计简单、高复用、高扩展、高可靠、高性能、低功耗的架构有深入理解和体会； 丰富的嵌入式软件开发经验，如：操作系统（RTOS、Linux、Android）、安全、媒体链路、GPU等； 深入理解SoC架构，以及系统优化方法，如NEON、DSP、GPU等； 具有较强的开发和编程实践能力，以及良好的质量意识； 至少参与过一款产品的敏捷开发实践，如：Scrum、Kanban等； 良好的沟通协调能力，以及较好的驱动力； 良好的学习能力及团队领导力，喜欢挑战。 高级嵌入式软件工程师（感知）工作职责 嵌入式软件开发流程和规范的梳理和把控； 视觉感知功能在嵌入式处理器上的方案设计、功能开发、性能分析与优化、系统级问题定位等； RTOS在嵌入式处理器上的移植、开发、调试。 任职要求 本科及以上学历，五年以上相关工作经验； 精通C/C++； 精通至少一种嵌入式RTOS（如freeRTOS、threadx、nucleus、QNX…），有RTOS移植经验； 精通实时性、调度抢占、中断优先级、中断嵌套、优先级翻转等问题； 责任心强、有良好的合作精神、有较强的学习能力和沟通协调能力； 有图像处理或视觉感知相关工作者优先，有硬件开发调试经验者优先，有Linux编程开发经验者优先。 高级嵌入式软件工程师（LinuxKernel方向）工作职责 负责uboot、kernel和Android hal层的移植； 负责Linux应用、内核和设备驱动程序的开发； 负责Android APP、Framework和Native层的开发； 参与无线图传相关的业务代码的编写； 参与测试用例的制定及测试文档的编写。 任职要求 熟悉uboot、kernel和Android hal层的移植，有过不同芯片平台的移植经验； 熟悉Linux应用（多进程、多线程、网络等）、内核（内存管理、进程管理、中断、锁、文件系统等）的开发及调试方法； 熟悉Linux设备驱动的开发（USB、EMMC、HDMI、Audio等），具备定位硬件问题的能力； 熟悉Android Framework和Native层的工作原理，能对AMS/WMS/SurfaceFlinger等进行优化，具备添加新组件的能力； 熟悉Android APP层的开发，能对系统应用进行定制和优化，能开发简单的用户应用； 具备Android系统性能优化的经验，能充分发挥CPU、GPU、DDR、VPU等硬件的极限性能，提升系统流畅度和稳定性； 了解音视频编解码算法和无线通信原理（WIFI/SDR）的优先。 高级嵌入式软件工程师（导航）工作职责 负责职能功能模块的设计、开发和调试； 负责产品功能、性能和稳定性等方面的优化； 负责指导组内软件同事的开发和技术深度的提高。 任职要求 计算机、电子相关专业毕业，本科及以上学历；5年以上嵌入式软件开发经验，熟悉软件开发流程，具有较强的软件设计和开发能力； 精通C&amp;C++语言、数据结构，具有良好的代码编写习惯； 丰富的Linux应用开发经验，有嵌入式软件架构设计相关经验优先考虑； 精通基于ARM的嵌入式软件开发和调试，精通编译工具以及调试工具的使用； 具有很强的独立开发能力，以及问题分析、解决能力； 具有良好的沟通能力和团队合作能力，具有较强的抗压能能力；有计算机视觉系统相关开发经验者优先。","categories":[{"name":"job","slug":"job","permalink":"http://onlyorange.top/categories/job/"}],"tags":[{"name":"skill","slug":"skill","permalink":"http://onlyorange.top/tags/skill/"}]},{"title":"MPU6050姿态结算","slug":"MPU6050姿态结算","date":"2019-10-13T03:33:28.000Z","updated":"2020-02-15T03:10:27.902Z","comments":true,"path":"2019/10/13/MPU6050姿态结算/","link":"","permalink":"http://onlyorange.top/2019/10/13/MPU6050姿态结算/","excerpt":"MPU6050简介IMU（Inertial measurement unit），中文翻译为惯性测量单元，是一种能够测量物体三轴加速度和角速度进而解算出物体姿态的装置。一般的，一个IMU包含了三个单轴的加速度计和三个单轴的陀螺仪，加速度计检测物体在载体坐标系统独立三轴的加速度信号，而陀螺仪检测载体相对于导航坐标系的角速度信号，测量物体在三维空间中的角速度和加速度，并以此解算出物体的姿态。在导航中有着很重要的应用价值。为了提高可靠性，还可以为每个轴配备更多的传感器，例如地磁传感器。MPU6050属于IMU的一种，包含了三个单轴的加速度计和三个单轴的陀螺仪。 加速度计原理与姿态解算 陀螺仪原理与姿态解算 融合加速度计和陀螺仪的数据","text":"MPU6050简介IMU（Inertial measurement unit），中文翻译为惯性测量单元，是一种能够测量物体三轴加速度和角速度进而解算出物体姿态的装置。一般的，一个IMU包含了三个单轴的加速度计和三个单轴的陀螺仪，加速度计检测物体在载体坐标系统独立三轴的加速度信号，而陀螺仪检测载体相对于导航坐标系的角速度信号，测量物体在三维空间中的角速度和加速度，并以此解算出物体的姿态。在导航中有着很重要的应用价值。为了提高可靠性，还可以为每个轴配备更多的传感器，例如地磁传感器。MPU6050属于IMU的一种，包含了三个单轴的加速度计和三个单轴的陀螺仪。 加速度计原理与姿态解算 陀螺仪原理与姿态解算 融合加速度计和陀螺仪的数据 需要姿态融合的原因为什么要有同时具备加速度计和陀螺仪。看了上面的介绍，我们发现单单通过加速度计或者陀螺仪就能解算出物体姿态，为什么IMU要同时具备两种功能相似的仪器呢？ 答案很简单：加速度计的数据不是100%准确的。有几个原因，还记加速度计测量的是惯性力，这个力可以由重力引起（理想情况只受重力影响），当也可能由设备的加速度（运动）引起。因此，就算加速度计处于一个相对比较平稳的状态，它对一般的震动和机械噪声很敏感。这就是为什么大部分的IMU系统都需要陀螺仪来使加速度计的输出更平滑。但是怎么办到这点呢？陀螺仪不受噪声影响吗？ 陀螺仪也会有噪声，但由于它检测的是旋转，因此对线性机械运动没那么敏感，不过陀螺仪有另外一种问题，比如漂移（当选择停止的时候电压不会回到零速率电压）并且陀螺仪是通过对旋转角度的累加进行姿态解算，所以长时间工作会有极大的误差。然而，通过计算加速度计和陀螺仪的平均值我们能得到一个相对更准确的当前设备的倾角值，这比单独使用加速度计更好。 通过上面的分析我们可以发现，加速度计短时间内精度较差，而长时间稳定性好，陀螺仪短时间内精度高，但会累计误差，只要将两者的数据进行互补，就能解算出正确的姿态。 姿态融合MPU6050 是一款姿态传感器，使用它就是为了得到待测物体（如四轴、平衡小车） x、y、z 轴的倾角（俯仰角 Pitch、滚转角 Roll、偏航角 Yaw） 。我们通过 I2C 读取到 MPU6050 的六个数据（三轴加速度 AD 值、三轴角速度 AD 值）经过姿态融合后就可以得到 Pitch、Roll、Yaw 角。本帖主要介绍三种姿态融合算法： 四元数法 一阶互补算法 卡尔曼滤波算法。 四元数法 关于四元数的一些概念和计算就不写上来了，我也不懂。我能告诉你的是：通过下面的算法，可以把六个数据转化成四元数（q0、q1、q2、q3），然后四元数转化成欧拉角（P、R、Y 角）。 ​ 虽然 MPU6050 自带的 DMP库可以直接输出四元数，减轻 STM32 的运算负担， 这里在此没有使用，因为我是用 STM32 的硬件 I2C 读取 MPU6050 数据的（http://bbs.elecfans.com/forum.ph … 4&amp;page=1#pid3625735） DMP库需要对 I2C 函数进行修改，如 DMP 库中的 I2C 写：i2c_write(st.hw-&gt;addr, st.reg-&gt;pwr_mgmt_1, 1, &amp;(data[0]))；有4个输入变量，而 STM32 硬件 I2C 的 I2C 写为：void MPU6050_I2C_ByteWrite(u8 slaveAddr, u8 pBuffer, u8 writeAddr)，只有 3 个输入量（这之间的差异好像是由于 MPU6050 的 DMP 库是针对 MSP430 单片机写的），所以必须进行修改，但是改固件库是一件很痛苦的事，你们应该都懂。当然，如果你用模拟 I2C 的话，是容易实现的，网上的 DMP 移植几乎都是基于模拟 I2C 的。 要注意的的是，四元数算法输出的是三个量 Pitch、Roll 和 Yaw，运算量很大。而像平衡小车这样的例子只需要一个角（Pitch 或 Roll ）就可以满足工作要求，个人觉得做平衡小车最好不用四元数法。 一阶互补算法 MPU6050 可以输出三轴的加速度和角速度。通过加速度和角速度都可以得到 Pitch 和 Roll 角（加速度不能得到 Yaw 角），就是说有两组 Pitch、Roll 角，到底应该选哪组呢？别急，先分析一下。MPU6050 的加速度计和陀螺仪各有优缺点，三轴的加速度值没有累积误差，且通过算 tan() 可以得到倾角，但是它包含的噪声太多（因为待测物运动时会产生加速度，电机运行时振动会产生加速度等），不能直接使用；陀螺仪对外界振动影响小，精度高，通过对角速度积分可以得到倾角，但是会产生累积误差。所以，不能单独使用 MPU6050 的加速度计或陀螺仪来得到倾角，需要互补。一阶互补算法的思想就是给加速度和陀螺仪不同的权值，把它们结合到一起，进行修正。得到 Pitch 角的程序如下： 123456789101112131415161718192021//一阶互补滤波float K1 =0.1; // 对加速度计取值的权重float dt=0.001;//注意：dt的取值为滤波器采样时间float angle_P,angle_R; //angle_ax=atan(ax/az)*57.3; //加速度得到的角度//gy=(float)gyo[1]/7510.0; //陀螺仪得到的角速度Pitch = yijiehubu_P(angle_ax,gy);Roll = yijiehubu_R(angle_ax,gy);float yijiehubu_P(float angle_m, float gyro_m)//采集后计算的角度和角加速度&#123; angle_P = K1 * angle_m + (1-K1) * (angle_P + gyro_m * dt); return angle_P;&#125; float yijiehubu_R(float angle_m, float gyro_m)//采集后计算的角度和角加速度&#123; angle_R = K1 * angle_m + (1-K1) * (angle_R + gyro_m * dt); return angle_R;&#125; 互补算法只能得到一个倾角，这在平衡车项目中够用了，而在四轴飞行器设计中还需要 Roll 和 Yaw，就需要两个 互补算法。单靠 MPU6050 无法准确得到 Yaw 角，需要和地磁传感器结合使用。 卡尔曼滤波 其实卡尔曼滤波和一阶互补有些相似，输入也是一样的。在此给出具体程序，和一阶互补算法一样，每次卡尔曼滤波只能得到一个方向的角度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;math.h&gt;#include \"stm32f10x.h\"#include \"Kalman_Filter.h\" //卡尔曼滤波参数与函数float dt=0.001;//注意：dt的取值为kalman滤波器采样时间float angle, angle_dot;//角度和角速度float P[2][2] = &#123;&#123; 1, 0 &#125;, &#123; 0, 1 &#125;&#125;;float Pdot[4] =&#123; 0,0,0,0&#125;;float Q_angle=0.001, Q_gyro=0.005; //角度数据置信度,角速度数据置信度float R_angle=0.5 ,C_0 = 1;float q_bias, angle_err, PCt_0, PCt_1, E, K_0, K_1, t_0, t_1; //卡尔曼滤波float Kalman_Filter(float angle_m, float gyro_m)//angleAx 和 gyroGy &#123; angle+=(gyro_m-q_bias) * dt; angle_err = angle_m - angle; Pdot[0]=Q_angle - P[0][1] - P[1][0]; Pdot[1]=- P[1][1]; Pdot[2]=- P[1][1]; Pdot[3]=Q_gyro; P[0][0] += Pdot[0] * dt; P[0][1] += Pdot[1] * dt; P[1][0] += Pdot[2] * dt; P[1][1] += Pdot[3] * dt; PCt_0 = C_0 * P[0][0]; PCt_1 = C_0 * P[1][0]; E = R_angle + C_0 * PCt_0; K_0 = PCt_0 / E; K_1 = PCt_1 / E; t_0 = PCt_0; t_1 = C_0 * P[0][1]; P[0][0] -= K_0 * t_0; P[0][1] -= K_0 * t_1; P[1][0] -= K_1 * t_0; P[1][1] -= K_1 * t_1; angle += K_0 * angle_err; //最优角度 q_bias += K_1 * angle_err; angle_dot = gyro_m-q_bias;//最优角速度 return angle；&#125; 三种融合算法都能够输出姿态角（Pitch 和 Roll ），一次四元数法可以输出 P、R、Y 三个倾角，计算量比较大。一阶互补和卡尔曼滤波每次只能输出一个轴的姿态角。 陀螺仪漂移的解决方法横滚角和俯仰角的偏差可以通过卡尔曼滤波或者一阶互补滤波即可消除漂移量. 但是航向角存在的偏差很难由自身来校准,这是由于:Z轴在静止状态下没有漂移，运动情况下有累积误差。因为Z轴角度是通过对角速度积分计算出来的，没有观测量滤波，所以漂移是不可避免的。X、Y轴的角度是根据重力加速度分量计算，X，Y轴是有重力场滤波，所以不会有漂移。Z轴只能用短时间内的相对测量量。 就是相邻两次的角度差来计算转过的角度。 可以采用带地磁的9轴陀螺仪来降低漂移量,但是仍然无法完全解决这个问题.而且地磁计对周围磁场的变化敏感,多磁场和多电机的工作环境都会导致地磁计不准.","categories":[{"name":"嵌入式系统","slug":"嵌入式系统","permalink":"http://onlyorange.top/categories/嵌入式系统/"}],"tags":[{"name":"IMU传感器","slug":"IMU传感器","permalink":"http://onlyorange.top/tags/IMU传感器/"}]},{"title":"C/C++ sizeof函数总结","slug":"C-C-sizeof函数总结","date":"2019-10-12T07:42:20.000Z","updated":"2020-01-08T13:18:06.197Z","comments":true,"path":"2019/10/12/C-C-sizeof函数总结/","link":"","permalink":"http://onlyorange.top/2019/10/12/C-C-sizeof函数总结/","excerpt":"解决sizeof求结构体大小的问题一、C/C++中不同数据类型所占用的内存大小 数据类型 32位 64位 char 1 1 int 4 大多数4(少数8) short 2 2 long 4 8 float 4 4 double 8 8 *指针 4 8 （单位都为字节） 结构体(struct)：比较复杂，对齐问题需要考虑清楚。 联合(union)：取所有成员中最长的作为联合的长度。 枚举(enum)：根据数据类型。","text":"解决sizeof求结构体大小的问题一、C/C++中不同数据类型所占用的内存大小 数据类型 32位 64位 char 1 1 int 4 大多数4(少数8) short 2 2 long 4 8 float 4 4 double 8 8 *指针 4 8 （单位都为字节） 结构体(struct)：比较复杂，对齐问题需要考虑清楚。 联合(union)：取所有成员中最长的作为联合的长度。 枚举(enum)：根据数据类型。 二、sizeof计算单层结构体大小运算符sizeof可以计算出给定类型的大小，对于32位系统来说， sizeof(char) = 1; sizeof(int) = 4。 基本数据类型的大小很好计算，我们来看一下如何计算构造数据类型的大小。 C语言中的构造数据类型有三种 数组 结构体 共用体 数组是相同类型的元素的集合，只要会计算单个元素的大小，整个数组所占空间等于基础元素大小乘上元素的个数。 结构体中的成员可以是不同的数据类型，成员按照定义时的顺序依次存储在连续的内存空间。和数组不一样的是，结构体的大小不是所有成员大小简单的相加，需要考虑到系统在存储结构体变量时的地址对齐问题。看下面这样的一个结构体： 123456struct stu1&#123; int i; char c; int j;&#125; 用sizeof求该结构体的大小，发现值为12。int占4个字节，char占1个字节，结果应该是9个字节才对啊，为什么呢？ 先介绍一个相关的概念——偏移量。偏移量指的是结构体变量中成员的地址和结构体变量地址的差。结构体大小**等于最后一个成员的偏移量加上最后一个成员的大小**。显然，结构体变量中第一个成员的地址就是结构体变量的首地址。因此，第一个成员i的偏移量为0。第二个成员c的偏移量是第一个成员的偏移量加上第一个成员的大小（0+4）,其值为4；第三个成员j的偏移量是第二个成员的偏移量加上第二个成员的大小（4+1）,其值为5。 然而，在实际中，存储变量时地址要求对齐，编译器在编译程序时会遵循两条原则： 结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍） 结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。 上面的例子中前两个成员的偏移量都满足要求，但第三个成员的偏移量为5，并不是自身(int)大小的整数倍。编译器在处理时会在第二个成员后面补上3个空字节，使得第三个成员的偏移量变成8。结构体大小等于最后一个成员的偏移量加上其大小，上面的例子中计算出来的大小为12，满足要求。 再来看另外一个例子： 12345struct stu2&#123; int k; short t;&#125; 成员k的偏移量为0；成员t的偏移量为4，都不需要调整。但计算出来的大小为6，显然不是成员k大小的整数倍。因此，编译器会在成员t后面补上2个字节，使得结构体的大小变成8从而满足第二个要求。 由此可见，结构体类型需要考虑到字节对齐的情况. 不同的顺序也会影响结构体的大小 对比下面两种定义顺序： 123456789101112struct stu3 &#123; char c1; int i; char c2; &#125; struct stu4 &#123; char c1; char c2; int i; &#125; 虽然结构体stu3和stu4中成员都一样，但sizeof(struct stu3)的值为12而sizeof(struct stu4)的值为8 共用体中的成员公用同一段内存，所以整个联合体的sizeof是所有成员中占用内存最大的成员的sizeof，联合体要考虑内存对齐，整体空间长度要是公用体中长度最大的数据类型的整数倍 1234union st&#123; char a[9]; int b[2];&#125;s 结果分析： sizeof(a)=9*1=9 sizeof(b)=2*4=8 选两者中最大的一个，即9，考虑内存对齐，整体空间长度要是公用体中长度最大的数据类型的整数倍，在这里是int占用空间的整数倍，比9大的且是4的整数倍的最小数是12 拓展枚举类enum型空间计算 enum只是定义了一个常量集合，里面没有“元素”，而枚举类型是当做int来存储的，所以枚举类型的sizeof值都为4 12345enum color(red,pink,white,black)c;void main()&#123; cout&lt;&lt;sizeof(enum); //值为4&#125; 三、sizeof计算嵌套的结构体大小对于嵌套的结构体，需要将其展开。对结构体求sizeof时，上述两种原则变为： 展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大的成员的整数倍。 结构体大小必须是所有成员大小的整数倍，这里所有成员计算的是展开后的成员，而不是将嵌套的结构体当做一个整体。 被展开的结构体的规则同单结构体sizeof计算规则。 看下面的例子： 12345678910struct stu5 &#123; short i; struct &#123; char c; int j; &#125; ss; int k; &#125; 结构体stu5的成员ss.c的偏移量应该是4，而不是2。整个结构体大小应该是16，即4+（4+4）+4，第二个4是 char c 的扩展(由后面int j导致)。 下面的代码测试原则2： 1234567891011121314struct stu5 &#123; char i; struct &#123; char c; int j; &#125; ss; char a; char b; char d; char e; char f; &#125; ​ 结构体ss单独计算占用空间为8，而stu5的sizeof则是20（由17扩展至20，而不是扩展到24），不是8的整数倍，这说明在计算sizeof(stu5)时，将嵌套的结构体ss展开了，这样stu5中最大的成员为ss.j，占用4个字节，20为4的整数倍。如果将ss当做一个整体，结果应该是24了。 另一个常见的例子： 结构体中包含数组，其sizeof应当和处理嵌套结构体一样，将其展开 123456struct ss &#123; float f; char p; int adf[3]; &#125;; 补充 另外一个涉及数据类型以及内存存储的问题内存中的数据并非保存在任意地址。处理器通常按照和其字大小相同的块读取内存数据；那么考虑到效率因素，编译器会按照块大小的整数倍对内存中的实体进行地址对齐。因此在 32 位的处理器上，一个 4 字节整型数据肯定存放在内存地址能被4整除的地方。 下面，假设系统中整型数据和指针大小均为 4 字节。现在有一个指向整型的指针。如上所述，整型数据可以存放在内存地址 0×1000 或者 0×1004 或者 0×1008，但是决不会存放在 0×1001 或者0×1002 或者 0×1003 或者其他不能被4整除的任何地址。所有是4整数倍的二进制数都是以 00 结尾。实际上，这意味着对于所有指向整型的指针，它的最后两位总是 0。","categories":[{"name":"C语言","slug":"C语言","permalink":"http://onlyorange.top/categories/C语言/"}],"tags":[]},{"title":"数据结构与算法知识随笔","slug":"数据结构与算法知识随笔","date":"2019-10-11T05:06:33.000Z","updated":"2020-01-08T13:18:06.212Z","comments":true,"path":"2019/10/11/数据结构与算法知识随笔/","link":"","permalink":"http://onlyorange.top/2019/10/11/数据结构与算法知识随笔/","excerpt":"数据结构与算法1.完全二叉树与满二叉树的区别满二叉树是完全二叉树的特例，因为满二叉树已经满了，而完全并不代表满。所以形态你也应该想象出来了吧，满指的是出了叶子节点外每个节点都有两个孩子，而完全的含义则是最后一层没有满，并没有满。 2.已知二叉树的前序遍历和中序遍历求后续遍历现有二叉搜索树（BST）前序遍历结果序列为abdefgc，中序遍历结果序列为debgfac，请问后序遍历结果序列? 答：前序遍历结果序列为abdefgc，中序遍历结果序列为debgfac以此为条件，根据前序知道a是根，根据中知道debgf为左子树，c为右子树。根据前知道b为左子树中的根，根据中知道de为b的左，gf为右，根据前和中判断d为根，e为右，f为根，g为左，树成型，得出后序结果edgfbca","text":"数据结构与算法1.完全二叉树与满二叉树的区别满二叉树是完全二叉树的特例，因为满二叉树已经满了，而完全并不代表满。所以形态你也应该想象出来了吧，满指的是出了叶子节点外每个节点都有两个孩子，而完全的含义则是最后一层没有满，并没有满。 2.已知二叉树的前序遍历和中序遍历求后续遍历现有二叉搜索树（BST）前序遍历结果序列为abdefgc，中序遍历结果序列为debgfac，请问后序遍历结果序列? 答：前序遍历结果序列为abdefgc，中序遍历结果序列为debgfac以此为条件，根据前序知道a是根，根据中知道debgf为左子树，c为右子树。根据前知道b为左子树中的根，根据中知道de为b的左，gf为右，根据前和中判断d为根，e为右，f为根，g为左，树成型，得出后序结果edgfbca 3.已知啊a * b = c，求系统进制如果某系统15*4=112成立，则系统采用的是几进制？ 将原式转为X进制：1 5 * 4 = 1 1 2（X+5）* 4 = X^2+X+2解方程即可x=6 4.栈 设栈S和队列Q的初始状态均为空，元素啊，a,b,c,d,e,f,g依次进入栈S。若每个元素出栈后立即进入推列Q，且7个元素出队的顺序是b,d,,c,f,e,a,g，则栈S的容量至少是？ 栈是先进后出，队列是先进先出，所以元素出队列的顺序就是出栈的顺序。出栈的顺序为b,d,c,f,e,a,g，这意味着 a,b进入，b出； c,d进入，此时栈中有a,d,c，出来d,c； e,f进入， 此时栈中有a,e,f，出来f,e,a； g进入，此时栈中有g，出来g； 由此看出整个过程中栈中存在的元素最多有3个，所以栈S的容量至少是3 一个栈的入栈序列是a,b,c,d,e,f,则栈的不可能的输出序列是（） A:fedcba B:defbca C:defcba D:abcdef A可以 全进栈 然后依次出栈B不可以C先进adcd 然后d出 再进e e出 再进f f出 剩下的依次cba出D一个进 一个出 5. 网络延迟网络延迟是指在传输介质中传输所用的时间，即从报文开始进入网络到它开始离开网络之间的时间。 6.完全二叉树的存储完全二叉树由于其结构上的特点，通常采用顺序存储方式存储(数组)。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://onlyorange.top/categories/数据结构/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://onlyorange.top/tags/随笔/"}]},{"title":"技术知识随笔","slug":"技术知识随笔","date":"2019-10-11T02:44:57.000Z","updated":"2020-01-08T13:18:06.212Z","comments":true,"path":"2019/10/11/技术知识随笔/","link":"","permalink":"http://onlyorange.top/2019/10/11/技术知识随笔/","excerpt":"技术知识随笔1. 黑盒测试与白盒测试任何工程产品(注意是任何工程产品)都可以使用以下两种方法之一进行测试。 黑盒测试：已知产品的功能设计规格，可以进行测试证明每个实现了的功能是否符合要求。 白盒测试：已知产品的内部工作过程，可以通过测试证明每种内部操作是否符合设计规格要求，所有内部成分是否以经过检查。","text":"技术知识随笔1. 黑盒测试与白盒测试任何工程产品(注意是任何工程产品)都可以使用以下两种方法之一进行测试。 黑盒测试：已知产品的功能设计规格，可以进行测试证明每个实现了的功能是否符合要求。 白盒测试：已知产品的内部工作过程，可以通过测试证明每种内部操作是否符合设计规格要求，所有内部成分是否以经过检查。 软件的黑盒测试意味着测试要在软件的接口处进行。这种方法是把测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。因此黑盒测试又叫功能测试或数据驱动测试。 黑盒测试主要是为了发现以下几类错误： 是否有不正确或遗漏的功能? 在接口上，输入是否能正确的接受?能否输出正确的结果? 是否有数据结构错误或外部信息(例如数据文件)访问错误? 性能上是否能够满足要求? 是否有初始化或终止性错误? 软件的白盒测试是对软件的过程性细节做细致的检查。这种方法是把测试对象看做一个打开的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。通过在不同点检查程序状态，确定实际状态是否与预期的状态一致。因此白盒测试又称为结构测试或逻辑驱动测试。 白盒测试主要是想对程序模块进行如下检查： 对程序模块的所有独立的执行路径至少测试一遍。 对所有的逻辑判定，取“真”与取“假”的两种情况都能至少测一遍。 在循环的边界和运行的界限内执行循环体。 测试内部数据结构的有效性，等等。 以上事实说明，软件测试有一个致命的缺陷，即测试的不完全、不彻底性。由于任何程序只能进行少量(相对于穷举的巨大数量而言)的有限的测试，在未发现错误时，不能说明程序中没有错误。 如果能够执行完美的黑盒测试，还需要进行白盒测试吗?从以上可以看出就算完美的黑盒测试也是无法测试程序内部特定部位，另外当规格说明本身有误，也不能发现问题。而白盒测试能对程序的内部特定部位进行覆盖测试，所以黑盒和白盒测试为互补关系，结合起来测试用例的设计更为合理。 经验表明，通常在进行单元测试时采用白盒测试方法，集成测试采用灰盒测试方法，系统测试采用黑盒测试方法。 2.简述单工、半双工、全双工的区别网络的领域内，单工、半双工、全双工是经常会遇见的名称，下面简单的讲述一下他们的区别。 单工：简单的说就是一方只能发信息，另一方则只能收信息，通信是单向的。 半双工：比单工先进一点，就是双方都能发信息，但同一时间则只能一方发信息。 全双工：比半双工再先进一点，就是双方不仅都能发信息，而且能够同时发送。 3.笔试面试知识整理​ 参考链接 4.设计模式创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。","categories":[{"name":"job","slug":"job","permalink":"http://onlyorange.top/categories/job/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://onlyorange.top/tags/随笔/"}]},{"title":"Linux知识随笔","slug":"Linux系统与计算机网络知识随笔","date":"2019-10-11T02:44:34.000Z","updated":"2020-01-08T13:18:06.197Z","comments":true,"path":"2019/10/11/Linux系统与计算机网络知识随笔/","link":"","permalink":"http://onlyorange.top/2019/10/11/Linux系统与计算机网络知识随笔/","excerpt":"Linux知识随笔1.Linux内核五大模块 进程调度模块 内存管理模块 文件系统模块 进程间通信模块 网络接口模块","text":"Linux知识随笔1.Linux内核五大模块 进程调度模块 内存管理模块 文件系统模块 进程间通信模块 网络接口模块 2.死锁要点提示 掌握死锁的概念和产生死锁的根本原因。 理解产生死锁的必要条件–以下四个条件同时具备：互斥条件、不可抢占条件、占有且申请条件、循环等待条件。 记住解决死锁的一般方法，掌握死锁的预防和死锁的避免二者的基本思想。 掌握死锁的预防策略中资源有序分配策略。 理解进程安全序列的概念，理解死锁与安全序列的关系。 了解银行家算法。 了解资源分配图。 了解死锁的检测及恢复的思想。 ———————————————— 原文链接：https://blog.csdn.net/abigale1011/article/details/6450845 死锁产生的原因：（1）竞争资源（2）进程推进顺序不当 3.TCP/IP协议详解 参考文章 4.最受欢迎的Linux发行版(现第2), Manjaro折腾全记录（超长超详细） 参考文章 5. 对于一个分布式计算系统来说3个指标不能同时完成 一致性 可用性 分区容错性 6.OSI参考模型中各层作用 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）数据链路层：将比特组装成帧和点到点的传递（帧Frame）网络层：负责数据包从源到宿的传递和网际互连（包PackeT）传输层：提供端到端的可靠报文传递和错误恢复（段Segment）会话层：建立、管理和终止会话（会话协议数据单元SPDU）表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）应用层：允许访问OSI环境的手段（应用协议数据单元APDU） 网络层： IP协议 ICMP协议 ARP协议 RARP协议。 传输层： UDP协议 TCP协议。 应用层： FTP（文件传送协议） Telenet（远程登录协议） DNS（域名解析协议） SMTP（邮件传送协议） POP3协议（邮局协议） HTTP协议 SNMP协议 TFTP 7.OSI七层模型和TCP/IP四层模型OSI七层模型各层协议： 物理层：RJ45、CLOCK、IEEE802.3 数据链路层：PPP、FR、HDLC、VLAN、MAC 网络层：IP、IPX、OSPF、RIP、IGRP、ICMP、ARP、RARP 传输层：TCP、UDP、SPX 会话层：NFS、SQL、NETBIOS、RPC 表示层：JPEG、MPEG、ASII 应用层：Telnet、HTTP、FTP、WWW、NFS、SMTP TCP/IP四层模型：一、TCP/IP四层模型名称：网络接口层（Network Access）【又分为物理层（Physical）和数据链路层（Datalink）】→网络互联层（Internet）→传输层（Transport）→应用层（Application） 二、TCP/IP四层模型各层的功能： 网络接口层：负责实际数据的传输 网络互联层：负责网络间的寻址数据传输 传输层：负责提供可靠的传输服务 应用层：负责实现一切与应用程序相关的功能 三、TCP/IP四层模型各层的协议：1、网络接口层：HDLC（高级链路控制协议）、PPP（点对点协议）、SLIP（串行线路接口协议） 2、网络互联层：IP（网际协议）、ICMP（网际控制消息协议）、ARP（地址解析协议）、RARP（反向地址解析协议） 3、传输层：TCP（控制传输协议）、UDP（用户数据报协议） 4、应用层：FTP（文件传输协议）、HTTP（超文本传输协议）、DNS（域名服务器协议）、SMTP（简单邮件传输协议）、NFS（网络文件系统协议） 四、OSI七层模型和TCP/IP四层模型的区别：OSI七层模型和TCP/IP四层模型最大的区别在于：OSI七层模型是一个理论上的网络通信模型，而TCP/IP四层模型则是实际运行的网络协议。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://onlyorange.top/categories/Linux/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://onlyorange.top/tags/随笔/"}]},{"title":"Python知识随笔","slug":"Python知识随笔","date":"2019-10-11T02:44:12.000Z","updated":"2020-01-08T13:18:06.197Z","comments":true,"path":"2019/10/11/Python知识随笔/","link":"","permalink":"http://onlyorange.top/2019/10/11/Python知识随笔/","excerpt":"","text":"python知识随笔正则表达式的贪婪与非贪婪匹配String str=&quot;abcaxc&quot;; Patter p=&quot;ab*c&quot;; 贪婪匹配：正则表达式一般趋向于最大长度匹配，也就是所谓的贪婪匹配。如上面使用模式p匹配字符串str，结果就是匹配到：abcaxc(ab*c)。 非贪婪匹配：就是匹配到结果就好，就少的匹配字符。如上面使用模式p匹配字符串str，结果就是匹配到：abc(ab*c)。","categories":[{"name":"Python","slug":"Python","permalink":"http://onlyorange.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://onlyorange.top/tags/Python/"}]},{"title":"职位汇总","slug":"职位汇总","date":"2019-09-29T01:59:33.000Z","updated":"2020-01-08T13:18:06.212Z","comments":true,"path":"2019/09/29/职位汇总/","link":"","permalink":"http://onlyorange.top/2019/09/29/职位汇总/","excerpt":"海康威视软件研发类【2020校招】嵌入式软件开发工程师（BSP）工作地点：浙江省-杭州市,湖北省-武汉市 工作职责： 根据产品和业务需求开发嵌入式系统底层软件，设计和实现软件功能，并编写相应开发文档； 开发、测试和维护产品中各种芯片驱动软件； 对系统软件进行优化，提升系统性能、可靠性和稳定性。","text":"海康威视软件研发类【2020校招】嵌入式软件开发工程师（BSP）工作地点：浙江省-杭州市,湖北省-武汉市 工作职责： 根据产品和业务需求开发嵌入式系统底层软件，设计和实现软件功能，并编写相应开发文档； 开发、测试和维护产品中各种芯片驱动软件； 对系统软件进行优化，提升系统性能、可靠性和稳定性。 任职资格： 本科及以上学历，计算机、电子信息、通信等相关专业，对英文技术文档有较好的阅读理解能力； 熟练使用C语言，有汇编语言或脚本语言的使用经验； 熟悉常用总线和接口协议，如I2C、SPI、UART，了解基本网络知识； 了解单片机、ARM、DSP、X86等至少一种芯片架构及组成； 了解操作系统原理，理解中断、进程、内存等基本概念，有Linux/RTOS上驱动或应用程序开发经验优先。 【2020校招】嵌入式软件开发工程师（应用）工作地点：浙江省-杭州市，北京市 工作职责： 负责嵌入式应用软件开发和维护工作； 负责编写软件设计文档，参与需求分析和讨论； 负责对编码进行调试和验证，设计测试用例； 负责对疑难问题的跟踪和解决。 任职资格： 本科及以上学历，计算机、电子信息类相关专业； 熟练掌握C/C++语言，具备良好的编程风格； 熟悉Linux操作系统，熟悉多线程编程，熟悉TCP/IP协议； 具有较强的沟通能力和解决问题的能力，工作态度积极主动，有团队合作精神。 【2020校招】高性能计算工程师（高性能计算\\AI计算引擎\\分布式计算）—研究院工作地点：浙江省杭州市 工作职责： 负责智能分析核心计算框架与高性能后台服务，承担系统的架构设计、开发及技术难点攻关； 负责高性能系统中硬件平台的系统架构方案的选型，制定性能评估、验证等相关技术标准； 对机器学习（深度学习）中的计算问题进行研究，与算法团队合作，实现算法的软硬件联合优化； 面向计算、存储、传输构建高性能计算基础软件栈，优化系统架构设计； 针对人工智能中各个垂直应用领域，与算法团队合作进行解决方案的设计与开发工作。 任职资格： 硕士及以上学历，电子、自动化、计算机等相关专业； 掌握C++、Python、Go、Java语言一种或几种，有多线程、多进程开发经验； 有良好的逻辑思维能力和系统思考能力，有较强责任心和抗压能力； 具备以下条件之一者优先： 熟悉计算机体系结构，在某种异构芯片上（GPU，ARM等）做过深入工作，具备驱动、内核、网络协议开发经验； 在分布式、高并发、容器、数据库、软硬件结合等领域有开发和优化经验； 熟悉caffe、tensorflow、pytorch等主流的框架及常用的AI算法网络。 【2020校招】嵌入式软件开发工程师（算法应用）工作地点：浙江省-杭州市 工作职责： 1、负责嵌入式算法组件在嵌入式芯片上的系统集成和系统性能调优；2、负责嵌入式算法组件后处理算法的开发和结合产品应用的功能开发和调优。 任职资格： 1、数学/计算机相关专业，研究生及其以上学历，2年算法开发或者偏算法应用的开发经验，有智能驾驶算法、机器人比赛等开发经验者优先；2、熟悉视频/雷达/IMU/GPS等传感和定位的基本原理和应用；3、了解并熟练应用FMEA/FTA者优先；4、具备一定的嵌入式SOC开发经验，理解基本操作系统线程、进程任务调度，了解ISO26262功能安全；5、具备较强的学习能力、良好团队合作意识和抗压性。 算法类【2020校招】智能传感算法工程师（传感器\\深度感知\\三维重建\\VSLAM\\AR\\移动机器人\\计算光学成像等）—研究院工作地点：浙江省-杭州市 工作职责： 负责传感器、深度感知（TOF、双目、结构光等）、三维重建、VSLAM、AR、移动机器人、计算光学成像的算法或者系统的设计及开发。 任职资格： 硕士及以上学历，计算机、光学、电子、仪器、通信、自控、数学等相关专业； 有较好的系统思维，知识面丰富，熟悉计算机视觉、传感器、信号处理、光学设计、嵌入式、硬件等相关技术之一； 具备较强的全局观，良好的沟通与协作能力，能够系统、全面地看待及分析问题； 具备下述项目经验之一者优先： 具备雷达、激光雷达、多传感器系统设计或算法开发经验； 具备深度感知（双目/TOF/结构光等）、三维重建、VSLAM等系统设计或算法开发经验之一； 具备AR/VR、移动机器人、计算光学（高光谱等）等系统设计或算法开发经验之一； 具备光学系统设计和开发经验； 具备DSP、ARM等软硬件系统开发优化经验。 【2020校招】AI算法工程师（模式识别\\机器学习\\ADAS\\OCR）—研究院工作地点：上海市 工作职责： 负责模式识别、计算机视觉、视频分析、ADAS、OCR相关算法的研究与实现。 任职资格： 硕士及以上学历，计算机、模式识别、电子工程、应用数学类等相关专业； 熟练掌握C\\C++\\Python，具备扎实的编程基础； 具有较好的数学功底，对模式识别、机器学习有较深入的理解与认识； 具备计算机视觉领域的研究经历； 熟练使用Caffe、Tensorflow、PyTorch及其它开源框架者优先； 有实际项目开发或参加竞赛经验者优先； 在CVPR、ICCV、ECCV、TMM、TIP、PAMI等国际顶级会议或期刊上发表过文章者优先。 【2020校招】图像处理算法工程师—萤石工作地点：浙江省-杭州市 工作职责： 收集当前相关的最新技术，并定期跟踪和尝试复现最新技术结果； 有图像处理相关研究生项目经验； 面向应用方向为图像处理，生物特征方面的图像处理、任一相关方向即可。 任职资格： 硕士及以上学历，计算机、信号处理、图像处理及信息类专业； 有较好数学基础，较强的图像处理技术基础； 掌握C/C++语言，能编程实现图像处理类算法； 较强的论文检索，英文专业文献阅读能力； 较强的沟通与协作能力； 有嵌入式或者图像处理，特别是指纹静脉类图像处理学习开发经验者优先。 【2020校招】运动控制算法工程师-机器人工作地点：浙江省-杭州市 工作职责： 负责移动机器人运动控制相关算法研发及产品化。 任职资格： 硕士及以上学历，计算机、电子、自动控制类专业； 在移动机器人运动控制相关领域研究开发经验； 熟练掌握运动控制、轨迹规划等相关算法，对移动机器人的运动控制有较深入的理解和认识； 具有较好的数学功底和良好的英语阅读能力，具有较强的学习能力； 精通C/C++，有较好的编程基础，具有较强的动手实现能力； 具有移动机器人实际项目开发经验者优先考虑。 【2020校招】运动控制算法工程师工作地点：浙江省杭州市 工作职责： 参与机械臂及足式机器人的控制系统的搭建； 参与总体结构方案设计，关键元器件选型等； 对机械臂或足式机器人进行运动学、动力学建模，完成误差标定、参数辨识、轨迹规划等基本功能。 负责机械臂或足式机器人算法应用的开发。 任职资格： 硕士及以上学历，计算机、机器人、自动化等相关专业； 具备机械臂或足式机器人运动规划算法以及算法应用开发的经验，掌握机器人运动学，动力学，轨迹规划等相关知识； 熟悉ROS系统，了解MOVEIT、Gazebo等常用相关工具，熟练使用C/C++等编程语言； 沟通表达协调能力好，能无障碍阅读英文文献； 有足式机器人相关竞赛经验者优先。 大华股份软件类【研发中心】2020届C/C++软件工程师（linux、嵌入式）工作地点：浙江省-杭州市 工作职责： 你将和业界优秀的软件工程师前辈、专家一起，研发功能领先、性能卓越的产品，接触、参与到前沿技术，不断突破、快速成长，包括但不限于：1、负责产品软件的设计、编码、调试等工作，相关技术文档撰写；2、负责产品软件研发及商用过程中的功能、性能、可靠性等问题的定位解决；3、负责产品软件关键技术、前沿技术的预研和产品化，提升产品优势与核心价值，为客户提供持续领先解决方案；4、探索、洞察业界技术新方向，持续创新，与前辈、技术专家技术交流、合作。 任职资格： 1、全日制本科及以上学历，计算机、电子信息、软件工程、自动化等相关专业；2、热爱编程、基础扎实，熟悉C/C++语言，对操作系统原理、Linux、CPU等有一定的了解；3、参加竞赛获奖者、国际期刊发表论文者、有实际项目经验者优先考虑。 小米集团软件研发类【嵌入式工程师】岗位描述： 1、负责手机各种外设驱动的开发优化工作，比如Camera、LCD、Touch、Audio、Charger、Sensor等； 2、负责Linux Kernel相关开发优化工作，如稳定性优化、性能优化等。 任职要求： 1、计算机、软件、电子、通信等相关专业本科及以上学历； 2、熟悉C/C++语言编程，有一定的硬件功底； 3、熟悉数据结构和算法，了解操作系统原理； 4、学习能力强，思路清晰，团队合作能力好，适应快节奏、高效率工作； 5、熟练读懂英文文档，并能进行英语交流； 6、优先条件： （1）熟悉Linux kernel原理，有相关产品开发优化经验； （2）熟悉Linux驱动模型，有相关设备驱动开发经验； （3）参加过大学生电子设计竞赛（或同类型竞赛）并获奖者； （4）有嵌入式/单片机开发经验。 【嵌入式软件工程师】北京市·海淀区 职位描述 工作职责： 1.负责小米智能语音产品嵌入式Linux平台搭建； 2.负责集成小米智能语音算法并封装SDK,提供给所有小米智能语音产品使用； 3.负责将小米智能语音算法移植到各嵌入式平台； 职位要求： 1.精通C/C++编程和数据结构； 2.熟悉嵌入式Linux系统开发和算法移植； 3.熟悉Linux多线程、多进程编程； 4.熟悉Linux/Unix下的网络编程； 【嵌入式高级研发软件工程师】职位描述 岗位职责： 1.小米智能家居IoT-WIFI平台研发工作 2.负责/参与IoT-WIFI平台需求分析，方案设计，功能开发，调试以及性能优化等工作 岗位要求： 计算机、通信、自动化等相关专业，硕士5年以上、本科8年以上嵌入式软件开发经验 精通802.11、Wi-Fi相关协议和TCP/IP协议，精通网络编程 精通C/C++语言，熟悉设计模式，具有良好的编程风格和文档编制习惯 熟悉LINUX或者RTOS，精通多线程编程 熟悉网络安全和系统安全设计者优先 具备嵌入式软硬件协同能力者优先 积极主动、善于沟通、良好的团队合作意识 阿里巴巴嵌入式软件开发工程师岗位描述Job Description IoT芯片驱动、AI算法、面向领域的应用解决方案开发； IoT芯片操作系统开发； IoT芯片编译工具链、模拟器、调试器、IDE开发和性能优化 岗位要求Qualifications 1.本科及以上学历，计算机、嵌入式等相关专业； 2.具有良好的算法基础及软件编程能力；3.熟悉至少一门编程语言,ASM/C/C++/Python；4.富有激情，有创新意识和能力，具有自我驱动和良好的团队合作能力；5.良好的沟通和表达能力，能够主动发现并解决问题。加分项：1.有嵌入式系统或智能硬件开发经验；2.有编译器开发经验；3.熟悉Linux或RTOS操作系统内核；4.熟悉一种以上物联网协议；5.熟悉深度学习算法，量化算法。 美团嵌入式系统工程师岗位职责1.承担无人车系统中底层嵌入式控制系统开发工作，侧重底层信号采集处理与控制决策、执行机控制，或域控制器开发。 2.在ARM或FPGA平台上，构建完备的信号采集、计算处理、执行部件实时控制系统。涉及各器件及功能模块的接口与驱动、通讯、控制算法实现与优化。 3.控制算法开发，涉及传感器融合、移动机器人学/车辆控制、电机控制；实现同时需要顾及响应实时性，可靠性，以及容错机制设计。 4.配合控制单元测试、集成测试、整车测试。 5.产品/技术文档。 任职要求1.控制工程、电子工程、机电工程、车辆工程或其他相关专业硕士及以上学历。 2.熟悉ARM或FPGA，熟悉常用总线与接口技术，具备电路原理图阅读能力。 3.熟悉RTOS、运动控制技术；或熟悉Linux、有ROS开发经验。 4.有实际项目研发经历，调试经验丰富。 5.工作自驱动，责任心强，良好的团队合作精神。 具备以下者优先： 有创新证明（获奖、论文、专利等）。 岗位亮点： 1.较好的跨专业（机械、电子、控制系统）工作机会。 2.涉及车辆控制、机器人技术、无人驾驶技术。","categories":[{"name":"job","slug":"job","permalink":"http://onlyorange.top/categories/job/"}],"tags":[{"name":"职位","slug":"职位","permalink":"http://onlyorange.top/tags/职位/"}]},{"title":"c语言考试测试题-临时(教学用)","slug":"C语言考试测试题-临时","date":"2019-07-02T08:49:33.000Z","updated":"2020-02-12T05:27:17.343Z","comments":true,"path":"2019/07/02/C语言考试测试题-临时/","link":"","permalink":"http://onlyorange.top/2019/07/02/C语言考试测试题-临时/","excerpt":"c语言能力测试基础练习题 编写程序，输入x,求f(x)函数的值 f(x)={x-2 , 9&lt;=x&lt;10} ​ {x2+10 , 0&lt;=x&lt;9} ​ {4x2-5 , x&gt;15} 编写程序，求解修路问题，60公里公路，60人修建，甲工程队一人一次修4公里，乙工程队一人一次修3公里，丙工程队两人一次修1公里，要求1次搬完。问各需甲、乙和丙工程队各多少人。 编写程序，完成以下任务： 定义一个能存放50本书价格的一位数组。 向数组中输入或者赋给[0,200]之间的随机整数。 输出所有数组的所有元素。 统计50本书总价格，和价格大于100的书籍中奇数和偶数的个数，并分别计算奇数和偶数的平均值。","text":"c语言能力测试基础练习题 编写程序，输入x,求f(x)函数的值 f(x)={x-2 , 9&lt;=x&lt;10} ​ {x2+10 , 0&lt;=x&lt;9} ​ {4x2-5 , x&gt;15} 编写程序，求解修路问题，60公里公路，60人修建，甲工程队一人一次修4公里，乙工程队一人一次修3公里，丙工程队两人一次修1公里，要求1次搬完。问各需甲、乙和丙工程队各多少人。 编写程序，完成以下任务： 定义一个能存放50本书价格的一位数组。 向数组中输入或者赋给[0,200]之间的随机整数。 输出所有数组的所有元素。 统计50本书总价格，和价格大于100的书籍中奇数和偶数的个数，并分别计算奇数和偶数的平均值。 编写程序，完成以下任务： 定义一个6行6列的二维数组。 向数组中输入或者赋给[0,100]之间的随机整数。 按照行列方式输出所有数组的所有元素。 求出前3行数组中所有元素的最大值和最小值。 编写并调用函数： 编写函数stri，参数为三条边长，函数值为三角形面积。 在main()函数中输入三角形三条边，调用stri函数，计算并输出三角形面积。 编写并调用字符串处理函数： 编写函数void abc(char s[])，将形参字符串中的所有大写字母变为小写字母，而小写字母不变，去掉数字。例如，字符串“ABCDefgh1234”,转换后为“abcdefgh”。 在main()函数中，定义一个字符数组，输入字符串，调用abc()函数进行大小写转换，输出处理后的字符串。 选择题 已知数字字符’0’的ASCII值为65。以下程序运行后的输出结果是( ) 123456void main()&#123; char a = 'A'; a = a + 35; printf(\"%c,%d\",a,a);&#125; A: 100,100 B: d,100 C: A, 100 D: d,d 执行以下程序，分别从键盘上输入0和5，输出结果分别是( ) 123456789101112void main()&#123; int b; scanf(\"%d\",&amp;b); switch(b) &#123; case 0:print(\"00\"); case 1:print(\"11\"); case 2:print(\"22\");break; defalut:print(\"33\"); &#125;&#125; A: 00 33 B: 00 11 33 C: 00 11 22 33 D: 00 11 已经定义int a = 4,b = 4,则条件表达式a&lt;b?a*b:a+b的值是( )。 A: 0 B: 无结果 C: 16 D: 8 以下程序输入整数a,b，当a&gt;b时将其反序。补全代码 123456789101112void main()&#123; int a,b,t; scanf(\"%d%d\",&amp;a,&amp;b); (1) &#123; (2) (3) (4) &#125; printf(\"%d %d\\n\",a,b);&#125; 以下程序的运行结果为 12345678910void main()&#123; int s = 2, i =6 ; while(i&gt;=2) &#123; s=s*i; i--;i--; &#125; printf(\"%d\",s--);&#125; 以下程序结果为 12345678910void main()&#123; int i,j; for(i=3;i&lt;6;i++) printf(\"*\"); for(j=5;j&gt;=2;j--) printf(\"#\"); printf(\"*\"); &#125; 以下程序的运行结果为( ) 12345678910void abc()&#123; static int a = 1; int b=0; a = a+1; b = b+a; printf(\"%d,%d\\n\",a,b);&#125;void main()&#123; abc();abc();abc();&#125;","categories":[{"name":"c语言","slug":"c语言","permalink":"http://onlyorange.top/categories/c语言/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://onlyorange.top/tags/c语言/"}]},{"title":"python str和list排序并删除重复数据","slug":"python-str和list排序并删除重复数据","date":"2019-06-30T06:31:26.000Z","updated":"2020-01-08T13:18:06.197Z","comments":true,"path":"2019/06/30/python-str和list排序并删除重复数据/","link":"","permalink":"http://onlyorange.top/2019/06/30/python-str和list排序并删除重复数据/","excerpt":"一、排序函数sort()和sort()sort() 是Python列表的一个内置的排序方法，list.sort() 方法排序时直接修改原列表，返回None； sort() 是Python内置的一个排序函数，它会从一个迭代器返回一个排好序的新列表。 相比于 sort()，sorted() 使用的范围更为广泛，但是如果不需要保留原列表，sort更有效一点。另外，sort() 只是列表的一个方法，只适用于列表，而sorted() 函数接受一切迭代器，返回新列表。 这两个方法有以下 2 个共同的参数： key 是带一个参数的函数，返回一个值用来排序，默认为 None。这个函数只调用一次，所以fast。 reverse 表示排序结果是否反转","text":"一、排序函数sort()和sort()sort() 是Python列表的一个内置的排序方法，list.sort() 方法排序时直接修改原列表，返回None； sort() 是Python内置的一个排序函数，它会从一个迭代器返回一个排好序的新列表。 相比于 sort()，sorted() 使用的范围更为广泛，但是如果不需要保留原列表，sort更有效一点。另外，sort() 只是列表的一个方法，只适用于列表，而sorted() 函数接受一切迭代器，返回新列表。 这两个方法有以下 2 个共同的参数： key 是带一个参数的函数，返回一个值用来排序，默认为 None。这个函数只调用一次，所以fast。 reverse 表示排序结果是否反转 看例子 1234567891011121314151617&gt;&gt;&gt; a = (1,2,4,2,3) # a 是元组，故不能用sort() 排序&gt;&gt;&gt; a.sort()Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'tuple' object has no attribute 'sort'&gt;&gt;&gt; sorted(a) # sorted() 可以为元组排序，返回一个新有序列表[1, 2, 2, 3, 4]&gt;&gt;&gt; a=['1',1,'a',3,7,'n']&gt;&gt;&gt; sorted(a)[1, 3, 7, '1', 'a', 'n']&gt;&gt;&gt; a # sorted() 不改变原列表['1', 1, 'a', 3, 7, 'n'] &gt;&gt;&gt; print a.sort()None&gt;&gt;&gt; a # a.sort()直接修改原列表[1, 3, 7, '1', 'a', 'n'] 因此如果实际应用过程中需要保留原有列表，使用 sorted() 函数较为适合，否则可以选 择 sort() 函数，因为 sort() 函数不需要复制原有列表，消耗的内存较少，效率也较高。 sorted() 函数功能非常强大，它可以方便地针对不同的数据结构进行排序，从而满足不同需求。例子如下： 对字典进行排序 1234&gt;&gt;&gt; sorted(&#123;1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'&#125;) # 根据字典键排序[1, 2, 3, 4, 5]&gt;&gt;&gt; sorted(&#123;1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'&#125;.values()) # 根据字典值排序['A', 'B', 'B', 'D', 'E'] 对多维列表排序 12345&gt;&gt;&gt; student_tuples = [('john', 'A', 15),('jane', 'B', 12),('dave', 'B', 10)]&gt;&gt;&gt; sorted(student_tuples, key = lambda student: student[0]) # 对姓名排序[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]&gt;&gt;&gt; sorted(student_tuples, key = lambda student: student[2]) # 年龄排序[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)] 调用operator模块中的 itemgetter() 可以实现根据多个参数排序 123456&gt;&gt;&gt; sorted(student_tuples, key = itemgetter(2)) # 根据年龄排序[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]&gt;&gt;&gt; sorted(student_tuples, key = itemgetter(1, 2)) # 根据成绩和年龄排序[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]&gt;&gt;&gt; sorted(student_tuples, key = itemgetter(1, 2), reverse=True) # 反转排序结果[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)] ps: itemgetter 返回一个函数，实现取元素的功能。比如 f = itemgetter(2)，调用 f(r) 返回 r[2]; f = itemgetter(2, 5, 3)，调用 f(r) 返回元组 (r[2], r[5], r[3]). 二、python集合(set)操作python的set和其他语言类似, 是一个无序不重复元素集, 基本功能包括关系测试和消除重复元素. 集合对象还支持union(联合), intersection(交), difference(差)和sysmmetric difference(对称差集)等数学运算. 下面来点简单的小例子说明 1234&gt;&gt;&gt; x = set('spam')&gt;&gt;&gt; y = set(['h','a','m'])&gt;&gt;&gt; x, y(set(['a', 'p', 's', 'm']), set(['a', 'h', 'm'])) 再来些小应用。 12345678&gt;&gt;&gt; x &amp; y # 交集set(['a', 'm'])&gt;&gt;&gt; x | y # 并集set(['a', 'p', 's', 'h', 'm'])&gt;&gt;&gt; x - y # 差集set(['p', 's']) 记得以前个网友提问怎么去除海量列表里重复元素，用hash来解决也行，只不过感觉在性能上不是很高，用set解决还是很不错的，示例如下： 1234567&gt;&gt;&gt; a = [11,22,33,44,11,22]&gt;&gt;&gt; b = set(a)&gt;&gt;&gt; bset([33, 11, 44, 22])&gt;&gt;&gt; c = [i for i in b]&gt;&gt;&gt; c[33, 11, 44, 22] 集合用于包含一组无序的对象。要创建集合，可使用set()函数并像下面这样提供一系列的项： 123s = set([3,5,9,10]) #创建一个数值集合t = set(\"Hello\") #创建一个唯一字符的集合 与列表和元组不同，集合是无序的，也无法通过数字进行索引。此外，集合中的元素不能重复。例如，如果检查前面代码中t集合的值，结果会是： 12&gt;&gt;&gt; tset(['H', 'e', 'l', 'o']) 注意只出现了一个’l’。 集合支持一系列标准操作，包括并集、交集、差集和对称差集，例如： 1234a = t | s # t 和 s的并集b = t &amp; s # t 和 s的交集c = t – s # 求差集（项在t中，但不在s中）d = t ^ s # 对称差集（项在t或s中，但不会同时出现在二者中） 基本操作：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172t.add('x') # 添加一项s.update([10,37,42]) # 在s中添加多项t.remove('H')#使用remove()可以删除一项len(s)#set 的长度x in s#测试 x 是否是 s 的成员x not in s#测试 x 是否不是 s 的成员s.issubset(t)s &lt;= t#测试是否 s 中的每一个元素都在 t 中s.issuperset(t)s &gt;= t#测试是否 t 中的每一个元素都在 s 中s.union(t)s | t#返回一个新的 set 包含 s 和 t 中的每一个元素s.intersection(t)s &amp; t#返回一个新的 set 包含 s 和 t 中的公共元素s.difference(t)s - t#返回一个新的 set 包含 s 中有但是 t 中没有的元素s.symmetric_difference(t)s ^ t#返回一个新的 set 包含 s 和 t 中不重复的元素s.copy()#返回 set “s”的一个浅复制hash(s)#返回 s 的 hash 值s.update(t)s |= t#返回增加了 set “t”中元素后的 set “s”s.intersection_update(t)s &amp;= t#返回只保留含有 set “t”中元素的 set “s”s.difference_update(t)s -= t#返回删除了 set “t”中含有的元素后的 set “s”s.symmetric_difference_update(t)s ^= t#返回含有 set “t”或者 set “s”中有而不是两者都有的元素的 set “s”s.remove(x)#从 set “s”中删除元素 x, 如果不存在则引发 KeyErrors.discard(x)#如果在 set “s”中存在元素 x, 则删除s.pop()#删除并且返回 set “s”中的一个不确定的元素, 如果为空则引发 KeyErrors.clear()#删除 set “s”中的所有元素 三、str和list排序 删除重复数据 List排序并删除重复值 1234&gt;&gt;&gt; a =[1,1,2,3,4,5,4,2,3,1]&gt;&gt;&gt; b =sorted(set(a)) &gt;&gt;&gt; print(b)[1,2,3,4,5] List排序不删除重复值 1234&gt;&gt;&gt; a=[1,1,2,3,4,5,4,2,3,1]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; print (a)[1, 1, 1, 2, 2, 3, 3, 4, 4, 5] String排序不删除重复值 123456&gt;&gt;&gt; a=\"abchabcgesdfaad\"&gt;&gt;&gt; b=list(a)&gt;&gt;&gt; b.sort()&gt;&gt;&gt; s=\"\".join(b)&gt;&gt;&gt;print (s)aaaabbccddefghs String排序删除重复值 12345&gt;&gt;&gt; a=\"abchabcgesdfaad\"&gt;&gt;&gt; b=list(a)&gt;&gt;&gt; c=sorted(set(b))&gt;&gt;&gt; c['a','b','c','d','e','f','g','h','s']","categories":[{"name":"python","slug":"python","permalink":"http://onlyorange.top/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://onlyorange.top/tags/python/"}]},{"title":"python获取当前目录，上级目录，上上级目录","slug":"python获取当前目录，上级目录，上上级目录","date":"2019-06-30T03:55:28.000Z","updated":"2020-01-08T13:18:06.212Z","comments":true,"path":"2019/06/30/python获取当前目录，上级目录，上上级目录/","link":"","permalink":"http://onlyorange.top/2019/06/30/python获取当前目录，上级目录，上上级目录/","excerpt":"","text":"12345678910111213import os print '***获取当前目录***'print os.getcwd()print os.path.abspath(os.path.dirname(__file__)) print '***获取上级目录***'print os.path.abspath(os.path.dirname(os.path.dirname(__file__)))print os.path.abspath(os.path.dirname(os.getcwd()))print os.path.abspath(os.path.join(os.getcwd(), \"..\")) print '***获取上上级目录***'print os.path.abspath(os.path.join(os.getcwd(), \"../..\"))","categories":[{"name":"python","slug":"python","permalink":"http://onlyorange.top/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://onlyorange.top/tags/python/"}]},{"title":"为Hexo添加分类及标签","slug":"为Hexo添加分类及标签","date":"2019-06-27T08:01:49.000Z","updated":"2020-01-08T13:18:06.212Z","comments":true,"path":"2019/06/27/为Hexo添加分类及标签/","link":"","permalink":"http://onlyorange.top/2019/06/27/为Hexo添加分类及标签/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Typora取消继承上一行格式","slug":"Typora取消继承上一行格式","date":"2019-06-27T08:01:01.000Z","updated":"2020-01-08T13:18:06.197Z","comments":true,"path":"2019/06/27/Typora取消继承上一行格式/","link":"","permalink":"http://onlyorange.top/2019/06/27/Typora取消继承上一行格式/","excerpt":"","text":"问题使用Typora写列表时，换行会继承上一行的格式 解决办法Mac command+[ windows ctrl+[ 即可取消继承 补充：直接按方向键时不自动继承上一行的，按Enter会继承上一行","categories":[{"name":"Markdown","slug":"Markdown","permalink":"http://onlyorange.top/categories/Markdown/"}],"tags":[{"name":"Markdown编辑器","slug":"Markdown编辑器","permalink":"http://onlyorange.top/tags/Markdown编辑器/"}]},{"title":"Git安装及Github基本使用","slug":"Git安装及Github基本使用","date":"2019-06-27T07:32:58.000Z","updated":"2020-01-08T13:18:06.197Z","comments":true,"path":"2019/06/27/Git安装及Github基本使用/","link":"","permalink":"http://onlyorange.top/2019/06/27/Git安装及Github基本使用/","excerpt":"目录 安装git 创建ssh key 、配置git 提交本地项目到Github","text":"目录 安装git 创建ssh key 、配置git 提交本地项目到Github 安装git在Mac上安装git 首先在终端输入git查看是否已安装过git 通过homebrew安装git 未安装homebrew，先安装homebrew 1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 安装git 1brew install git 创建ssh key、配置git 设置username和email（github每次commit都会记录他们） 12git config --global user.name \"你的用户名\"git config --global user.email \"你的邮箱地址\" 生成ssh key 1ssh-keygen -t rsa -C \"你的邮箱地址\" 然后直接三个回车即可，默认不需要设置密码 然后找到~/下生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制 打开GitHub_Settings_keys页面，新建new SSH Key ![屏幕快照 2019-06-28 下午9.02.22](/Users/sky/Desktop/屏幕快照 2019-06-28 下午9.02.22.png) Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。在Git Bash中检测GitHub公钥设置是否成功，终端输入 ssh git@github.com 123Last login: Sat Jan 6 14:42:55 on ttys000你的主机名:~ 你的用户名$ ssh git@github.com Hi 你刚刚设置的user.name! You've successfully authenticated, but GitHub does not provide shell access. 说明已经链接成功。 提交本地项目到Github 在GitHub上新创建一个 repository或者Start a Project 填写项目信息，填写完成后点击Create repository Clone工程到本地，首先复制ssh 地址 然后克隆项目,终端输入 1git clone 你复制的ssh地址 这时，工程已经被克隆到所在文件夹 进入clone下来的文件夹，使用编辑器等修改并保存代码 提交修改，首先切换到文件夹所在目录 1234567cd clone下来的文件夹的地址//文件添加到仓库（.代表提交所有文件）git add .//把文件提交到仓库git commit -m \"First Commit\"//上传到githubgit push 查看GitHub上的项目，就已经上传成功啦 参考文章 Git教程 GitHub+Hexo 搭建个人网站详细教程","categories":[{"name":"Git","slug":"Git","permalink":"http://onlyorange.top/categories/Git/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://onlyorange.top/tags/GitHub/"}]},{"title":"hexo不解析Markdown标题&#40&#35&#41","slug":"Typora编辑器使用中的问题","date":"2019-06-22T13:07:03.000Z","updated":"2020-01-08T13:18:06.197Z","comments":true,"path":"2019/06/22/Typora编辑器使用中的问题/","link":"","permalink":"http://onlyorange.top/2019/06/22/Typora编辑器使用中的问题/","excerpt":"问题发布文章后标题没有被解析显示#标题 ，但是在我编辑器(Typora)里面显示没有问题","text":"问题发布文章后标题没有被解析显示#标题 ，但是在我编辑器(Typora)里面显示没有问题 原因Markdown标题标准写法需要在”#”和后面字符之间加一个空格 不加空格一些引擎就解析不了 Typora编辑器中在行首有#，就会自动识别为标题 注意需要注意写Markdown文档时要严格遵守Markdowm标准 拓展Markdown诞生自 Daring Fireball之手，点击这里可以找到最早版本的语法标准。然而，它的语法标准因解析器和编辑器而异，Typora使用的是GitHub Flavored Markdown标准。 需要注意的是在Markdown中的HTML代码块可以被识别但并不会被解析和编译。同样要注意的是，保存之后的文档格式可能会对最初的编写的文档格式有所微调。","categories":[{"name":"Markdown","slug":"Markdown","permalink":"http://onlyorange.top/categories/Markdown/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"http://onlyorange.top/tags/踩坑/"},{"name":"Markdown编辑器","slug":"Markdown编辑器","permalink":"http://onlyorange.top/tags/Markdown编辑器/"}]},{"title":"Hexo generate报错TypeError: Cannot read property &#39utcOffset&#39 of null","slug":"Hexo-generate报错TypeError-Cannot-read-property-39utcOffset-39-of-null","date":"2019-06-22T12:17:05.000Z","updated":"2020-01-08T13:18:06.197Z","comments":true,"path":"2019/06/22/Hexo-generate报错TypeError-Cannot-read-property-39utcOffset-39-of-null/","link":"","permalink":"http://onlyorange.top/2019/06/22/Hexo-generate报错TypeError-Cannot-read-property-39utcOffset-39-of-null/","excerpt":"问题最近刚刚开始使用Hexo，新建了一篇文章，运行hexo g时报错","text":"问题最近刚刚开始使用Hexo，新建了一篇文章，运行hexo g时报错 1TypeError: Cannot read property 'utcOffset' of null 原因研究一番后发现是因为最初设置_config.yml中的时区时，我把timezone: Asia/Shanghai修改为timezone: Asia/Beijing 解决在_config.yml中设置timezone: Asia/Shanghai 拓展常用的程序语言支持的时区属于中国的有六个 … Asia/Chongqing Asia/Shanghai Asia/Urumqi Asia/Macao Asia/Hong_Kong Asia/Taipei 1949年以前，中国一共分了5个时区，以哈尔滨、上海、重庆、乌鲁木齐和喀什为代表，分别是： 长白时区GMT+8:30 中原标准时区GMT+8 陇蜀时区GMT+7 新藏时区GMT+6 昆仑时区GMT+5:30。 它是1912年北京观象台制订，后由内政部批准过.北京也是GMT+8。可能是为了兼容旧的标准，没有新增Asia/Beijing","categories":[{"name":"hexo","slug":"hexo","permalink":"http://onlyorange.top/categories/hexo/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"http://onlyorange.top/tags/踩坑/"}]},{"title":"hexo删除&#34Hello Word&#34初始文章","slug":"hexo-删除-34Hello-Word-34初始文章","date":"2019-06-19T16:47:14.000Z","updated":"2020-01-08T13:18:06.197Z","comments":true,"path":"2019/06/20/hexo-删除-34Hello-Word-34初始文章/","link":"","permalink":"http://onlyorange.top/2019/06/20/hexo-删除-34Hello-Word-34初始文章/","excerpt":"起因Hexo初始有一篇”Hello World”文章，我准备先删除掉它来开始我的blog生涯。但是一波操作之后，刷新界面它还是在那个地方看着，于是学习了一下就有了这篇文章 步骤一般文章的删除步骤为： 删除本地文件 location:本地博客目录位置/source/_posts/你的文章 生成 部署","text":"起因Hexo初始有一篇”Hello World”文章，我准备先删除掉它来开始我的blog生涯。但是一波操作之后，刷新界面它还是在那个地方看着，于是学习了一下就有了这篇文章 步骤一般文章的删除步骤为： 删除本地文件 location:本地博客目录位置/source/_posts/你的文章 生成 部署 12hexo ghexo d 但是我试过一次发现本地删掉了，hexo g报错，博客上还是存在这篇文章的。网上查阅后发现原因是_post文件夹不能为空，新建一篇就好了 解决办法hexo n &quot;博客名字&quot; 保证_post文件夹不为空就好了 拓展在使用hexo写文章时，如果文章的title中包含双引号”abc”、&#36;符号时会编译出错，文章无法渲染。由于这里的写法是yml语法，”、$这些都是特殊符号，执行hexo -s时到编译title这里就会出现错误 解决办法 这里我们需要对特殊符号进行转义，用对应的HTML字符实体进行替换 附录：各种常用特殊字符对应的HTML字符实体 123456789101112131415161718192021222324! &amp;#33; — 惊叹号 Exclamation mark\" &amp;#34; &amp;quot; — 双引号 Quotation mark# &amp;#35; — 数字标志 Number sign$ &amp;#36; — 美元标志 Dollar sign% &amp;#37; — 百分号 Percent sign&amp; &amp;#38; &amp;amp; — 与符号(&amp;) Ampersand' &amp;#39; — 单引号 Apostrophe( &amp;#40; — 小括号左边部分 Left parenthesis) &amp;#41; — 小括号右边部分 Right parenthesis* &amp;#42; — 星号 Asterisk+ &amp;#43; — 加号 Plus sign&lt; &amp;#60; &amp;lt; 小于号 Less than= &amp;#61; — 等于符号 Equals sign- &amp;#45; &amp;minus; — 减号&gt; &amp;#62; &amp;gt; — 大于号 Greater than? &amp;#63; — 问号 Question mark@ &amp;#64; — Commercial at[ &amp;#91; — 中括号左边部分 Left square bracket\\ &amp;#92; — 反斜杠 Reverse solidus (backslash)] &amp;#93; — 中括号右边部分 Right square bracket&#123; &amp;#123; — 大括号左边部分 Left curly brace| &amp;#124; — 竖线Vertical bar&#125; &amp;#125; — 大括号右边部分 Right curly brace空格 &amp;nbsp;","categories":[{"name":"hexo","slug":"hexo","permalink":"http://onlyorange.top/categories/hexo/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://onlyorange.top/tags/blog/"},{"name":"skill","slug":"skill","permalink":"http://onlyorange.top/tags/skill/"}]}]}