{"meta":{"title":"Azure's BLOG","subtitle":"Maker & Developer","description":"“所有的事情，所有身外的期望，所有的骄傲，所有的对困难和失败的恐惧。这些东西在死亡面前立刻消失的无影无踪，只剩下真正重要的东西。” —— Steve Jobs","author":"Sky Azure","url":"https://skyazure.top","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-02-13T12:47:13.720Z","updated":"2020-02-13T12:47:13.720Z","comments":true,"path":"404.html","permalink":"https://skyazure.top/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-02-13T12:39:15.599Z","updated":"2020-02-13T12:39:15.599Z","comments":true,"path":"about/index.html","permalink":"https://skyazure.top/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-02-13T09:59:29.863Z","updated":"2020-02-13T09:59:29.863Z","comments":true,"path":"categories/index.html","permalink":"https://skyazure.top/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-02-13T13:12:26.844Z","updated":"2020-02-13T13:12:26.844Z","comments":true,"path":"friends/index.html","permalink":"https://skyazure.top/friends/index.html","excerpt":"","text":"这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有标签","date":"2020-02-13T13:41:09.304Z","updated":"2020-02-13T13:41:09.304Z","comments":true,"path":"tags/index.html","permalink":"https://skyazure.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"生成和安装requirements.txt依赖","slug":"生成和安装requirements-txt依赖","date":"2020-03-07T11:14:01.000Z","updated":"2020-03-07T11:26:40.036Z","comments":true,"path":"2020/0307/pip-requirements/","link":"","permalink":"https://skyazure.top/2020/0307/pip-requirements/","excerpt":"","text":"Github上的Python项目中，通常存在一个requirements.txt的文件，其记录了当前环境中存在的所有依赖包及其版本号。用来在其他设备上快速重构项目所需依赖。 生成requirements.txt 12pip freeze &gt; requirements.txtpip freeze #此命令可打印出存在的依赖，可预览 安装requirements.txt中依赖 1pip install -r requirements.txt","categories":[{"name":"Python","slug":"Python","permalink":"https://skyazure.top/categories/Python/"}],"tags":[{"name":"pip","slug":"pip","permalink":"https://skyazure.top/tags/pip/"},{"name":"requirements","slug":"requirements","permalink":"https://skyazure.top/tags/requirements/"}]},{"title":"Jupyter notebook使用虚拟环境中module","slug":"Jupyter-notebook使用虚拟环境中module","date":"2020-03-07T09:41:36.000Z","updated":"2020-03-07T11:17:06.579Z","comments":true,"path":"2020/0307/Jupyter-venv-module/","link":"","permalink":"https://skyazure.top/2020/0307/Jupyter-venv-module/","excerpt":"Jupyter notebook选择不同虚拟环境中module Jupyter notebook改变工作路径 Jupyter notebook中文化","text":"Jupyter notebook选择不同虚拟环境中module Jupyter notebook改变工作路径 Jupyter notebook中文化 Jupyter notebook选择不同虚拟环境中module1234conda activate $Your-env-name #激活对应虚拟环境conda install ipykernel #在此环境中安装ipykernel moduleipython kernel install --user --name= $Your-like-name#为此虚拟环境添加对应的kernel 打开jupyter notebook，在界面选择对应虚拟环境的kernel，即可使用其中的模块 Jupyter kernel管理命令 1234#查看当前已有的 jupyter kerneljuputer kernelspec list#删除不再需要的 kerneljupyter kernelspec uninstall $kernel_name Jupyter notebook改变工作路径生成配置文件 12jupyter notebook --generate-config#路径应为$user/.jupyter/`jupyter_notebook_config.py` 执行命令后会显示生成的路径，前往该路径，并打开jupyter_notebook_config.py 123#c.NotebookApp.notebook_dir = ''#将此处修改为c.NotebookApp.notebook_dir = '你希望的路径' Jupyter notebook中文化使用中文终端打开jupyter notebook，界面会自动变为中文 例如使用windows端的Git Bash","categories":[{"name":"DL","slug":"DL","permalink":"https://skyazure.top/categories/DL/"}],"tags":[{"name":"Jupyter notebook","slug":"Jupyter-notebook","permalink":"https://skyazure.top/tags/Jupyter-notebook/"}]},{"title":"Git过滤某文件/文件夹","slug":"git过滤某文件或文件夹","date":"2020-03-06T14:16:38.000Z","updated":"2020-03-06T14:29:01.643Z","comments":true,"path":"2020/0306/Git-checkout-dir/","link":"","permalink":"https://skyazure.top/2020/0306/Git-checkout-dir/","excerpt":"push与pull过滤文件","text":"push与pull过滤文件 push使用”.gitignore“文件在git push时过滤本地库中文件/文件夹 ● 在本地根目录创建.gitignore 123vim .gitignore#或touch .gitignore ● 常用的规则 1234567/abc/ 过滤整个文件夹*.zip 过滤所有.zip文件/abc/do.c 过滤某个具体文件!src/ 不过滤该文件夹!*.zip 不过滤所有.zip文件!/mtk/do.c 不过滤该文件 ● 语法 以斜杠/开头表示目录；以星号*通配多个字符；以问号?通配单个字符以方括号[]包含单个字符的匹配列表；以叹号!表示不忽略(跟踪)匹配到的文件或目录； git 对于 .gitignore配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效 pull使用”sparse-checkout“文件在git pull时过滤远程库中文件/文件夹 ● 在$repo/.git/info/创建.gitignore 12345git sparse-checkout init# 默认情况下，运行此命令会包含/* ！/*/# include everything in root, but nothing two levels below root ● 常用的规则和语法 ​ 与.gitignore相同","categories":[{"name":"Git","slug":"Git","permalink":"https://skyazure.top/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://skyazure.top/tags/Git/"}]},{"title":"Manjaro安装TensorFlow2-gpu","slug":"Manjaro安装tensorflow2.1-gpu","date":"2020-03-06T10:30:28.000Z","updated":"2020-03-07T08:23:41.194Z","comments":true,"path":"2020/0306/Manjaro-TensorFlow2-install/","link":"","permalink":"https://skyazure.top/2020/0306/Manjaro-TensorFlow2-install/","excerpt":"三种方法安装Tensorflow2-gpu","text":"三种方法安装Tensorflow2-gpu 安装Miniconda yay安装 1sudo yay -Sy miniconda3 手动安装 下载Miniconda清华源 1234sh $PATH/Miniconda3-latest-Linux-x86.sh#Yes接受协议#Yes自动配置conda#若终端使用zsh，需要复制~/bashrc末尾的配置路径字段至~/zshrc 终端界面出现（base）字样 1234conda deactivate #退出当前环境#或者关闭自动进入环境#安装conda后，每次启动终端，都会自动启动conda的base环境，conda的环境可以用 conda env list 查看，只要设置conda不要自动启动base环境就可以了。conda config --set auto_activate_base false 安装TensorFlow2.1.0-gpu本机为intel和nvidia双显卡，Manjaro装机时驱动安装选择为non-free 特别注意：使用（混合驱动程序）video-hybrid-intel-nvidia-418xx-bumblebee驱动程序，INTEL将成为活动的主显示芯片（2d），nvidia芯片仅保留用于3d，并且只能在optirun中启动。 安装混合版本驱动，务必注意需要使用optirun来运行python程序， optirun demo.py optirun jupyter notebook Manjaro等Linux的显卡管理不像Windows那样简单易用，修改显卡驱动请谨慎操作，其可能导致启动问题。更多相关内容可以参考文末。 ● 方法一(推荐)：conda and conda​ 使用conda创建虚拟环境，并使用conda安装tensorflow-gpu ● 方法二：conda and pip​ 1. 使用conda创建虚拟环境，激活环境，使用pip安装tensorflow-gpu GPU版需要安装cudnn、cudatoolkit 若运行demo报错请参考issues35968 issues34329 ● 方法三：pacman​ 使用pacman(Manjaro)安装tensorflow-gpu ​ 可参考Installing Tensorflow and CUDA on Manjaro 验证demo.py 1234567import tensorflow as tfversion = tf.__version__gpu_ok = tf.config.list_physical_devices('GPU')print(\"tf version\",version,\"\\nuse GPU\",gpu_ok)&gt;&gt;&gt;tf version 2.1.0 &gt;&gt;&gt;use GPU [PhysicalDevice(name='/physical_device:GPU:0', device_type='GPU')] Windows也可仿照此方法进行安装，因为conda支持多平台 附Manjaro NVIDIA配置相关链接 Configure NVIDIA(non-free) NVIDIA drivers are not loaded NVIDIA Optimus Nvidia-xrun PRIME Bunblebee","categories":[{"name":"DL","slug":"DL","permalink":"https://skyazure.top/categories/DL/"}],"tags":[{"name":"Manjaro","slug":"Manjaro","permalink":"https://skyazure.top/tags/Manjaro/"},{"name":"TensorFlow2","slug":"TensorFlow2","permalink":"https://skyazure.top/tags/TensorFlow2/"}]},{"title":"Conda使用指南","slug":"Conda使用指南","date":"2020-03-05T02:32:00.000Z","updated":"2020-03-05T10:05:40.332Z","comments":true,"path":"2020/0305/Conda-Env-guide/","link":"","permalink":"https://skyazure.top/2020/0305/Conda-Env-guide/","excerpt":"Conda环境管理","text":"Conda环境管理 Conda基础配置 Windows用户请打开“Anaconda Prompt”；macOS和Linux用户请打开“Terminal”（“终端”）进行操作 添加清华镜像 验证conda已被安装 12conda --version&gt;&gt;conda 4.8.2 管理包 12345678910conda install package_name #安装包conda remove package_name #卸载包conda update package_name #更新包conda update conda #更新Condaconda list #列出已安装包conda clean -a #删除索引缓存，锁定文件，未使用的缓存程序包和tarballconda clean -l #删除所有conda锁定文件conda clean -p #从可写程序包缓存中删除未使用的程序包。警告：这不会检查使用符号链接返回到程序包缓存安装的程序包conda clean -t #删除缓存的软件包tarballconda clean -i #清除索引缓存，保证用的是镜像站提供的索引 常用命令 clean Remove unused packages and caches.删除未使用的程序包和缓存。 create Create a new conda environment from a list of specified packages.从指定软件包列表中创建一个新的conda环境。 help Displays a list of available conda commands and their help strings.显示可用的conda命令及其帮助字符串的列表。 install Installs a list of packages into a specified conda environment. 将软件包列表安装到指定的conda环境中。 uninstall Alias for conda remove. conda remove的别名。 list List linked packages in a conda environment.列出conda环境中的链接包。 remove Remove a list of packages from a specified conda environment.从指定的conda环境中删除软件包列表。 run Run an executable in a conda environment. [Experimental]在conda环境中运行可执行文件。 [实验] search Search for packages and display associated information. The input is a MatchSpec, a query language for conda packages.See examples below.搜索软件包并显示相关信息。输入是MatchSpec，这是conda软件包的查询语言。请参见下面的示例。 config Modify configuration values in .condarc. This is modeled after the git config command. Writes to the user .condarc file (C:\\Users\\Azure.condarc) by default.修改.condarc中的配置值。这是在git config命令之后建模的。默认情况下写入用户.condarc文件(C:\\Users \\Azure\\ .condarc) info Display information about current conda install. 显示有关当前conda安装的信息。 package Low-level conda package utility. (EXPERIMENTAL) 低级conda软件包实用程序。（实验性） 卸载conda 1rm -rf ~/anaconda3 Conda管理环境创建 Conda 环境： 1conda create -n $NAME_OF_ENV python=3.6 由于 Conda 管理不同版本的 Python，是把 Python 视为包进行管理的，所以这里指定 Python 版本，相当于指定了初始化 Conda 环境的包 查看 Conda 环境列表： 1conda env list 激活 Conda 环境： 1conda activate $ENV_NAME 退出当前环境： 1conda deactivate 返回默认环境 1conda activate 分享环境：将当前环境信息生成YAML文件 1conda env export &gt; environment.yaml 删除 Conda 环境 1conda env remove -n $ENV_NAME 删除Conda环境及其安装包 1conda remove --name $ENV_NAME --all 参考文章 Anaconda介绍、安装及使用教程（By 豆豆） Conda环境的正确使用姿势（By sigmarising）","categories":[{"name":"Python","slug":"Python","permalink":"https://skyazure.top/categories/Python/"}],"tags":[{"name":"Conda","slug":"Conda","permalink":"https://skyazure.top/tags/Conda/"}]},{"title":"技术书籍汇总","slug":"技术书籍汇总","date":"2020-03-02T06:56:26.000Z","updated":"2020-03-05T08:22:47.839Z","comments":true,"path":"2020/0302/code-book-update/","link":"","permalink":"https://skyazure.top/2020/0302/code-book-update/","excerpt":"热爱生活 ● 热爱阅读","text":"热爱生活 ● 热爱阅读 阅读方法论 一.速读一遍（最好在1~2天内完成） 人的大脑记忆力有限，在一天内快速看完一本书会在大脑里留下深刻印象，对于之后复习以及总结都会有特别好的作用。对于每一章的知识，先阅读标题，弄懂大概讲的是什么主题，再去快速看一遍，不懂也没有关系，但是一定要在不懂的地方做个记号，什么记号无所谓，但是要让自己后面再看的时候有个提醒的作用，看看第二次看有没有懂了些。 二.精读一遍（在2周内看完） 有了前面速读的感觉，第二次看会有慢慢深刻了思想和意识的作用，具体为什么不要问我，去问30年后的神经大脑专家，现在人类可能还没有总结出为什么大脑对记忆的完全方法论，但是，就像我们专业程序员，打代码都是先实践，然后就渐渐懂了过程，慢慢懂了原理，所以第二遍读的时候稍微慢下来，2周内搞定。记住一句话：没看完一个章节后，总结一下这个章节讲了啥。很关键。 三.实践（在整个过程中都要） 实践的时候，要注意不用都去实践，最好看着书，敲下代码，把重点的内容敲一遍有个肌肉记忆就很不错了。以及到自己做过的项目中去把每个有涉及的原理的代码，研究一遍，就可以了 语言类 C语言 《C primer plus》（入门首选） 《C语言程序设计：现代方法》（第2版） 《C和指针》 《C专家编程》 《C陷阱与缺陷》 C++ 《Essential C++》 《C++ primer plus》（第六版） 《Effeetive C++》 《More Effeetive C++》 《C++标准程序库》 《STL源码剖析》 《深度探索C++对象模型》 Python 《Python编程：从入门到实践》 《Python3网络爬虫开发实战》 数据结构与算法 《数据结构与算法分析C++语言描述》 《数据结构与算法分析C语言描述》 《大话数据结构》 MOOC《数据结构》浙江大学 《啊哈！算法哈磊》 《算法竞赛入门经典》（第2版） 《算法》（第四版） 剑指Offer LeetCode 操作系统与组成原理 深入理解计算机系统（第三版） 计算机组成与设计 硬件软件接口（第5版） 计算机网络 《TCP/IP详解》 设计模式 《大话设计模式》 Linux 《鸟哥的Linux私房菜 基础学习篇 第四版》 《Linux命令行与shell脚本编程大全》 《Linux就该这么学》 《UNIX环境高级编程》 《UNIX网络编程》 《深入Linux内核架构》 《深入理解LINUX内核》 《Linux高性能服务器编程》 《POSIX多线程程序设计》 嵌入式 gcc/makefile/cmake 《跟我一起学Makefile》 《debugging with gdb》 深度学习与计算机视觉 《深度学习入门之PyTorch》 《动手学深度学习PyTorch版》 《神经网络与深度学习》 TensorFlow2_tutorials_chinese","categories":[{"name":"折腾","slug":"折腾","permalink":"https://skyazure.top/categories/折腾/"}],"tags":[{"name":"Book","slug":"Book","permalink":"https://skyazure.top/tags/Book/"}]},{"title":"修改Hexo文章链接格式","slug":"修改Hexo文章链接格式","date":"2020-02-18T12:10:08.000Z","updated":"2020-02-19T05:04:59.336Z","comments":true,"path":"2020/0218/set-post-format/","link":"","permalink":"https://skyazure.top/2020/0218/set-post-format/","excerpt":"优化Hexo文章链接格式，使之既不出现中文又便于管理","text":"优化Hexo文章链接格式，使之既不出现中文又便于管理 问题今天给博客配置Gitalk评论插件，配置完成后出现401报错，初始化创建失败，提示Error: Validation Failed.搜索后发现很多博主出现此现象，详见issues#115 由此引发了我对Hexo文章链接格式的关注，我之前所用的合适类似skyazure.top/2020/02/05/Manjaro配置命令/Gitalk的使用是将文章名称经URL编码后添加到issues的label里，但是label的长度上限是50个字符，所以文章名有些长的(尤其是中文名称编码后会较长)都会生成label失败，也就没法评论了。 123https://skyazure.top/2020/02/05/Manjaro配置命令/# 转码后变为https://skyazure.top/2020/02/05/Manjaro%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4/ 修改首先 _config.yml 是 Hexo 的配置文件，在其中找到 permalink，我们发现文章的链接是按照 年/月/日/标题排列的。 1permalink: :year/:month/:day/:title/ 变量 描述 :year 文章的发表年份（4 位数） :month 文章的发表月份（2 位数） :i_month 文章的发表月份（去掉开头的零） :day 文章的发表日期 (2 位数) :i_day 文章的发表日期（去掉开头的零） :title 文件名称 :post_title 文章标题 :id 文章 ID :category 分类。如果文章没有分类，则是 default_category 配置信息 按照默认设置，如果想规避链接中出现中文，文件名称应该设置成英文，但是这样很不方便本地查找文章。解决办法是 打开吧博客根目录/scaffolds/post.md增加urlname字段 12345title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;urlname: categories: tags: 这样每次在hexo n &quot;title&quot;时会在Front-matter中增加urlname 其次，再把博客根目录/_config.yml 的 permalink修改一下，此处修改为 分类/urlname： 1permalink: :category/:urlname/ 这样即使文章title为修改Hexo文章链接格式，但只要设置了urlname: set-post-format和categories: -Blog -Hexo那么生成的网页链接也会显示为 https://skyazure.top/Blog/Hexo/set-post-format/ 如果标签中含有中文可以使用 1permalink: :year:month:day/:urlname/ https://skyazure.top/20200218/set-post-format/ 我要去修改之前的文章了 GG","categories":[{"name":"Blog","slug":"Blog","permalink":"https://skyazure.top/categories/Blog/"},{"name":"Hexo","slug":"Blog/Hexo","permalink":"https://skyazure.top/categories/Blog/Hexo/"}],"tags":[{"name":"Debug","slug":"Debug","permalink":"https://skyazure.top/tags/Debug/"}]},{"title":"Win10和Manjaro双系统记录","slug":"Win10和Manjaro双系统记录","date":"2020-02-13T14:36:28.000Z","updated":"2020-03-06T13:12:50.827Z","comments":true,"path":"2020/0213/Win10-Manjaro-install/","link":"","permalink":"https://skyazure.top/2020/0213/Win10-Manjaro-install/","excerpt":"疫情不能出门那就折腾win10和manjaro双系统吧！","text":"疫情不能出门那就折腾win10和manjaro双系统吧！ 一、准备工作 硬件信息 UEFI+GPT 的架构 128G SSD(已装win10) + 1T HDD 启动相关设置并分配空间 禁用快速启动 电源选项 &gt; 选择电源按钮的功能 &gt; 更改当前不可用的设置 &gt; 关机设置 &gt; [取消勾选] 启用快速启动 &gt; 保存修改 禁用安全启动(Secure Boot) 如果你想在 Win 10 的电脑上双引导 Linux ，安全机制会阻止这样做。所以需要禁用 UEFI 安全引导，以支持 Linux 的双系统启动。进入bios中将安全启动关闭 为Linux从HDD中划分80G未分配空间 ![](https://cdn.jsdelivr.net/gh/SkyAzure/ImgHosting/Azure-Img/article/20200213150126.png) 准备操作系 因为我的win10驱动出了问题，直接重装 Win10：LTSC 1909 OneDrive镜像 百度网盘镜像 Linux：Manjaro KDE Plasma 18.1.5 官方镜像 win系统推荐镜像下载地址：Windsys大量精简优化版本可供下载 二、安装系统 Windows10安装 制作PE系统(这里推荐微PE)到U盘 U盘启动进入PE，使用PG格式化C盘 打开Winouws安装器，选择镜像文件，选择安装驱动器盘为C: ,选择引导驱动器盘为EFI分区盘符一般默认为Z:。挂载盘符随便选一个。 确定，重启即可进入系统 Manjaro安装 使用镜像制作U盘启动盘(推荐Rufus、Etcher) 开始安装 CPU 独显 driver Intel 无 free/intel Intel AMD free Intel NVDIA non free AMD NVDIA non free AMD 无 free 选择手动分区，选择80G未分配空间 未分区磁盘72G，挂载点根节点/，文件系统ext4 EFI分区100M，挂载点/boot/efi，文件系统fat32，内容：保留 未分区磁盘8G，挂载点swap RAM大小 推荐的交换空间 &lt;=2G 2倍RAM 2G-8G =RAM &gt;8G 8G 三、rEFInd管理启动引导 进入manjaro，从官网下载压缩包并解压 在解压好的文件目录打开终端，执行./refind-install 调整refind配置文件，主题美化 调整启动顺序 Manjarosudo efibootmgr Win使用BOOTICE 注意事项： 如果Win10大版本更新后，发现引导界面消失，直接进入Win10，这时需要替换引导文件，调整启动顺序即可 使用Linux某发行版一段时间后，如果想使用其他发行版，请务必将之前的引导文件删除 如果Manjaro更新内核后无法进入win10，这是不可以直接修复Win10引导，这会格式化EFI分区。应修复Windows引导","categories":[{"name":"折腾","slug":"折腾","permalink":"https://skyazure.top/categories/折腾/"}],"tags":[{"name":"Manjaro","slug":"Manjaro","permalink":"https://skyazure.top/tags/Manjaro/"}]},{"title":"Manjaro 配置命令","slug":"Manjaro配置命令","date":"2020-02-05T01:33:28.000Z","updated":"2020-03-08T11:02:25.300Z","comments":true,"path":"2020/0205/Manjaro-set-list/","link":"","permalink":"https://skyazure.top/2020/0205/Manjaro-set-list/","excerpt":"Manjaro 初始化配置记录","text":"Manjaro 初始化配置记录 换源并更新系统1234567891011sudo pacman -Syysudo pacman-mirrors -i -c China -m ranksudo pacman -Syyusudo pacman -Sy vim # 安装vimsudo vim /etc/pacman.conf # 设定软件源分支# 增加[archlinuxcn]SigLevel = Optional TrustedOnlyServer =https://mirrors.ustc.edu.cn/archlinuxcn/$arch#sudo pacman -Syy &amp;&amp; sudo pacman -S archlinuxcn-keyring 安装包pacman -Sy 将本地的包数据库与远程的仓库进行了同步pacman -Su 同步后的更新(与-Syu的差别是-Su只升级系统，-Syu除了升级系统还同步数据库） pacman -Syu 对整个系统进行更新pacman -S 包名 安装包pacman -Sy 包名 同步数据库后安装包pacman -Sv 包名 在显示一些操作信息后执行安装pacman -U 安装本地包,其扩展名为 pkg.tar.gzpacman -U http://www.example.com/repo/example.pkg.tar.xz 安装一个远程包（不在 pacman 配置的源里面） 删除包pacman -R 包名 该命令将只删除包，保留其全部已经安装的依赖关系pacman -Rs 包名 在删除包的同时，删除其所有没有被其他已安装软件包使用的依赖关系pacman -Rsc 包名 在删除包的同时，删除所有依赖这个软件包的程序pacman -Rd 包名 在删除包时不检查依赖 搜索包pacman -Ss 关键字：在仓库中搜索含关键字的包pacman -Qs 关键字： 搜索已安装的包pacman -Qi 包名：查看有关包的详尽信息pacman -Ql 包名：列出该包的文件 pacman -Sw 包名：只下载包，不安装pacman -Sc：清理未安装的包文件，包文件位于 /var/cache/pacman/pkg/ 目录pacman -Scc：清理所有的缓存文件 双系统统一时间12sudo timedatectl set-local-rtc true # 统一linux和Windows时间方案，调整linux为本地时间 安装搜狗输入法12345678910111213141516# 先安装中文语言包sudo pacman -Sy fcitx-im # 默认全部安装 sudo pacman -Sy fcitx-configtoolsudo pacman -Sy fcitx-sogoupinyinvim ~/.xprofile#export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=\"@im=fcitx\"#source ~/.xprofile#报错：sogou输入法异常！请删除～/.config/SougoPY并重启#尝试删除SouPY,SouPY.users,fcitx文件夹，依旧报错sogou-qimpanel # 报错sudo pacman -Sy fcitx-qt4 # 问题解决reboot 安装chrome Typora1234sudo pacman -Sy google-chormesudo pacman -Ss Typora # 查找Typora包sudo pacman -Sy Typora#yay -Sy depin-wine-tim 安装配置electron-ssr1234567sudo pacman -Ss electron-ssrsudo pacman -Sy electron-ssrsudo pacman -Ss proxychains # 全局模式无法使用请安装sudo pacman -Sy proxychains# 修改系统设置－网络－代理－使用系统代理/使用手动配置的代理服务器# HTTP代理：127.0.0.1:12333# SOCKS代理：127.0.0.1:1080 终端美化123456789101112131415161718sudo panman -Sy zsh # 默认已安装sudo vim /etc/passwd##修改user中/bin/bash为/bin/zsh#sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" # 安装oh-my-zshsudo vim ~/.zshrc#export ZSH=\"/home/azure/.oh-my-zsh\"#wget --no-check-certificate -O $ZSH_CUSTOM/themes/pi.zsh-theme https://raw.githubusercontent.com/tobyjamesthomas/pi/master/pi.zsh-theme # 下载Pi主题sudo vim ~/.zshrc#ZSH_THEME=\"pi\"# 重启终端即可 AUR助手1sudo pacman -Sy yay 配置SSH Key到Github12345678~git config --global user.email \"you@example.com\"git config --global user.name \"Your Name\"ssh-keygen -t rsa# 在github中添加～/.ssh/id_rsa.pubssh -T git@github.com# Hi 'user' You've successfully authenticated, but GitHub does not provide shell access. 安装hexo12345678sudo pacman -Sy nodejssudo pacman -Sy npmnode -v # v13.7.0npm -v # 6.13.6sudo npm或cnpm config set registry https://registry.npm.taobao.org # npm换淘宝源sudo npm install hexo-cli -g sudo npm install hexo --save hexo -v 清理12345sudo pacman -R $(pacman -Qdtq) # 清理系统中无用包sudo pacman -Scc # 清除已下载安装包du -t 100M /var # 查看日志垃圾journalctl --disk-usage # 查看日志垃圾sudo journalctl --vacuum-size=50M # 删除指定大小日志文件","categories":[{"name":"折腾","slug":"折腾","permalink":"https://skyazure.top/categories/折腾/"}],"tags":[{"name":"Manjaro","slug":"Manjaro","permalink":"https://skyazure.top/tags/Manjaro/"}]},{"title":"浙大数据结构笔记","slug":"浙大数据结构笔记","date":"2019-11-14T08:02:23.000Z","updated":"2020-02-18T13:56:40.791Z","comments":true,"path":"2019/1114/zju-DataStructures-notebook/","link":"","permalink":"https://skyazure.top/2019/1114/zju-DataStructures-notebook/","excerpt":"Data Structures","text":"Data Structures ● 基本概念1 什么是数据结构1.1 其他定义 数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。 ——Sartaj Sahni 《数据结构、算法与应用》 数据结构是 ADT（Abstract Data Type，数据抽象类型）的物理实现。 ——Clifford A.Shaffer 《数据结构与算法分析》 数据结构（data structure）是计算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来最优效率的算法。 ——中文维基百科 1.2 解决问题方法的效率 跟数组的组织方式有关 跟空间的利用效率有关 跟算法的巧妙程度有关 1.3 最终定义 数据对象在计算机中的组织方式 逻辑结构 物理存储结构 数据对象必定与一系列加在其上的操作相关联 完成这些操作所用的方法就是算法 1.4 抽象数据类型（Abstract Data Type） 数据类型 数据对象集 数据集合相关联的操作集 抽象：描述数据类型的方法不依赖于具体实现 与存放数据的机器无关 与数据存储的物理结构无关 与实现操作的算法和编程语言均无关 只描述数据对象集和相关操作集“是什么”，并不涉及“如何做到”的问题 2 什么是算法2.1 定义 一个有限指令集 ≥ 0 的输入 0 的输出 一定在有限步骤之后终止 每一条指令必须 有充分明确的目标，不可以有歧义 计算机能处理范围内 描述应不依赖于任何一种计算机语言以及具体的实现手段 2.2 描述算法的手段 空间复杂度 S(n) 根据算法写成的程序在执行时占用存储空间的长度 时间复杂度 T(n) 根据算法写成的程序在执行时耗费的时间的长度 2.3 评价 在分析一般算法的效率时，常常关注","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://skyazure.top/categories/数据结构/"}],"tags":[{"name":"Data Structures","slug":"Data-Structures","permalink":"https://skyazure.top/tags/Data-Structures/"}]},{"title":"hexo博客美化","slug":"hexo博客美化","date":"2019-11-13T03:24:43.000Z","updated":"2020-03-08T10:57:56.682Z","comments":true,"path":"2019/1113/Hexo-beautify/","link":"","permalink":"https://skyazure.top/2019/1113/Hexo-beautify/","excerpt":"美美哒","text":"美美哒 【01】主题的选择将NexT7.0换为 Material X 下载主题源码到 themes/ 文件夹 1git clone https://github.com/xaoxuu/hexo-theme-material-x themes/material-x 然后安装必要的依赖包 1npm i -S hexo-generator-search hexo-generator-json-content hexo-renderer-less 修改站点配置文件 1theme: material-x","categories":[{"name":"Blog","slug":"Blog","permalink":"https://skyazure.top/categories/Blog/"},{"name":"Hexo","slug":"Blog/Hexo","permalink":"https://skyazure.top/categories/Blog/Hexo/"}],"tags":[{"name":"美化","slug":"美化","permalink":"https://skyazure.top/tags/美化/"}]},{"title":"工作技能","slug":"工作技能","date":"2019-10-19T05:51:57.000Z","updated":"2020-03-09T04:27:42.267Z","comments":true,"path":"2019/1019/Job-skill/","link":"","permalink":"https://skyazure.top/2019/1019/Job-skill/","excerpt":"要变强 ！","text":"要变强 ！ 嵌入式系统软件工程师-高通无线通信技术(中国)有限公司-北京 熟练掌握 C/C++, Linux shell 编程语言，具有 Python/Perl/Java/Makefile 经验更佳； 熟悉Linux操作系统，驱动，内核开发。 例如以下领域，u-boot, PCIe/PCI, Ethernet, DDR, LCD,Camera, USB, and Power Management； 了解 CPU 架构，例如 ARM，MIPS 更佳； 了解机器学习更佳； 优秀的中英文沟通技巧； 快速学习能力； 基本的问题解决能力； 通信，计算机，电子等相关专业，本科及以上学历。 嵌入式系统工程师-阿里巴巴集团新零售技术事业群-杭州 工作职责： 参与工厂数字化改造方案中嵌入式 IoT 设备端的开发工作； 负责多个 IoT 设备系列的嵌入式端侧软件架构设计； 探索当前互联网主流框架与嵌入式 IoT 设备端侧架构的创新结合，如 Flutter、Node.js 等技术在嵌入式端侧的应用 任职要求： 5年以上嵌入式开发经验，精通 C/C++ 编程语言，熟悉面向对象编程和常用的设计模式，具有良好的编码规范； 精通 Node.js、Python、Lua 等脚本语言，熟悉设计模式，具备架构能力； 有各类工业现场协议对接经验的优先； 沟通能力强，有较强的自我驱动力和快速学习能力。责任心强，具备良好团队合作精神； 具备极客精神，熟练使用常见数据结构，算法，熟悉队列、消息、多线程、网络编程、事件机制等技术的应用； 追求优雅的工程实现和问题解决 加分项： 精通基于 linux 的底层系统构建，如 uboot,kernel 等在不同方案上的移植、优化； 熟悉 MTK/RK/TI/NXP 等一家或多家主控芯片的产品化引用； 具备技术产品的设计、架构和实现能力，有强烈的进取心推进产品化实现； 嵌入式软件开发工程师-阿里巴巴 岗位描述 IoT 芯片驱动、AI 算法、面向领域的应用解决方案开发； IoT 芯片操作系统开发； IoT 芯片编译工具链、模拟器、调试器、IDE 开发和性能优化 岗位要求 本科及以上学历，计算机、嵌入式等相关专业； 具有良好的算法基础及软件编程能力； 熟悉至少一门编程语言, ASM/C/C++/Python； 富有激情，有创新意识和能力，具有自我驱动和良好的团队合作能力； 良好的沟通和表达能力，能够主动发现并解决问题。加分项： 有嵌入式系统或智能硬件开发经验； 有编译器开发经验； 熟悉 Linux 或 RTOS 操作系统内核； 熟悉一种以上物联网协议； 熟悉深度学习算法，量化算法 嵌入式软件开发工程师-天津深之蓝海洋设备科技有限公司-天津 工作职责： STM32 嵌入式软件开发。 任职要求： 本科及以上学历； 一年及以上嵌入式软件工作经验； 具有STM32嵌入式软件开发经验； 熟悉UCOSIIRTOS、FreeRTOS、RTX、RT-Thread至少一种嵌入式操作系统，具有掌握RTX、RT-Thread操作系统的优先考虑； 嵌入式软件工程师-科沃斯-苏州 工作职责： 参与软件系统的方案设计，负责公司机器人产品软件开发； 不同平台下软件分析规划、功能模块开发和技术难点攻关； 负责软件设计、代码编写和调试； 负责相关技术文档的编写； 负责指导助理软件工程师的开发工作，提供技术支持。 任职要求： 精通C/C++语言，精通数据结构，具有良好的代码编写习惯； 熟悉MCU/ARM处理器架构，熟练掌握软件编译环境和软件调试工具； 熟练各种常用硬件接口和传感器设备的驱动开发和调试，有网络通信（wifi、蓝牙、Zigbee等）相关经验； 有一定的算法学习研究、分析设计能力，对机器人技术感兴趣，具有创新思维； 有较强的分析和解决问题能力，有持续自我学习的能力和意愿，善于沟通和逻辑表达 工作积极主动，具有团队协作能力，服从领导安排。 加分项： 有FreeRTOS开发经验者优先； 有软件底层开发经验者优先。 机器人导航算法开发-石头科技-北京 工作职责: 负责开发机器人的行走，转向，脱困，避障等算法 职位要求： 三年以上C++编程经验，精通常用算法和数据结构 熟悉Linux编程和常用的调试工具 有室内定位和运动控制开发经验的优先 机器人系统软件开发-石头科技-北京 工作职责: 负责开发优化机器人系统架构，系统升级和系统安全软件 职位要求: 三年以上C++编程经验，熟悉常用算法和数据结构 深入理解Linux操作系统，了解系统内核和文件系统 了解常用的设计模式 嵌入式系统工程师-Calmcar(天瞳威视)-天津 工作职责： 开发和优化基于DSP/ARM的视觉算法 配合硬件工程师及FPGA工程师完成相关的测试及接口定义 设计文档的整理、撰写及审核，做好转生产工作，确保产品的小批量、批量生产的顺利进行 任职要求： 计算机、电子通信等相关专业，具有相关项目开发3-5年经验 丰富的编程经验，C/C++ ，熟悉瑞萨、TI等平台 丰富的电子开发经验，Digital and Analog Design 熟悉DSP/ARM架构，能完成程序的移植及优化 具备较强的软件设计文档编写能力 工作认真负责，具有较强的承压能力 具有较强的沟通协调能力、学习能力以及良好的团队合作精神 加分项： 熟悉汽车电子，比如CAN，汽车线束 熟悉机器学习与模式识别技术 熟悉图像识别领域的常见工具，如OpenCV 熟悉CUDA 了解FMEA、Six Sigma流程 热爱汽车电子技术 高级嵌入式软件工程师(相机)-dji 工作职责 负责相机核心功能模块的设计、开发与调试； 负责新技术的调研与难题攻关； 负责产品功能、性能及稳定性等方面的调优； 负责指导新员工的开发工作。 任职要求 计算机、电子相关专业毕业，本科及以上学历；5年以上嵌入式软件开发经验，熟悉软件开发流程，具有较强的软件设计和开发能力； 精通C语言、数据结构，具有良好的代码编写习惯； 精通基于ARM的嵌入式软件开发和调试，精通编译工具及调试工具的使用； 精通Linux或者任意一款主流嵌入式操作系统的移植、裁剪、驱动开发和应用开发； 具有很强的独立开发能力，以及问题分析、解决能力；具有一定的硬件知识，能看懂原理图；具有良好的沟通能力和团队合作精神，具有较强的抗压能力；有相机相关开发经验者优先。 高级嵌入式软件工程师(Android系统方向) -dji 工作职责 负责Android系统ROM定制以及Android平台产品化开发； 负责系统UI裁剪和定制化开发，对Android HAL和Framework相关模块进行优化； 负责系统显示性能优化，提升产品体验； 根据公司的产品需求，开发相应的Framework服务及系统应用。 任职要求 统招本科及以上学历，计算机科学、电子工程、通信相关专业毕业； 5年以上Android系统开发经验，精通C/C++语言，熟悉Linux Kernel及驱动开发，了解Java编程； 熟悉Android系统框架，具备较强的开发、调试、性能优化能力，熟练使用Systrace、Traceview等工具； 熟悉Android系统的UI显示机制，有显示系统开发及性能调优的工作经验； 对ACodec、MediaCodec、OMX、SurfaceFlinger、HWC等有深入理解； 熟悉V4L2架构，熟悉Android系统的camera框架； 能熟练编写及阅读shell脚本，熟悉git版本管理工具，熟悉gerrit及jenkins环境者更佳； 具备丰富的Android手机产品系统开发经验者优先考虑； 能承担较大工作压力，工作认真负责，积极主动。 高级嵌入式软件优化工程师-dji 工作职责 感知算法在嵌入式平台上的资源消耗评估，指导算法工程师按嵌入式平台的限制优化算法； 感知算法在嵌入式处理器上的软件移植，优化，集成，调试； 感知算法硬件加速器的驱动，集成，调试。 任职要求 硕士及以上学历，5年以上相关工作经验； 精通C/C++； 精通DSP或NEON代码优化；熟悉vector C或intrinsic C编程； 熟悉cache，DMA等memory优化技能。 嵌入式软件架构师-dji 工作职责 收集并分析市场和产品需求，完成架构设计； 制定相关技术演进的roadmap，以及实施计划； 带领团队设计并开发复杂异构的操作系统以及多媒体系统解决方案，满足不同应用场景的需求； 设计要求高稳定性、低功耗、高性能、高安全性等的软硬件解决方案； 深入理解产品，参与产品的整个生命周期的开发过程，包括需求定义、设计、实现、测试、生产、售后等； 制定和改善软件的开发流程； 跟踪嵌入式领域最新的技术发展，对团队进行技术指导。 任职要求 EE，CE，CS或同等专业硕士及以上学位，6年以上相关开发经验，1年以上架构师经验； 深度参与至少1款产品的架构设计，对于设计简单、高复用、高扩展、高可靠、高性能、低功耗的架构有深入理解和体会； 丰富的嵌入式软件开发经验，如：操作系统（RTOS、Linux、Android）、安全、媒体链路、GPU等； 深入理解SoC架构，以及系统优化方法，如NEON、DSP、GPU等； 具有较强的开发和编程实践能力，以及良好的质量意识； 至少参与过一款产品的敏捷开发实践，如：Scrum、Kanban等； 良好的沟通协调能力，以及较好的驱动力； 良好的学习能力及团队领导力，喜欢挑战。 高级嵌入式软件工程师（感知） 工作职责 嵌入式软件开发流程和规范的梳理和把控； 视觉感知功能在嵌入式处理器上的方案设计、功能开发、性能分析与优化、系统级问题定位等； RTOS在嵌入式处理器上的移植、开发、调试。 任职要求 本科及以上学历，五年以上相关工作经验； 精通C/C++； 精通至少一种嵌入式RTOS（如freeRTOS、threadx、nucleus、QNX…），有RTOS移植经验； 精通实时性、调度抢占、中断优先级、中断嵌套、优先级翻转等问题； 责任心强、有良好的合作精神、有较强的学习能力和沟通协调能力； 有图像处理或视觉感知相关工作者优先，有硬件开发调试经验者优先，有Linux编程开发经验者优先 高级嵌入式软件工程师（LinuxKernel方向） 工作职责 负责uboot、kernel和Android hal层的移植； 负责Linux应用、内核和设备驱动程序的开发； 负责Android APP、Framework和Native层的开发； 参与无线图传相关的业务代码的编写； 参与测试用例的制定及测试文档的编写。 任职要求 熟悉uboot、kernel和Android hal层的移植，有过不同芯片平台的移植经验； 熟悉Linux应用（多进程、多线程、网络等）、内核（内存管理、进程管理、中断、锁、文件系统等）的开发及调试方法； 熟悉Linux设备驱动的开发（USB、EMMC、HDMI、Audio等），具备定位硬件问题的能力； 熟悉Android Framework和Native层的工作原理，能对AMS/WMS/SurfaceFlinger等进行优化，具备添加新组件的能力； 熟悉Android APP层的开发，能对系统应用进行定制和优化，能开发简单的用户应用； 具备Android系统性能优化的经验，能充分发挥CPU、GPU、DDR、VPU等硬件的极限性能，提升系统流畅度和稳定性； 了解音视频编解码算法和无线通信原理（WIFI/SDR）的优先。 高级嵌入式软件工程师（导航） 工作职责 负责职能功能模块的设计、开发和调试； 负责产品功能、性能和稳定性等方面的优化； 负责指导组内软件同事的开发和技术深度的提高。 任职要求 计算机、电子相关专业毕业，本科及以上学历；5年以上嵌入式软件开发经验，熟悉软件开发流程，具有较强的软件设计和开发能力； 精通C&amp;C++语言、数据结构，具有良好的代码编写习惯； 丰富的Linux应用开发经验，有嵌入式软件架构设计相关经验优先考虑； 精通基于ARM的嵌入式软件开发和调试，精通编译工具以及调试工具的使用； 具有很强的独立开发能力，以及问题分析、解决能力； 具有良好的沟通能力和团队合作能力，具有较强的抗压能能力；有计算机视觉系统相关开发经验者优先。 嵌入式软件开发工程师（BSP）-海康威视-杭州 工作职责： 根据产品和业务需求开发嵌入式系统底层软件，设计和实现软件功能，并编写相应开发文档； 开发、测试和维护产品中各种芯片驱动软件； 对系统软件进行优化，提升系统性能、可靠性和稳定性。 任职资格： 本科及以上学历，计算机、电子信息、通信等相关专业，对英文技术文档有较好的阅读理解能力； 熟练使用C语言，有汇编语言或脚本语言的使用经验； 熟悉常用总线和接口协议，如I2C、SPI、UART，了解基本网络知识； 了解单片机、ARM、DSP、X86等至少一种芯片架构及组成； 了解操作系统原理，理解中断、进程、内存等基本概念，有Linux/RTOS上驱动或应用程序开发经验优先。 嵌入式软件开发工程师（算法应用）-海康威视-杭州 工作职责： 1、负责嵌入式算法组件在嵌入式芯片上的系统集成和系统性能调优；2、负责嵌入式算法组件后处理算法的开发和结合产品应用的功能开发和调优。 任职资格： 1、数学/计算机相关专业，研究生及其以上学历，2年算法开发或者偏算法应用的开发经验，有智能驾驶算法、机器人比赛等开发经验者优先；2、熟悉视频/雷达/IMU/GPS等传感和定位的基本原理和应用；3、了解并熟练应用FMEA/FTA者优先；4、具备一定的嵌入式SOC开发经验，理解基本操作系统线程、进程任务调度，了解ISO26262功能安全；5、具备较强的学习能力、良好团队合作意识和抗压性。 智能传感算法工程师（传感器\\深度感知\\三维重建\\VSLAM\\AR\\移动机器人\\计算光学成像等）-海康威视-杭州 工作职责： 负责传感器、深度感知（TOF、双目、结构光等）、三维重建、VSLAM、AR、移动机器人、计算光学成像的算法或者系统的设计及开发。 任职资格： 硕士及以上学历，计算机、光学、电子、仪器、通信、自控、数学等相关专业； 有较好的系统思维，知识面丰富，熟悉计算机视觉、传感器、信号处理、光学设计、嵌入式、硬件等相关技术之一； 具备较强的全局观，良好的沟通与协作能力，能够系统、全面地看待及分析问题； 具备下述项目经验之一者优先： 具备雷达、激光雷达、多传感器系统设计或算法开发经验； 具备深度感知（双目/TOF/结构光等）、三维重建、VSLAM等系统设计或算法开发经验之一； 具备AR/VR、移动机器人、计算光学（高光谱等）等系统设计或算法开发经验之一； 具备光学系统设计和开发经验； 具备DSP、ARM等软硬件系统开发优化经验。 运动控制算法工程师 工作职责： 参与机械臂及足式机器人的控制系统的搭建； 参与总体结构方案设计，关键元器件选型等； 对机械臂或足式机器人进行运动学、动力学建模，完成误差标定、参数辨识、轨迹规划等基本功能。 负责机械臂或足式机器人算法应用的开发。 任职资格： 硕士及以上学历，计算机、机器人、自动化等相关专业； 具备机械臂或足式机器人运动规划算法以及算法应用开发的经验，掌握机器人运动学，动力学，轨迹规划等相关知识； 熟悉ROS系统，了解MOVEIT、Gazebo等常用相关工具，熟练使用C/C++等编程语言； 沟通表达协调能力好，能无障碍阅读英文文献； 有足式机器人相关竞赛经验者优先。 2020届C/C++软件工程师（linux、嵌入式）-大华股份-杭州 工作职责： 你将和业界优秀的软件工程师前辈、专家一起，研发功能领先、性能卓越的产品，接触、参与到前沿技术，不断突破、快速成长，包括但不限于： 负责产品软件的设计、编码、调试等工作，相关技术文档撰写； 负责产品软件研发及商用过程中的功能、性能、可靠性等问题的定位解决； 负责产品软件关键技术、前沿技术的预研和产品化，提升产品优势与核心价值，为客户提供持续领先解决方案； 探索、洞察业界技术新方向，持续创新，与前辈、技术专家技术交流、合作。 任职资格： 全日制本科及以上学历，计算机、电子信息、软件工程、自动化等相关专业； 热爱编程、基础扎实，熟悉C/C++语言，对操作系统原理、Linux、CPU等有一定的了解； 参加竞赛获奖者、国际期刊发表论文者、有实际项目经验者优先考虑。 嵌入式工程师-小米集团-北京 岗位描述： 负责手机各种外设驱动的开发优化工作，比如Camera、LCD、Touch、Audio、Charger、Sensor等； 负责Linux Kernel相关开发优化工作，如稳定性优化、性能优化等。 任职要求： 计算机、软件、电子、通信等相关专业本科及以上学历； 熟悉C/C++语言编程，有一定的硬件功底； 熟悉数据结构和算法，了解操作系统原理； 学习能力强，思路清晰，团队合作能力好，适应快节奏、高效率工作； 熟练读懂英文文档，并能进行英语交流； 优先条件： 熟悉Linux kernel原理，有相关产品开发优化经验； 熟悉Linux驱动模型，有相关设备驱动开发经验； 参加过大学生电子设计竞赛（或同类型竞赛）并获奖者； 有嵌入式/单片机开发经验。 嵌入式软件工程师-小米集团 工作职责： 负责小米智能语音产品嵌入式Linux平台搭建； 负责集成小米智能语音算法并封装SDK,提供给所有小米智能语音产品使用； 负责将小米智能语音算法移植到各嵌入式平台； 职位要求： 精通C/C++编程和数据结构； 熟悉嵌入式Linux系统开发和算法移植； 熟悉Linux多线程、多进程编程； 熟悉Linux/Unix下的网络编程； 嵌入式高级研发软件工程师 岗位职责： 小米智能家居IoT-WIFI平台研发工作 负责/参与IoT-WIFI平台需求分析，方案设计，功能开发，调试以及性能优化等工作 岗位要求： 计算机、通信、自动化等相关专业，硕士5年以上、本科8年以上嵌入式软件开发经验 精通802.11、Wi-Fi相关协议和TCP/IP协议，精通网络编程 精通C/C++语言，熟悉设计模式，具有良好的编程风格和文档编制习惯 熟悉LINUX或者RTOS，精通多线程编程 熟悉网络安全和系统安全设计者优先 具备嵌入式软硬件协同能力者优先 积极主动、善于沟通、良好的团队合作意识 嵌入式系统工程师-美团-北京 岗位职责 承担无人车系统中底层嵌入式控制系统开发工作，侧重底层信号采集处理与控制决策、执行机控制，或域控制器开发。 在ARM或FPGA平台上，构建完备的信号采集、计算处理、执行部件实时控制系统。涉及各器件及功能模块的接口与驱动、通讯、控制算法实现与优化。 控制算法开发，涉及传感器融合、移动机器人学/车辆控制、电机控制；实现同时需要顾及响应实时性，可靠性，以及容错机制设计。 配合控制单元测试、集成测试、整车测试。 产品/技术文档。 任职要求 控制工程、电子工程、机电工程、车辆工程或其他相关专业硕士及以上学历。 熟悉ARM或FPGA，熟悉常用总线与接口技术，具备电路原理图阅读能力。 熟悉RTOS、运动控制技术；或熟悉Linux、有ROS开发经验。 有实际项目研发经历，调试经验丰富。 工作自驱动，责任心强，良好的团队合作精神。 具备以下者优先： 有创新证明（获奖、论文、专利等）。 岗位亮点： 较好的跨专业（机械、电子、控制系统）工作机会。 涉及车辆控制、机器人技术、无人驾驶技术。","categories":[{"name":"Job","slug":"Job","permalink":"https://skyazure.top/categories/Job/"}],"tags":[{"name":"skill","slug":"skill","permalink":"https://skyazure.top/tags/skill/"}]},{"title":"MPU6050姿态结算","slug":"MPU6050姿态结算","date":"2019-10-13T03:33:28.000Z","updated":"2020-03-06T11:18:08.134Z","comments":true,"path":"2019/1013/Mpu6050-calculation/","link":"","permalink":"https://skyazure.top/2019/1013/Mpu6050-calculation/","excerpt":"IMU（Inertial measurement unit），中文翻译为惯性测量单元，是一种能够测量物体三轴加速度和角速度进而解算出物体姿态的装置。一般的，一个IMU包含了三个单轴的加速度计和三个单轴的陀螺仪，加速度计检测物体在载体坐标系统独立三轴的加速度信号，而陀螺仪检测载体相对于导航坐标系的角速度信号，测量物体在三维空间中的角速度和加速度，并以此解算出物体的姿态。在导航中有着很重要的应用价值。为了提高可靠性，还可以为每个轴配备更多的传感器，例如地磁传感器。MPU6050属于IMU的一种，包含了三个单轴的加速度计和三个单轴的陀螺仪。 加速度计原理与姿态解算 陀螺仪原理与姿态解算 融合加速度计和陀螺仪的数据","text":"IMU（Inertial measurement unit），中文翻译为惯性测量单元，是一种能够测量物体三轴加速度和角速度进而解算出物体姿态的装置。一般的，一个IMU包含了三个单轴的加速度计和三个单轴的陀螺仪，加速度计检测物体在载体坐标系统独立三轴的加速度信号，而陀螺仪检测载体相对于导航坐标系的角速度信号，测量物体在三维空间中的角速度和加速度，并以此解算出物体的姿态。在导航中有着很重要的应用价值。为了提高可靠性，还可以为每个轴配备更多的传感器，例如地磁传感器。MPU6050属于IMU的一种，包含了三个单轴的加速度计和三个单轴的陀螺仪。 加速度计原理与姿态解算 陀螺仪原理与姿态解算 融合加速度计和陀螺仪的数据 需要姿态融合的原因为什么要有同时具备加速度计和陀螺仪。看了上面的介绍，我们发现单单通过加速度计或者陀螺仪就能解算出物体姿态，为什么IMU要同时具备两种功能相似的仪器呢？ 答案很简单：加速度计的数据不是100%准确的。有几个原因，还记加速度计测量的是惯性力，这个力可以由重力引起（理想情况只受重力影响），当也可能由设备的加速度（运动）引起。因此，就算加速度计处于一个相对比较平稳的状态，它对一般的震动和机械噪声很敏感。这就是为什么大部分的IMU系统都需要陀螺仪来使加速度计的输出更平滑。但是怎么办到这点呢？陀螺仪不受噪声影响吗？ 陀螺仪也会有噪声，但由于它检测的是旋转，因此对线性机械运动没那么敏感，不过陀螺仪有另外一种问题，比如漂移（当选择停止的时候电压不会回到零速率电压）并且陀螺仪是通过对旋转角度的累加进行姿态解算，所以长时间工作会有极大的误差。然而，通过计算加速度计和陀螺仪的平均值我们能得到一个相对更准确的当前设备的倾角值，这比单独使用加速度计更好。 通过上面的分析我们可以发现，加速度计短时间内精度较差，而长时间稳定性好，陀螺仪短时间内精度高，但会累计误差，只要将两者的数据进行互补，就能解算出正确的姿态。 姿态融合MPU6050 是一款姿态传感器，使用它就是为了得到待测物体（如四轴、平衡小车） x、y、z 轴的倾角（俯仰角 Pitch、滚转角 Roll、偏航角 Yaw） 。我们通过 I2C 读取到 MPU6050 的六个数据（三轴加速度 AD 值、三轴角速度 AD 值）经过姿态融合后就可以得到 Pitch、Roll、Yaw 角。本帖主要介绍三种姿态融合算法： 四元数法 一阶互补算法 卡尔曼滤波算法。 四元数法 关于四元数的一些概念和计算就不写上来了，我也不懂。我能告诉你的是：通过下面的算法，可以把六个数据转化成四元数（q0、q1、q2、q3），然后四元数转化成欧拉角（P、R、Y 角）。 ​ 虽然 MPU6050 自带的 DMP库可以直接输出四元数，减轻 STM32 的运算负担， 这里在此没有使用，因为我是用 STM32 的硬件 I2C 读取 MPU6050 数据的（http://bbs.elecfans.com/forum.ph … 4&amp;page=1#pid3625735） DMP库需要对 I2C 函数进行修改，如 DMP 库中的 I2C 写：i2c_write(st.hw-&gt;addr, st.reg-&gt;pwr_mgmt_1, 1, &amp;(data[0]))；有4个输入变量，而 STM32 硬件 I2C 的 I2C 写为：void MPU6050_I2C_ByteWrite(u8 slaveAddr, u8 pBuffer, u8 writeAddr)，只有 3 个输入量（这之间的差异好像是由于 MPU6050 的 DMP 库是针对 MSP430 单片机写的），所以必须进行修改，但是改固件库是一件很痛苦的事，你们应该都懂。当然，如果你用模拟 I2C 的话，是容易实现的，网上的 DMP 移植几乎都是基于模拟 I2C 的。 要注意的的是，四元数算法输出的是三个量 Pitch、Roll 和 Yaw，运算量很大。而像平衡小车这样的例子只需要一个角（Pitch 或 Roll ）就可以满足工作要求，个人觉得做平衡小车最好不用四元数法。 一阶互补算法 MPU6050 可以输出三轴的加速度和角速度。通过加速度和角速度都可以得到 Pitch 和 Roll 角（加速度不能得到 Yaw 角），就是说有两组 Pitch、Roll 角，到底应该选哪组呢？别急，先分析一下。MPU6050 的加速度计和陀螺仪各有优缺点，三轴的加速度值没有累积误差，且通过算 tan() 可以得到倾角，但是它包含的噪声太多（因为待测物运动时会产生加速度，电机运行时振动会产生加速度等），不能直接使用；陀螺仪对外界振动影响小，精度高，通过对角速度积分可以得到倾角，但是会产生累积误差。所以，不能单独使用 MPU6050 的加速度计或陀螺仪来得到倾角，需要互补。一阶互补算法的思想就是给加速度和陀螺仪不同的权值，把它们结合到一起，进行修正。得到 Pitch 角的程序如下： 123456789101112131415161718192021//一阶互补滤波float K1 =0.1; // 对加速度计取值的权重float dt=0.001;//注意：dt的取值为滤波器采样时间float angle_P,angle_R; //angle_ax=atan(ax/az)*57.3; //加速度得到的角度//gy=(float)gyo[1]/7510.0; //陀螺仪得到的角速度Pitch = yijiehubu_P(angle_ax,gy);Roll = yijiehubu_R(angle_ax,gy);float yijiehubu_P(float angle_m, float gyro_m)//采集后计算的角度和角加速度&#123; angle_P = K1 * angle_m + (1-K1) * (angle_P + gyro_m * dt); return angle_P;&#125; float yijiehubu_R(float angle_m, float gyro_m)//采集后计算的角度和角加速度&#123; angle_R = K1 * angle_m + (1-K1) * (angle_R + gyro_m * dt); return angle_R;&#125; 互补算法只能得到一个倾角，这在平衡车项目中够用了，而在四轴飞行器设计中还需要 Roll 和 Yaw，就需要两个 互补算法。单靠 MPU6050 无法准确得到 Yaw 角，需要和地磁传感器结合使用。 卡尔曼滤波 其实卡尔曼滤波和一阶互补有些相似，输入也是一样的。在此给出具体程序，和一阶互补算法一样，每次卡尔曼滤波只能得到一个方向的角度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;math.h&gt;#include \"stm32f10x.h\"#include \"Kalman_Filter.h\" //卡尔曼滤波参数与函数float dt=0.001;//注意：dt的取值为kalman滤波器采样时间float angle, angle_dot;//角度和角速度float P[2][2] = &#123;&#123; 1, 0 &#125;, &#123; 0, 1 &#125;&#125;;float Pdot[4] =&#123; 0,0,0,0&#125;;float Q_angle=0.001, Q_gyro=0.005; //角度数据置信度,角速度数据置信度float R_angle=0.5 ,C_0 = 1;float q_bias, angle_err, PCt_0, PCt_1, E, K_0, K_1, t_0, t_1; //卡尔曼滤波float Kalman_Filter(float angle_m, float gyro_m)//angleAx 和 gyroGy &#123; angle+=(gyro_m-q_bias) * dt; angle_err = angle_m - angle; Pdot[0]=Q_angle - P[0][1] - P[1][0]; Pdot[1]=- P[1][1]; Pdot[2]=- P[1][1]; Pdot[3]=Q_gyro; P[0][0] += Pdot[0] * dt; P[0][1] += Pdot[1] * dt; P[1][0] += Pdot[2] * dt; P[1][1] += Pdot[3] * dt; PCt_0 = C_0 * P[0][0]; PCt_1 = C_0 * P[1][0]; E = R_angle + C_0 * PCt_0; K_0 = PCt_0 / E; K_1 = PCt_1 / E; t_0 = PCt_0; t_1 = C_0 * P[0][1]; P[0][0] -= K_0 * t_0; P[0][1] -= K_0 * t_1; P[1][0] -= K_1 * t_0; P[1][1] -= K_1 * t_1; angle += K_0 * angle_err; //最优角度 q_bias += K_1 * angle_err; angle_dot = gyro_m-q_bias;//最优角速度 return angle；&#125; 三种融合算法都能够输出姿态角（Pitch 和 Roll ），一次四元数法可以输出 P、R、Y 三个倾角，计算量比较大。一阶互补和卡尔曼滤波每次只能输出一个轴的姿态角。 陀螺仪漂移的解决方法横滚角和俯仰角的偏差可以通过卡尔曼滤波或者一阶互补滤波即可消除漂移量. 但是航向角存在的偏差很难由自身来校准,这是由于:Z轴在静止状态下没有漂移，运动情况下有累积误差。因为Z轴角度是通过对角速度积分计算出来的，没有观测量滤波，所以漂移是不可避免的。X、Y轴的角度是根据重力加速度分量计算，X，Y轴是有重力场滤波，所以不会有漂移。Z轴只能用短时间内的相对测量量。 就是相邻两次的角度差来计算转过的角度。 可以采用带地磁的9轴陀螺仪来降低漂移量,但是仍然无法完全解决这个问题.而且地磁计对周围磁场的变化敏感,多磁场和多电机的工作环境都会导致地磁计不准.","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://skyazure.top/categories/嵌入式/"}],"tags":[{"name":"IMU传感器","slug":"IMU传感器","permalink":"https://skyazure.top/tags/IMU传感器/"}]},{"title":"C/C++ sizeof函数总结","slug":"C-C-sizeof函数总结","date":"2019-10-12T07:42:20.000Z","updated":"2020-03-08T11:06:04.741Z","comments":true,"path":"2019/1012/C-sizeof/","link":"","permalink":"https://skyazure.top/2019/1012/C-sizeof/","excerpt":"解决 sizeof 求结构体大小的问题","text":"解决 sizeof 求结构体大小的问题 一、C/C++ 中不同数据类型所占用的内存大小 数据类型 32位 64位 char 1 1 int 4 大多数4(少数8) short 2 2 long 4 8 float 4 4 double 8 8 *指针 4 8 （单位都为字节） 结构体(struct)：比较复杂，对齐问题需要考虑清楚。 联合(union)：取所有成员中最长的作为联合的长度。 枚举(enum)：根据数据类型。 二、sizeof 计算单层结构体大小运算符sizeof可以计算出给定类型的大小，对于 32 位系统来说， sizeof(char) = 1; sizeof(int) = 4。 基本数据类型的大小很好计算，我们来看一下如何计算构造数据类型的大小。 C语言中的构造数据类型有三种 数组 结构体 共用体 数组是相同类型的元素的集合，只要会计算单个元素的大小，整个数组所占空间等于基础元素大小乘上元素的个数。 结构体中的成员可以是不同的数据类型，成员按照定义时的顺序依次存储在连续的内存空间。和数组不一样的是，结构体的大小不是所有成员大小简单的相加，需要考虑到系统在存储结构体变量时的地址对齐问题。看下面这样的一个结构体： 123456struct stu1&#123; int i; char c; int j;&#125; 用sizeof求该结构体的大小，发现值为 12 。int占 4 个字节，char占 1 个字节，结果应该是 9 个字节才对啊，为什么呢？ 先介绍一个相关的概念——偏移量。偏移量指的是结构体变量中成员的地址和结构体变量地址的差。结构体大小**等于最后一个成员的偏移量加上最后一个成员的大小**。显然，结构体变量中第一个成员的地址就是结构体变量的首地址。因此，第一个成员i的偏移量为 0。第二个成员 c 的偏移量是第一个成员的偏移量加上第一个成员的大小（0+4）,其值为 4；第三个成员j的偏移量是第二个成员的偏移量加上第二个成员的大小（4+1）,其值为 5。 然而，在实际中，存储变量时地址要求对齐，编译器在编译程序时会遵循两条原则： 结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍） 结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。 上面的例子中前两个成员的偏移量都满足要求，但第三个成员的偏移量为5，并不是自身(int)大小的整数倍。编译器在处理时会在第二个成员后面补上 3 个空字节，使得第三个成员的偏移量变成8。结构体大小等于最后一个成员的偏移量加上其大小，上面的例子中计算出来的大小为 12，满足要求。 再来看另外一个例子： 12345struct stu2&#123; int k; short t;&#125; 成员k的偏移量为 0；成员t的偏移量为 4，都不需要调整。但计算出来的大小为 6，显然不是成员 k 大小的整数倍。因此，编译器会在成员 t 后面补上 2 个字节，使得结构体的大小变成8从而满足第二个要求。 由此可见，结构体类型需要考虑到字节对齐的情况. 不同的顺序也会影响结构体的大小 对比下面两种定义顺序： 123456789101112struct stu3 &#123; char c1; int i; char c2; &#125; struct stu4 &#123; char c1; char c2; int i; &#125; 虽然结构体 stu3 和 stu4 中成员都一样，但 sizeof(struct stu3) 的值为 12 而 sizeof(struct stu4) 的值为 8 共用体中的成员公用同一段内存，所以整个联合体的 sizeof 是所有成员中占用内存最大的成员的 sizeof，联合体要考虑内存对齐，整体空间长度要是公用体中长度最大的数据类型的整数倍 1234union st&#123; char a[9]; int b[2];&#125;s 结果分析： sizeof(a)=9*1=9 sizeof(b)=2*4=8 选两者中最大的一个，即 9，考虑内存对齐，整体空间长度要是公用体中长度最大的数据类型的整数倍，在这里是 int 占用空间的整数倍，比 9 大的且是 4 的整数倍的最小数是 12 拓展枚举类 enum 型空间计算 enum 只是定义了一个常量集合，里面没有“元素”，而枚举类型是当做 int 来存储的，所以枚举类型的 sizeof 值都为 4 12345enum color(red,pink,white,black)c;void main()&#123; cout&lt;&lt;sizeof(enum); //值为4&#125; 三、sizeof计算嵌套的结构体大小对于嵌套的结构体，需要将其展开。对结构体求 sizeof 时，上述两种原则变为： 展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大的成员的整数倍。 结构体大小必须是所有成员大小的整数倍，这里所有成员计算的是展开后的成员，而不是将嵌套的结构体当做一个整体。 被展开的结构体的规则同单结构体 sizeof 计算规则。 原则 1： 12345678910struct stu5 &#123; short i; struct &#123; char c; int j; &#125; ss; int k; &#125; 结构体 stu5 的成员 ss.c 的偏移量应该是 4，而不是 2。整个结构体大小应该是 16，即 4+（4+4）+4，第二个 4是 char c 的扩展(由后面 int j 导致)。 原则 2： 1234567891011121314struct stu5 &#123; char i; struct &#123; char c; int j; &#125; ss; char a; char b; char d; char e; char f; &#125; 结构体 ss单独计算占用空间为8，而 stu5 的 sizeof 则是 20 （由17扩展至 20，而不是扩展到 24），不是 8 的整数倍，这说明在计算 sizeof(stu5) 时，将嵌套的结构体 ss 展开了，这样 stu5 中最大的成员为 ss.j ，占用 4 个字节， 20 为 4 的整数倍。如果将 ss 当做一个整体，结果应该是 24 了。 另一个常见的例子： 结构体中包含数组，其 sizeof 应当和处理嵌套结构体一样，将其展开 123456struct ss &#123; float f; char p; int adf[3]; &#125;; 补充另外一个涉及数据类型以及内存存储的问题 内存中的数据并非保存在任意地址。处理器通常按照和其字大小相同的块读取内存数据；那么考虑到效率因素，编译器会按照块大小的整数倍对内存中的实体进行地址对齐。因此在 32 位的处理器上，一个 4 字节整型数据肯定存放在内存地址能被 4 整除的地方。 下面，假设系统中整型数据和指针大小均为 4 字节。现在有一个指向整型的指针。如上所述，整型数据可以存放在内存地址 0×1000 或者 0×1004 或者 0×1008，但是决不会存放在 0×1001 或者 0×1002 或者 0×1003 或者其他不能被 4 整除的任何地址。所有是4整数倍的二进制数都是以 00 结尾。实际上，这意味着对于所有指向整型的指针，它的最后两位总是 0。","categories":[{"name":"C语言","slug":"C语言","permalink":"https://skyazure.top/categories/C语言/"}],"tags":[{"name":"结构体","slug":"结构体","permalink":"https://skyazure.top/tags/结构体/"}]},{"title":"数据结构与算法知识点","slug":"数据结构与算法知识整理","date":"2019-10-11T05:06:33.000Z","updated":"2020-03-08T10:57:29.312Z","comments":true,"path":"2019/1011/DataStructures-knowledge-list/","link":"","permalink":"https://skyazure.top/2019/1011/DataStructures-knowledge-list/","excerpt":"知识点整理","text":"知识点整理 ● 完全二叉树与满二叉树的区别满二叉树是完全二叉树的特例，因为满二叉树已经满了，而完全并不代表满。所以形态你也应该想象出来了吧，满指的是出了叶子节点外每个节点都有两个孩子，而完全的含义则是最后一层没有满，并没有满。 ● 已知二叉树的前序遍历和中序遍历求后续遍历现有二叉搜索树（BST）前序遍历结果序列为abdefgc，中序遍历结果序列为debgfac，请问后序遍历结果序列? 答：前序遍历结果序列为 abdefgc，中序遍历结果序列为 debgfac以此为条件，根据前序知道a是根，根据中知道debgf为左子树，c为右子树。根据前知道b为左子树中的根，根据中知道de为b的左，gf为右，根据前和中判断d为根，e为右，f为根，g为左，树成型，得出后序结果 edgfbca ● 已知啊 a * b = c，求系统进制如果某系统 15*4=112 成立，则系统采用的是几进制？ 将原式转为 X进制：1 5 * 4 = 1 1 2（X+5）* 4 = X^2+X+2解方程即可 x=6 ● 栈 设栈 S 和队列 Q 的初始状态均为空，元素啊，a,b,c,d,e,f,g 依次进入栈 S。若每个元素出栈后立即进入推列Q，且7个元素出队的顺序是 b,d,,c,f,e,a,g，则栈 S 的容量至少是？ 栈是先进后出，队列是先进先出，所以元素出队列的顺序就是出栈的顺序。出栈的顺序为 b,d,c,f,e,a,g，这意味着 a,b 进入，b 出； c,d 进入，此时栈中有 a,d,c，出来 d,c； e,f 进入， 此时栈中有 a,e,f，出来 f,e,a； g 进入，此时栈中有 g，出来 g； 由此看出整个过程中栈中存在的元素最多有 3 个，所以栈 S 的容量至少是 3 一个栈的入栈序列是 a,b,c,d,e,f,则栈的不可能的输出序列是（） A:fedcba B:defbca C:defcba D:abcdef A. 可以全进栈然后依次出栈B. 不可以C. 先进 adcd 然后 d 出，再进 e，e 出再进 f，f 出剩下的依次 cba出D. 一个进，一个出 ● 网络延迟网络延迟是指在传输介质中传输所用的时间，即从报文开始进入网络到它开始离开网络之间的时间。 ● 完全二叉树的存储完全二叉树由于其结构上的特点，通常采用顺序存储方式存储(数组)。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://skyazure.top/categories/数据结构/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://skyazure.top/tags/算法/"}]},{"title":"知识点随笔","slug":"技术知识随笔","date":"2019-10-11T02:44:57.000Z","updated":"2020-02-18T13:41:09.674Z","comments":true,"path":"2019/1011/job-knowledge-list/","link":"","permalink":"https://skyazure.top/2019/1011/job-knowledge-list/","excerpt":"知识点整理","text":"知识点整理 ● 黑盒测试与白盒测试任何工程产品(注意是任何工程产品)都可以使用以下两种方法之一进行测试。 黑盒测试：已知产品的功能设计规格，可以进行测试证明每个实现了的功能是否符合要求。 白盒测试：已知产品的内部工作过程，可以通过测试证明每种内部操作是否符合设计规格要求，所有内部成分是否以经过检查。 软件的黑盒测试意味着测试要在软件的接口处进行。这种方法是把测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。因此黑盒测试又叫功能测试或数据驱动测试。 黑盒测试主要是为了发现以下几类错误： 是否有不正确或遗漏的功能? 在接口上，输入是否能正确的接受?能否输出正确的结果? 是否有数据结构错误或外部信息(例如数据文件)访问错误? 性能上是否能够满足要求? 是否有初始化或终止性错误? 软件的白盒测试是对软件的过程性细节做细致的检查。这种方法是把测试对象看做一个打开的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。通过在不同点检查程序状态，确定实际状态是否与预期的状态一致。因此白盒测试又称为结构测试或逻辑驱动测试。 白盒测试主要是想对程序模块进行如下检查： 对程序模块的所有独立的执行路径至少测试一遍。 对所有的逻辑判定，取“真”与取“假”的两种情况都能至少测一遍。 在循环的边界和运行的界限内执行循环体。 测试内部数据结构的有效性，等等。 以上事实说明，软件测试有一个致命的缺陷，即测试的不完全、不彻底性。由于任何程序只能进行少量(相对于穷举的巨大数量而言)的有限的测试，在未发现错误时，不能说明程序中没有错误。 如果能够执行完美的黑盒测试，还需要进行白盒测试吗? 从以上可以看出就算完美的黑盒测试也是无法测试程序内部特定部位，另外当规格说明本身有误，也不能发现问题。而白盒测试能对程序的内部特定部位进行覆盖测试，所以黑盒和白盒测试为互补关系，结合起来测试用例的设计更为合理。 经验表明，通常在进行单元测试时采用白盒测试方法，集成测试采用灰盒测试方法，系统测试采用黑盒测试方法。 ● 简述单工、半双工、全双工的区别网络的领域内，单工、半双工、全双工是经常会遇见的名称，下面简单的讲述一下他们的区别。 单工：简单的说就是一方只能发信息，另一方则只能收信息，通信是单向的。 半双工：比单工先进一点，就是双方都能发信息，但同一时间则只能一方发信息。 全双工：比半双工再先进一点，就是双方不仅都能发信息，而且能够同时发送。 ● 笔试面试知识整理​ 参考链接 ● 设计模式创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。","categories":[{"name":"Job","slug":"Job","permalink":"https://skyazure.top/categories/Job/"}],"tags":[{"name":"知识点","slug":"知识点","permalink":"https://skyazure.top/tags/知识点/"}]},{"title":"Linux及计算机网络知识点汇总","slug":"Linux与计算机网络知识点整理","date":"2019-10-11T02:44:34.000Z","updated":"2020-02-27T02:30:44.066Z","comments":true,"path":"2019/1011/Linux-net-knowledge-list/","link":"","permalink":"https://skyazure.top/2019/1011/Linux-net-knowledge-list/","excerpt":"知识点整理","text":"知识点整理 ● Linux内核五大模块 进程调度模块 内存管理模块 文件系统模块 进程间通信模块 网络接口模块 ● 死锁 掌握死锁的概念和产生死锁的根本原因。 理解产生死锁的必要条件–以下四个条件同时具备：互斥条件、不可抢占条件、占有且申请条件、循环等待条件。 记住解决死锁的一般方法，掌握死锁的预防和死锁的避免二者的基本思想。 掌握死锁的预防策略中资源有序分配策略。 理解进程安全序列的概念，理解死锁与安全序列的关系。 了解银行家算法。 了解资源分配图。 了解死锁的检测及恢复的思想。 ———————————————— 原文链接：https://blog.csdn.net/abigale1011/article/details/6450845 死锁产生的原因： 竞争资源 进程推进顺序不当 ● TCP/IP协议详解 参考文章 ● 最受欢迎的Linux发行版(现第2), Manjaro折腾全记录（超长超详细） 参考文章 ● 对于一个分布式计算系统来说3个指标不能同时完成 一致性 可用性 分区容错性 ● OSI参考模型中各层作用物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）数据链路层：将比特组装成帧和点到点的传递（帧Frame）网络层：负责数据包从源到宿的传递和网际互连（包PackeT）传输层：提供端到端的可靠报文传递和错误恢复（段Segment）会话层：建立、管理和终止会话（会话协议数据单元SPDU）表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）应用层：允许访问OSI环境的手段（应用协议数据单元APDU） 网络层： IP协议 ICMP协议 ARP协议 RARP协议。 传输层： UDP协议 TCP协议。 应用层： FTP（文件传送协议） Telenet（远程登录协议） DNS（域名解析协议） SMTP（邮件传送协议） POP3协议（邮局协议） HTTP协议 SNMP协议 TFTP ● OSI七层模型和TCP/IP四层模型OSI七层模型各层协议： 物理层：RJ45、CLOCK、IEEE802.3 数据链路层：PPP、FR、HDLC、VLAN、MAC 网络层：IP、IPX、OSPF、RIP、IGRP、ICMP、ARP、RARP 传输层：TCP、UDP、SPX 会话层：NFS、SQL、NETBIOS、RPC 表示层：JPEG、MPEG、ASII 应用层：Telnet、HTTP、FTP、WWW、NFS、SMTP TCP/IP四层模型： 一- TCP/IP四层模型名称：网络接口层（Network Access）【又分为物理层（Physical）和数据链路层（Datalink）】→网络互联层（Internet）→传输层（Transport）→应用层（Application） 二、TCP/IP四层模型各层的功能： 网络接口层：负责实际数据的传输 网络互联层：负责网络间的寻址数据传输 传输层：负责提供可靠的传输服务 应用层：负责实现一切与应用程序相关的功能 三、TCP/IP四层模型各层的协议： 网络接口层：HDLC（高级链路控制协议）、PPP（点对点协议）、SLIP（串行线路接口协议） 网络互联层：IP（网际协议）、ICMP（网际控制消息协议）、ARP（地址解析协议）、RARP（反向地址解析协议） 传输层：TCP（控制传输协议）、UDP（用户数据报协议） 应用层：FTP（文件传输协议）、HTTP（超文本传输协议）、DNS（域名服务器协议）、SMTP（简单邮件传输协议）、NFS（网络文件系统协议） 四、OSI七层模型和TCP/IP四层模型的区别： OSI七层模型和TCP/IP四层模型最大的区别在于：OSI七层模型是一个理论上的网络通信模型，而TCP/IP四层模型则是实际运行的网络协议。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://skyazure.top/categories/Linux/"}],"tags":[{"name":"知识点","slug":"知识点","permalink":"https://skyazure.top/tags/知识点/"}]},{"title":"Python 知识点整理","slug":"Python知识点整理","date":"2019-10-11T02:44:12.000Z","updated":"2020-03-08T11:06:20.782Z","comments":true,"path":"2019/1011/Python-knowledge-list/","link":"","permalink":"https://skyazure.top/2019/1011/Python-knowledge-list/","excerpt":"知识点整理","text":"知识点整理 ● 正则表达式的贪婪与非贪婪匹配12String str=\"abcaxc\";Patter p=\"ab*c\"; 贪婪匹配(.*)：正则表达式一般趋向于最大长度匹配，也就是所谓的贪婪匹配。如上面使用模式 p 匹配字符串 str，结果就是匹配到：abcaxc(ab*c)。 非贪婪匹配(.*?)：就是匹配到结果就好，就少的匹配字符。如上面使用模式 p 匹配字符串 str，结果就是匹配到：abc(ab*c)。","categories":[{"name":"Python","slug":"Python","permalink":"https://skyazure.top/categories/Python/"}],"tags":[{"name":"知识点","slug":"知识点","permalink":"https://skyazure.top/tags/知识点/"}]},{"title":"python str和list排序并删除重复数据","slug":"python-str和list排序并删除重复数据","date":"2019-06-30T06:31:26.000Z","updated":"2020-03-08T11:02:08.202Z","comments":true,"path":"2019/0630/Python-str-sort/","link":"","permalink":"https://skyazure.top/2019/0630/Python-str-sort/","excerpt":"排序并删除重复数据","text":"排序并删除重复数据 一、排序函数 sort() 和 sorted()sort() 是 Python 列表的一个内置的排序方法，list.sort() 方法排序时直接修改原列表，返回None； sorted() 是 Python 内置的一个排序函数，它会从一个迭代器返回一个排好序的新列表。 相比于 sort()，sorted() 使用的范围更为广泛，但是如果不需要保留原列表，sort 更有效一点。另外，sort() 只是列表的一个方法，只适用于列表，而sorted() 函数接受一切迭代器，返回新列表。 这两个方法有以下 2 个共同的参数： key 是带一个参数的函数，返回一个值用来排序，默认为 None。这个函数只调用一次，所以 fast。 reverse 表示排序结果是否反转 1234567891011121314151617&gt;&gt;&gt; a = (1,2,4,2,3) # a 是元组，故不能用sort() 排序&gt;&gt;&gt; a.sort()Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'tuple' object has no attribute 'sort'&gt;&gt;&gt; sorted(a) # sorted() 可以为元组排序，返回一个新有序列表[1, 2, 2, 3, 4]&gt;&gt;&gt; a=['1',1,'a',3,7,'n']&gt;&gt;&gt; sorted(a)[1, 3, 7, '1', 'a', 'n']&gt;&gt;&gt; a # sorted() 不改变原列表['1', 1, 'a', 3, 7, 'n'] &gt;&gt;&gt; print a.sort()None&gt;&gt;&gt; a # a.sort()直接修改原列表[1, 3, 7, '1', 'a', 'n'] 因此如果实际应用过程中需要保留原有列表，使用 sorted() 函数较为适合，否则可以选 择 sort() 函数，因为 sort() 函数不需要复制原有列表，消耗的内存较少，效率也较高。 sorted() 函数功能非常强大，它可以方便地针对不同的数据结构进行排序，从而满足不同需求。例子如下： 对字典进行排序 1234&gt;&gt;&gt; sorted(&#123;1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'&#125;) # 根据字典键排序[1, 2, 3, 4, 5]&gt;&gt;&gt; sorted(&#123;1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'&#125;.values()) # 根据字典值排序['A', 'B', 'B', 'D', 'E'] 对多维列表排序 12345&gt;&gt;&gt; student_tuples = [('john', 'A', 15),('jane', 'B', 12),('dave', 'B', 10)]&gt;&gt;&gt; sorted(student_tuples, key = lambda student: student[0]) # 对姓名排序[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]&gt;&gt;&gt; sorted(student_tuples, key = lambda student: student[2]) # 年龄排序[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)] 调用operator模块中的 itemgetter() 可以实现根据多个参数排序 123456&gt;&gt;&gt; sorted(student_tuples, key = itemgetter(2)) # 根据年龄排序[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]&gt;&gt;&gt; sorted(student_tuples, key = itemgetter(1, 2)) # 根据成绩和年龄排序[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]&gt;&gt;&gt; sorted(student_tuples, key = itemgetter(1, 2), reverse=True) # 反转排序结果[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)] ps: itemgetter 返回一个函数，实现取元素的功能。比如 f = itemgetter(2)，调用 f(r) 返回 r[2]; f = itemgetter(2, 5, 3)，调用 f(r) 返回元组 (r[2], r[5], r[3]). 二、python集合(set)操作python的set和其他语言类似, 是一个无序不重复元素集, 基本功能包括关系测试和消除重复元素. 集合对象还支持union(联合), intersection(交), difference(差) 和 sysmmetric difference(对称差集)等数学运算. 下面来点简单的小例子说明 1234&gt;&gt;&gt; x = set('spam')&gt;&gt;&gt; y = set(['h','a','m'])&gt;&gt;&gt; x, y(set(['a', 'p', 's', 'm']), set(['a', 'h', 'm'])) 再来些小应用。 12345678&gt;&gt;&gt; x &amp; y # 交集set(['a', 'm'])&gt;&gt;&gt; x | y # 并集set(['a', 'p', 's', 'h', 'm'])&gt;&gt;&gt; x - y # 差集set(['p', 's']) 记得以前个网友提问怎么去除海量列表里重复元素，用 hash 来解决也行，只不过感觉在性能上不是很高，用 set 解决还是很不错的，示例如下： 1234567&gt;&gt;&gt; a = [11,22,33,44,11,22]&gt;&gt;&gt; b = set(a)&gt;&gt;&gt; bset([33, 11, 44, 22])&gt;&gt;&gt; c = [i for i in b]&gt;&gt;&gt; c[33, 11, 44, 22] 集合用于包含一组无序的对象。要创建集合，可使用 set() 函数并像下面这样提供一系列的项： 123s = set([3,5,9,10]) #创建一个数值集合t = set(\"Hello\") #创建一个唯一字符的集合 与列表和元组不同，集合是无序的，也无法通过数字进行索引。此外，集合中的元素不能重复。例如，如果检查前面代码中 t 集合的值，结果会是： 12&gt;&gt;&gt; tset(['H', 'e', 'l', 'o']) 注意只出现了一个 ‘l’ 。 集合支持一系列标准操作，包括并集、交集、差集和对称差集，例如： 1234a = t | s # t 和 s的并集b = t &amp; s # t 和 s的交集c = t – s # 求差集（项在t中，但不在s中）d = t ^ s # 对称差集（项在t或s中，但不会同时出现在二者中） 基本操作：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172t.add('x') # 添加一项s.update([10,37,42]) # 在s中添加多项t.remove('H')#使用remove()可以删除一项len(s)#set 的长度x in s#测试 x 是否是 s 的成员x not in s#测试 x 是否不是 s 的成员s.issubset(t)s &lt;= t#测试是否 s 中的每一个元素都在 t 中s.issuperset(t)s &gt;= t#测试是否 t 中的每一个元素都在 s 中s.union(t)s | t#返回一个新的 set 包含 s 和 t 中的每一个元素s.intersection(t)s &amp; t#返回一个新的 set 包含 s 和 t 中的公共元素s.difference(t)s - t#返回一个新的 set 包含 s 中有但是 t 中没有的元素s.symmetric_difference(t)s ^ t#返回一个新的 set 包含 s 和 t 中不重复的元素s.copy()#返回 set “s”的一个浅复制hash(s)#返回 s 的 hash 值s.update(t)s |= t#返回增加了 set “t”中元素后的 set “s”s.intersection_update(t)s &amp;= t#返回只保留含有 set “t”中元素的 set “s”s.difference_update(t)s -= t#返回删除了 set “t”中含有的元素后的 set “s”s.symmetric_difference_update(t)s ^= t#返回含有 set “t”或者 set “s”中有而不是两者都有的元素的 set “s”s.remove(x)#从 set “s”中删除元素 x, 如果不存在则引发 KeyErrors.discard(x)#如果在 set “s”中存在元素 x, 则删除s.pop()#删除并且返回 set “s”中的一个不确定的元素, 如果为空则引发 KeyErrors.clear()#删除 set “s”中的所有元素 三、str和list排序 删除重复数据 List 排序并删除重复值 1234&gt;&gt;&gt; a =[1,1,2,3,4,5,4,2,3,1]&gt;&gt;&gt; b =sorted(set(a)) &gt;&gt;&gt; print(b)[1,2,3,4,5] List 排序不删除重复值 1234&gt;&gt;&gt; a=[1,1,2,3,4,5,4,2,3,1]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; print (a)[1, 1, 1, 2, 2, 3, 3, 4, 4, 5] String 排序不删除重复值 123456&gt;&gt;&gt; a=\"abchabcgesdfaad\"&gt;&gt;&gt; b=list(a)&gt;&gt;&gt; b.sort()&gt;&gt;&gt; s=\"\".join(b)&gt;&gt;&gt;print (s)aaaabbccddefghs String 排序删除重复值 12345&gt;&gt;&gt; a=\"abchabcgesdfaad\"&gt;&gt;&gt; b=list(a)&gt;&gt;&gt; c=sorted(set(b))&gt;&gt;&gt; c['a','b','c','d','e','f','g','h','s']","categories":[{"name":"Python","slug":"Python","permalink":"https://skyazure.top/categories/Python/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://skyazure.top/tags/排序/"}]},{"title":"python 获取当前目录，上级目录，上上级目录","slug":"python获取当前目录，上级目录，上上级目录","date":"2019-06-30T03:55:28.000Z","updated":"2020-03-08T10:54:43.073Z","comments":true,"path":"2019/0630/Python-get-dir/","link":"","permalink":"https://skyazure.top/2019/0630/Python-get-dir/","excerpt":"","text":"12345678910111213import os print '***获取当前目录***'print os.getcwd()print os.path.abspath(os.path.dirname(__file__)) print '***获取上级目录***'print os.path.abspath(os.path.dirname(os.path.dirname(__file__)))print os.path.abspath(os.path.dirname(os.getcwd()))print os.path.abspath(os.path.join(os.getcwd(), \"..\")) print '***获取上上级目录***'print os.path.abspath(os.path.join(os.getcwd(), \"../..\"))","categories":[{"name":"Python","slug":"Python","permalink":"https://skyazure.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://skyazure.top/tags/Python/"}]},{"title":"Typora取消继承上一行格式","slug":"Typora取消继承上一行格式","date":"2019-06-27T08:01:01.000Z","updated":"2020-03-08T10:54:07.695Z","comments":true,"path":"2019/0627/Typora-cancel-inherit/","link":"","permalink":"https://skyazure.top/2019/0627/Typora-cancel-inherit/","excerpt":"Debug !","text":"Debug ! 问题使用 Typora 写列表时，换行会继承上一行的格式 解决办法Mac command+[ windows ctrl+[ 即可取消继承 补充：直接按方向键时不自动继承上一行的，按 Enter 会继承上一行","categories":[{"name":"Debug","slug":"Debug","permalink":"https://skyazure.top/categories/Debug/"}],"tags":[{"name":"Typora","slug":"Typora","permalink":"https://skyazure.top/tags/Typora/"}]},{"title":"Git安装及Github基本使用","slug":"Git安装及Github基本使用","date":"2019-06-27T07:32:58.000Z","updated":"2020-03-06T14:14:56.228Z","comments":true,"path":"2019/0627/Git-Github-Mac/","link":"","permalink":"https://skyazure.top/2019/0627/Git-Github-Mac/","excerpt":"","text":"安装git在Mac上安装git 首先在终端输入git查看是否已安装过git 通过homebrew安装git 未安装homebrew，先安装homebrew 1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 安装git 1brew install git 创建ssh key、配置git 设置username和email（github每次commit都会记录他们） 12git config --global user.name \"你的用户名\"git config --global user.email \"你的邮箱地址\" 生成ssh key 1ssh-keygen -t rsa -C \"你的邮箱地址\" 然后直接三个回车即可，默认不需要设置密码 然后找到~/下生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制 打开GitHub_Settings_keys页面，新建new SSH Key Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。在Git Bash中检测GitHub公钥设置是否成功，终端输入 ssh git@github.com 123Last login: Sat Jan 6 14:42:55 on ttys000你的主机名:~ 你的用户名$ ssh git@github.com Hi 你刚刚设置的user.name! You've successfully authenticated, but GitHub does not provide shell access. 说明已经链接成功。 提交本地项目到Github 在GitHub上新创建一个 repository或者Start a Project 填写项目信息，填写完成后点击Create repository Clone工程到本地，首先复制ssh 地址 然后克隆项目,终端输入 1git clone 你复制的ssh地址 这时，工程已经被克隆到所在文件夹 进入clone下来的文件夹，使用编辑器等修改并保存代码 提交修改，首先切换到文件夹所在目录 1234567cd clone下来的文件夹的地址//文件添加到仓库（.代表提交所有文件）git add .//把文件提交到仓库git commit -m \"First Commit\"//上传到githubgit push 查看GitHub上的项目，就已经上传成功啦 参考文章: Git教程 GitHub+Hexo 搭建个人网站详细教程","categories":[{"name":"Git","slug":"Git","permalink":"https://skyazure.top/categories/Git/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://skyazure.top/tags/GitHub/"}]},{"title":"hexo不解析Markdown标题","slug":"Typora编辑器使用中的问题","date":"2019-06-22T13:07:03.000Z","updated":"2020-02-20T14:11:06.723Z","comments":true,"path":"2019/0622/Typora-Markdown-title/","link":"","permalink":"https://skyazure.top/2019/0622/Typora-Markdown-title/","excerpt":"Debug !","text":"Debug ! 问题发布文章后标题没有被解析显示#标题 ，但是在我编辑器(Typora)里面显示没有问题 原因Markdown标题标准写法需要在”#”和后面字符之间加一个空格 不加空格一些引擎就解析不了 Typora编辑器中在行首有#，就会自动识别为标题 注意需要注意写Markdown文档时要严格遵守Markdowm标准 拓展 Markdown诞生自 Daring Fireball之手，点击这里可以找到最早版本的语法标准。然而，它的语法标准因解析器和编辑器而异，Typora使用的是GitHub Flavored Markdown标准。 需要注意的是在Markdown中的HTML代码块可以被识别但并不会被解析和编译。同样要注意的是，保存之后的文档格式可能会对最初的编写的文档格式有所微调。","categories":[{"name":"Debug","slug":"Debug","permalink":"https://skyazure.top/categories/Debug/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://skyazure.top/tags/Markdown/"},{"name":"Typore","slug":"Typore","permalink":"https://skyazure.top/tags/Typore/"}]},{"title":"Hexo generate 报错 TypeError: Cannot read property &#39utcOffset&#39 of null","slug":"Hexo-generate报错TypeError-Cannot-read-property-39utcOffset-39-of-null","date":"2019-06-22T12:17:05.000Z","updated":"2020-03-08T11:00:17.795Z","comments":true,"path":"2019/0622/Hexo-g-Debug/","link":"","permalink":"https://skyazure.top/2019/0622/Hexo-g-Debug/","excerpt":"Debug !","text":"Debug ! 问题最近刚刚开始使用 Hexo，新建了一篇文章，运行 hexo g 时报错 1TypeError: Cannot read property 'utcOffset' of null 原因研究一番后发现是因为最初设置 _config.yml 中的时区时，我把 timezone: Asia/Shanghai修改为timezone: Asia/Beijing 解决在 _config.yml 中设置 timezone: Asia/Shanghai 拓展 常用的程序语言支持的时区属于中国的有六个 … Asia/Chongqing Asia/Shanghai Asia/Urumqi Asia/Macao Asia/Hong_Kong Asia/Taipei 1949年以前，中国一共分了 5 个时区，以哈尔滨、上海、重庆、乌鲁木齐和喀什为代表，分别是： 长白时区GMT+8:30 中原标准时区GMT+8 陇蜀时区GMT+7 新藏时区GMT+6 昆仑时区GMT+5:30。 它是 1912 年北京观象台制订，后由内政部批准过.北京也是 GMT+8。可能是为了兼容旧的标准，没有新增 Asia/Beijing","categories":[{"name":"Blog","slug":"Blog","permalink":"https://skyazure.top/categories/Blog/"},{"name":"Hexo","slug":"Blog/Hexo","permalink":"https://skyazure.top/categories/Blog/Hexo/"}],"tags":[{"name":"Debug","slug":"Debug","permalink":"https://skyazure.top/tags/Debug/"}]},{"title":"hexo删 Hello Word","slug":"hexo删除Hello Word","date":"2019-06-19T16:47:14.000Z","updated":"2020-03-08T10:59:27.549Z","comments":true,"path":"2019/0620/Hexo-delete-helloword/","link":"","permalink":"https://skyazure.top/2019/0620/Hexo-delete-helloword/","excerpt":"hexo如何删除初始文章","text":"hexo如何删除初始文章 起因Hexo 初始有一篇 “Hello World” 文章，我准备先删除掉它来开始我的 blog 生涯。但是一波操作之后，刷新界面并没有起作用。 步骤一般文章的删除步骤为： 删除本地文件 location:本地博客目录位置/source/_posts/你的文章 生成 部署 12hexo ghexo d 但是我试过一次发现本地删掉了，hexo g报错，博客上还是存在这篇文章的。网上查阅后发现原因是_post文件夹不能为空，新建一篇就好了 解决办法hexo n &quot;博客名字&quot; 保证_post文件夹不为空就好了 拓展 在使用 hexo 写文章时，如果文章的title中包含双引号 ”abc”、&#36;符号时会编译出错，文章无法渲染。由于这里的写法是 yml 语法，”、$ 这些都是特殊符号，执行 hexo -s 时到编译 title 这里就会出现错误 这里我们需要对特殊符号进行转义，用对应的 HTML 字符实体进行替换附录：各种常用特殊字符对应的 HTML 字符实体 123456789101112131415161718192021222324! &amp;#33; — 惊叹号 Exclamation mark\" &amp;#34; &amp;quot; — 双引号 Quotation mark# &amp;#35; — 数字标志 Number sign$ &amp;#36; — 美元标志 Dollar sign% &amp;#37; — 百分号 Percent sign&amp; &amp;#38; &amp;amp; — 与符号(&amp;) Ampersand' &amp;#39; — 单引号 Apostrophe( &amp;#40; — 小括号左边部分 Left parenthesis) &amp;#41; — 小括号右边部分 Right parenthesis* &amp;#42; — 星号 Asterisk+ &amp;#43; — 加号 Plus sign&lt; &amp;#60; &amp;lt; 小于号 Less than= &amp;#61; — 等于符号 Equals sign- &amp;#45; &amp;minus; — 减号&gt; &amp;#62; &amp;gt; — 大于号 Greater than? &amp;#63; — 问号 Question mark@ &amp;#64; — Commercial at[ &amp;#91; — 中括号左边部分 Left square bracket\\ &amp;#92; — 反斜杠 Reverse solidus (backslash)] &amp;#93; — 中括号右边部分 Right square bracket&#123; &amp;#123; — 大括号左边部分 Left curly brace| &amp;#124; — 竖线Vertical bar&#125; &amp;#125; — 大括号右边部分 Right curly brace空格 &amp;nbsp;","categories":[{"name":"Blog","slug":"Blog","permalink":"https://skyazure.top/categories/Blog/"},{"name":"Hexo","slug":"Blog/Hexo","permalink":"https://skyazure.top/categories/Blog/Hexo/"}],"tags":[{"name":"Debug","slug":"Debug","permalink":"https://skyazure.top/tags/Debug/"}]}]}