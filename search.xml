<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Manjaro安装TensorFlow2-gpu</title>
      <link href="/2020/0306/Git-checkout-dir/"/>
      <url>/2020/0306/Git-checkout-dir/</url>
      
        <content type="html"><![CDATA[<blockquote><center><font color="#1Bc3FB">push与pull过滤文件</font><center></center></center></blockquote><a id="more"></a><h1 id="push"><a href="#push" class="headerlink" title="push"></a>push</h1><p>使用”<a href="https://git-scm.com/docs/gitignore" target="_blank" rel="noopener">.gitignore</a>“文件在<code>git push</code>时过滤本地库中文件/文件夹</p><p>● 在本地根目录创建.gitignore</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim .gitignore</span><br><span class="line"><span class="comment">#或</span></span><br><span class="line">touch .gitignore</span><br></pre></td></tr></table></figure><p>● 常用的规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/abc/ 过滤整个文件夹</span><br><span class="line">*.zip 过滤所有.zip文件</span><br><span class="line">/abc/do.c 过滤某个具体文件</span><br><span class="line"></span><br><span class="line">!src/   不过滤该文件夹</span><br><span class="line">!*.zip   不过滤所有.zip文件</span><br><span class="line">!/mtk/do.c 不过滤该文件</span><br></pre></td></tr></table></figure><p>● 语法</p><p>以斜杠<code>/</code>开头表示目录；<br>以星号<code>*</code>通配多个字符；<br>以问号<code>?</code>通配单个字符<br>以方括号<code>[]</code>包含单个字符的匹配列表；<br>以叹号<code>!</code>表示不忽略(跟踪)匹配到的文件或目录；</p><blockquote><p>git 对于 .gitignore配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效</p></blockquote><h1 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h1><p>使用”<a href="https://git-scm.com/docs/git-sparse-checkout" target="_blank" rel="noopener">sparse-checkout</a>“文件在<code>git pull</code>时过滤远程库中文件/文件夹</p><p>● 在<code>$repo/.git/info/</code>创建.gitignore</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git sparse-checkout init</span><br><span class="line"><span class="comment"># 默认情况下，运行此命令会包含</span></span><br><span class="line">/* </span><br><span class="line">！/*/</span><br><span class="line"><span class="comment"># include everything in root, but nothing two levels below root</span></span><br></pre></td></tr></table></figure><p>● 常用的规则和语法</p><p>​    与.gitignore相同</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Manjaro安装TensorFlow2-gpu</title>
      <link href="/2020/0306/Manjaro-TensorFlow2-install/"/>
      <url>/2020/0306/Manjaro-TensorFlow2-install/</url>
      
        <content type="html"><![CDATA[<blockquote><center><font color="#1Bc3FB">三种方法安装Tensorflow2-gpu</font><center></center></center></blockquote><a id="more"></a><h1 id="安装Miniconda"><a href="#安装Miniconda" class="headerlink" title="安装Miniconda"></a>安装Miniconda</h1><ol><li><p>yay安装</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yay -Sy miniconda3</span><br></pre></td></tr></table></figure><p>手动安装</p><p>下载<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/" target="_blank" rel="noopener">Miniconda清华源</a></p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh <span class="variable">$PATH</span>/Miniconda3-latest-Linux-x86.sh</span><br><span class="line"><span class="comment">#Yes接受协议</span></span><br><span class="line"><span class="comment">#Yes自动配置conda</span></span><br><span class="line"><span class="comment">#若终端使用zsh，需要复制~/bashrc末尾的配置路径字段至~/zshrc</span></span><br></pre></td></tr></table></figure></li><li><p>终端界面出现（base）字样</p><img src="https://cdn.jsdelivr.net/gh/SkyAzure/ImgHosting@master/Azure-Img/article/20200306192024.png"><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate <span class="comment">#退出当前环境</span></span><br><span class="line"><span class="comment">#或者关闭自动进入环境</span></span><br><span class="line"><span class="comment">#安装conda后，每次启动终端，都会自动启动conda的base环境，conda的环境可以用 conda env list 查看，只要设置conda不要自动启动base环境就可以了。</span></span><br><span class="line">conda config --<span class="built_in">set</span> auto_activate_base <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="安装TensorFlow2-1-0-gpu"><a href="#安装TensorFlow2-1-0-gpu" class="headerlink" title="安装TensorFlow2.1.0-gpu"></a>安装TensorFlow2.1.0-gpu</h1><p>本机为intel和nvidia双显卡，Manjaro装机时驱动安装选择为non-free</p><p><img src="https://cdn.jsdelivr.net/gh/SkyAzure/ImgHosting/Azure-Img/article/20200306200803.png" alt></p><blockquote><p>特别注意：使用（混合驱动程序）video-hybrid-intel-nvidia-418xx-bumblebee驱动程序，INTEL将成为活动的主显示芯片（2d），<strong>nvidia芯片仅保留用于3d，并且只能在optirun中启动</strong>。</p><p>安装混合版本驱动，务必注意需要使用<code>optirun</code>来运行python程序，</p><p><code>optirun demo.py</code></p><p><code>optirun jupyter notebook</code></p></blockquote><p>Manjaro等Linux的显卡管理不像Windows那样简单易用，修改显卡驱动请谨慎操作，其可能导致启动问题。更多相关内容可以参考文末。</p><h2 id="●-方法一-推荐-：conda-and-conda"><a href="#●-方法一-推荐-：conda-and-conda" class="headerlink" title="● 方法一(推荐)：conda and conda"></a>● 方法一(推荐)：conda and conda</h2><p>​    使用conda创建虚拟环境，并使用conda安装tensorflow-gpu</p><p><img src="https://cdn.jsdelivr.net/gh/SkyAzure/ImgHosting@master/Azure-Img/article/20200306192129.png" alt></p><h2 id="●-方法二：conda-and-pip"><a href="#●-方法二：conda-and-pip" class="headerlink" title="● 方法二：conda and pip"></a>● 方法二：conda and pip</h2><p>​    1. 使用conda创建虚拟环境，激活环境，使用pip安装tensorflow-gpu</p><p><img src="https://cdn.jsdelivr.net/gh/SkyAzure/ImgHosting@master/Azure-Img/article/20200306194506.png" alt></p><ol start="2"><li>GPU版需要安装cudnn、cudatoolkit</li></ol><p><img src="https://cdn.jsdelivr.net/gh/SkyAzure/ImgHosting@master/Azure-Img/article/20200306194029.png" alt></p><p>若运行demo报错请参考<a href="https://github.com/tensorflow/tensorflow/issues/35968" target="_blank" rel="noopener">issues35968</a>   <a href="https://github.com/tensorflow/tensorflow/issues/34329" target="_blank" rel="noopener">issues34329</a></p><h2 id="●-方法三：pacman"><a href="#●-方法三：pacman" class="headerlink" title="● 方法三：pacman"></a>● 方法三：pacman</h2><p>​    使用pacman(Manjaro)安装tensorflow-gpu<img src="https://cdn.jsdelivr.net/gh/SkyAzure/ImgHosting@master/Azure-Img/article/20200306192423.png" alt></p><p>​    可参考<a href="https://medium.com/@Soroush/installing-tensorflow-and-cuda-on-manjaro-linux-6cb64c5ece1e" target="_blank" rel="noopener">Installing Tensorflow and CUDA on Manjaro</a></p><p><strong>验证demo.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">version = tf.__version__</span><br><span class="line">gpu_ok = tf.config.list_physical_devices(<span class="string">'GPU'</span>)</span><br><span class="line">print(<span class="string">"tf version"</span>,version,<span class="string">"\nuse GPU"</span>,gpu_ok)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;tf version <span class="number">2.1</span><span class="number">.0</span> </span><br><span class="line">&gt;&gt;&gt;use GPU [PhysicalDevice(name=<span class="string">'/physical_device:GPU:0'</span>, device_type=<span class="string">'GPU'</span>)]</span><br></pre></td></tr></table></figure><blockquote><p>附Manjaro NVIDIA配置相关链接</p></blockquote><p><a href="https://wiki.manjaro.org/index.php?title=Configure_NVIDIA_(non-free)_settings_and_load_them_on_Startup" target="_blank" rel="noopener">Configure NVIDIA(non-free)</a>  </p><p><a href="https://forum.manjaro.org/t/nvidia-drivers-are-not-loaded/81909" target="_blank" rel="noopener">NVIDIA drivers are not loaded</a></p><p><a href="https://wiki.archlinux.org/index.php/NVIDIA_Optimus" target="_blank" rel="noopener">NVIDIA Optimus</a></p><p><a href="https://wiki.archlinux.org/index.php/Nvidia-xrun" target="_blank" rel="noopener">Nvidia-xrun</a></p><p><a href="https://wiki.archlinux.org/index.php/PRIME" target="_blank" rel="noopener">PRIME</a></p><p><a href="https://wiki.archlinux.org/index.php/Bumblebee_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">Bunblebee</a></p>]]></content>
      
      
      <categories>
          
          <category> DL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Manjaro </tag>
            
            <tag> TensorFlow2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Conda使用指南</title>
      <link href="/2020/0305/Conda-Env-guide/"/>
      <url>/2020/0305/Conda-Env-guide/</url>
      
        <content type="html"><![CDATA[<blockquote><center><font color="#1Bc3FB">Conda环境管理</font><center></center></center></blockquote><a id="more"></a><h1 id="Conda基础配置"><a href="#Conda基础配置" class="headerlink" title="Conda基础配置"></a>Conda基础配置</h1><blockquote><p>Windows用户请打开“Anaconda Prompt”；macOS和Linux用户请打开“Terminal”（“终端”）进行操作</p></blockquote><ol><li><p><a href="https://mirror.tuna.tsinghua.edu.cn/help/anaconda/" target="_blank" rel="noopener">添加清华镜像</a></p></li><li><p>验证conda已被安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda --version</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;conda 4.8.2</span></span><br></pre></td></tr></table></figure></li><li><p>管理包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">conda install package_name <span class="comment">#安装包</span></span><br><span class="line">conda remove package_name  <span class="comment">#卸载包</span></span><br><span class="line">conda update package_name  <span class="comment">#更新包</span></span><br><span class="line">conda update conda         <span class="comment">#更新Conda</span></span><br><span class="line">conda list                 <span class="comment">#列出已安装包</span></span><br><span class="line">conda clean -a             <span class="comment">#删除索引缓存，锁定文件，未使用的缓存程序包和tarball</span></span><br><span class="line">conda clean -l             <span class="comment">#删除所有conda锁定文件</span></span><br><span class="line">conda clean -p             <span class="comment">#从可写程序包缓存中删除未使用的程序包。警告：这不会检查使用符号链接返回到程序包缓存安装的程序包</span></span><br><span class="line">conda clean -t             <span class="comment">#删除缓存的软件包tarball</span></span><br><span class="line">conda clean -i             <span class="comment">#清除索引缓存，保证用的是镜像站提供的索引</span></span><br></pre></td></tr></table></figure></li><li><p>常用命令</p><ul><li><p>clean         Remove unused packages and caches.删除未使用的程序包和缓存。</p></li><li><p>create       Create a new conda environment from a list of specified packages.从指定软件包列表中创建一个新的conda环境。</p></li><li><p>help          Displays a list of available conda commands and their help strings.显示可用的conda命令及其帮助字符串的列表。</p></li><li><p>install       Installs a list of packages into a specified conda environment. 将软件包列表安装到指定的conda环境中。</p></li><li><p>uninstall  Alias for conda remove.  conda remove的别名。</p></li><li><p>list            List linked packages in a conda environment.列出conda环境中的链接包。</p></li><li><p>remove   Remove a list of packages from a specified conda environment.从指定的conda环境中删除软件包列表。</p></li><li><p>run          Run an executable in a conda environment. [Experimental]在conda环境中运行可执行文件。 [实验]</p></li><li><p>search    Search for packages and display associated information. The input is a MatchSpec, a query language for conda packages.See examples below.搜索软件包并显示相关信息。输入是MatchSpec，这是conda软件包的查询语言。请参见下面的示例。</p></li><li><p>config    Modify configuration values in .condarc. This is modeled after the git config command. Writes to the user .condarc file (C:\Users\Azure.condarc) by default.修改.condarc中的配置值。这是在git config命令之后建模的。默认情况下写入用户.condarc文件(C:\Users \Azure\ .condarc)</p></li><li><p>info        Display information about current conda install. 显示有关当前conda安装的信息。</p></li><li><p>package  Low-level conda package utility. (EXPERIMENTAL) 低级conda软件包实用程序。（实验性）</p></li></ul></li><li><p>卸载conda</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~/anaconda3</span><br></pre></td></tr></table></figure></li></ol><h1 id="Conda管理环境"><a href="#Conda管理环境" class="headerlink" title="Conda管理环境"></a>Conda管理环境</h1><p>创建 Conda 环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n $NAME_OF_ENV python=3.6</span><br></pre></td></tr></table></figure><blockquote><p>由于 Conda 管理不同版本的 Python，是把 Python 视为包进行管理的，所以这里指定 Python 版本，相当于指定了初始化 Conda 环境的包</p></blockquote><p>查看 Conda 环境列表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure><p>激活 Conda 环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate $ENV_NAME</span><br></pre></td></tr></table></figure><p>退出当前环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><p>返回默认环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate</span><br></pre></td></tr></table></figure><p>分享环境：将当前环境信息生成YAML文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env export &gt; environment.yaml</span><br></pre></td></tr></table></figure><p>删除 Conda 环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env remove -n $ENV_NAME</span><br></pre></td></tr></table></figure><p>删除Conda环境及其安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove --name $ENV_NAME --all</span><br></pre></td></tr></table></figure><blockquote><p>参考文章</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/32925500" target="_blank" rel="noopener">Anaconda介绍、安装及使用教程</a>（By 豆豆）</p><p><a href="https://blog.csdn.net/sigmarising/article/details/89446397" target="_blank" rel="noopener">Conda环境的正确使用姿势</a>（By sigmarising）</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Conda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术书籍汇总</title>
      <link href="/2020/0302/code-book-update/"/>
      <url>/2020/0302/code-book-update/</url>
      
        <content type="html"><![CDATA[<blockquote><center><font color="#1Bc3FB">热爱生活 ● 热爱阅读</font><center></center></center></blockquote><a id="more"></a><blockquote><p>阅读方法论</p><p><strong>一.速读一遍（最好在1~2天内完成）</strong></p><p>人的大脑记忆力有限，在一天内快速看完一本书会在大脑里留下深刻印象，对于之后复习以及总结都会有特别好的作用。<br>对于每一章的知识，先阅读标题，弄懂大概讲的是什么主题，再去快速看一遍，不懂也没有关系，但是一定要在不懂的地方做个记号，什么记号无所谓，但是要让自己后面再看的时候有个提醒的作用，看看第二次看有没有懂了些。</p><p><strong>二.精读一遍（在2周内看完）</strong></p><p>有了前面速读的感觉，第二次看会有慢慢深刻了思想和意识的作用，具体为什么不要问我，去问30年后的神经大脑专家，现在人类可能还没有总结出为什么大脑对记忆的完全方法论，但是，就像我们专业程序员，打代码都是先实践，然后就渐渐懂了过程，慢慢懂了原理，所以第二遍读的时候稍微慢下来，2周内搞定。记住一句话：没看完一个章节后，总结一下这个章节讲了啥。很关键。</p><p><strong>三.实践（在整个过程中都要）</strong></p><p>实践的时候，要注意不用都去实践，最好看着书，敲下代码，把重点的内容敲一遍有个肌肉记忆就很不错了。<br>以及到自己做过的项目中去把每个有涉及的原理的代码，研究一遍，就可以了</p></blockquote><h1 id="语言类"><a href="#语言类" class="headerlink" title="语言类"></a>语言类</h1><ol><li><p>C语言</p><ul><li>《C primer plus》（入门首选）</li><li>《C语言程序设计：现代方法》（第2版）</li><li>《C和指针》</li><li>《C专家编程》</li><li>《C陷阱与缺陷》</li></ul></li><li><p>C++</p><ul><li>《Essential C++》</li><li>《C++ primer plus》（第六版）</li><li>《Effeetive C++》</li><li>《More Effeetive C++》</li><li>《C++标准程序库》</li><li>《STL源码剖析》</li><li>《深度探索C++对象模型》</li></ul></li><li><p>Python</p><ul><li>《Python编程：从入门到实践》</li><li>《Python3网络爬虫开发实战》</li></ul></li></ol><h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><ul><li>《数据结构与算法分析C++语言描述》</li><li>《数据结构与算法分析C语言描述》</li><li>《大话数据结构》</li><li>MOOC《数据结构》浙江大学</li><li>《啊哈！算法哈磊》</li><li>《算法竞赛入门经典》（第2版）</li><li>《算法》（第四版）</li><li><a href="https://github.com/gatieme/CodingInterviews" target="_blank" rel="noopener">剑指Offer</a></li><li>LeetCode</li></ul><h1 id="操作系统与组成原理"><a href="#操作系统与组成原理" class="headerlink" title="操作系统与组成原理"></a>操作系统与组成原理</h1><ul><li>深入理解计算机系统（第三版）</li><li>计算机组成与设计 硬件软件接口（第5版）</li></ul><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><ul><li>《TCP/IP详解》</li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul><li>《大话设计模式》</li></ul><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><ul><li><p>《鸟哥的Linux私房菜 基础学习篇 第四版》</p></li><li><p>《Linux命令行与shell脚本编程大全》</p></li><li><p>《Linux就该这么学》</p></li><li><p>《UNIX环境高级编程》</p></li><li><p>《UNIX网络编程》</p></li><li><p>《深入Linux内核架构》</p></li><li><p>《深入理解LINUX内核》</p></li><li><p>《Linux高性能服务器编程》</p></li><li><p>《POSIX多线程程序设计》</p></li></ul><h1 id="嵌入式"><a href="#嵌入式" class="headerlink" title="嵌入式"></a>嵌入式</h1><ul><li>gcc/makefile/cmake</li><li>《跟我一起学Makefile》</li><li>《debugging with gdb》</li></ul><h1 id="深度学习与计算机视觉"><a href="#深度学习与计算机视觉" class="headerlink" title="深度学习与计算机视觉"></a>深度学习与计算机视觉</h1><ul><li><p>《深度学习入门之PyTorch》</p></li><li><p><a href="https://github.com/ShusenTang/Dive-into-DL-PyTorch" target="_blank" rel="noopener">《动手学深度学习PyTorch版》</a></p></li><li><p><a href="https://nndl.github.io" target="_blank" rel="noopener">《神经网络与深度学习》</a></p></li><li><p><a href="https://github.com/czy36mengfei/tensorflow2_tutorials_chinese" target="_blank" rel="noopener">TensorFlow2_tutorials_chinese</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改Hexo文章链接格式</title>
      <link href="/2020/0218/set-post-format/"/>
      <url>/2020/0218/set-post-format/</url>
      
        <content type="html"><![CDATA[<blockquote><p>优化Hexo文章链接格式，使之既不出现中文又便于管理</p></blockquote><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>今天给博客配置Gitalk评论插件，配置完成后出现401报错，初始化创建失败，提示<code>Error: Validation Failed.</code>搜索后发现很多博主出现此现象，详见<a href="https://github.com/gitalk/gitalk/issues/115" target="_blank" rel="noopener">issues#115</a></p><p>由此引发了我对Hexo文章链接格式的关注，我之前所用的合适类似<code>skyazure.top/2020/02/05/Manjaro配置命令/</code>Gitalk的使用是将文章名称经URL编码后添加到issues的label里，但是<strong>label的长度上限是50个字符</strong>，所以文章名有些长的(尤其是<strong>中文名称编码后会较长</strong>)都会生成label失败，也就没法评论了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://skyazure.top/2020/02/05/Manjaro配置命令/</span><br><span class="line"><span class="comment"># 转码后变为</span></span><br><span class="line">https://skyazure.top/2020/02/05/Manjaro%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4/</span><br></pre></td></tr></table></figure><h1 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h1><p>首先 <code>_config.yml</code> 是 Hexo 的配置文件，在其中找到 <code>permalink</code>，我们发现文章的链接是按照 <code>年/月/日/标题</code>排列的。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">变量</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">:year</td><td align="center">文章的发表年份（4 位数）</td></tr><tr><td align="center">:month</td><td align="center">文章的发表月份（2 位数）</td></tr><tr><td align="center">:i_month</td><td align="center">文章的发表月份（去掉开头的零）</td></tr><tr><td align="center">:day</td><td align="center">文章的发表日期 (2 位数)</td></tr><tr><td align="center">:i_day</td><td align="center">文章的发表日期（去掉开头的零）</td></tr><tr><td align="center">:title</td><td align="center">文件名称</td></tr><tr><td align="center">:post_title</td><td align="center">文章标题</td></tr><tr><td align="center">:id</td><td align="center">文章 ID</td></tr><tr><td align="center">:category</td><td align="center">分类。如果文章没有分类，则是 default_category 配置信息</td></tr></tbody></table><p>按照默认设置，如果想规避链接中出现中文，文件名称应该设置成英文，但是这样很不方便本地查找文章。解决办法是</p><ol><li><p>打开吧<code>博客根目录/scaffolds/post.md</code>增加<code>urlname</code>字段</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">urlname: </span><br><span class="line">categories: </span><br><span class="line">tags:</span><br></pre></td></tr></table></figure><blockquote><p>这样每次在<code>hexo n &quot;title&quot;</code>时会在<strong>Front-matter</strong>中增加<code>urlname</code></p></blockquote></li><li><p>其次，再把<code>博客根目录/_config.yml</code> 的 <code>permalink</code>修改一下，此处修改为 <code>分类/urlname</code>：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:category/:urlname/</span></span><br></pre></td></tr></table></figure></li></ol><p>这样即使文章title为<code>修改Hexo文章链接格式</code>，但只要设置了<code>urlname: set-post-format</code>和<code>categories: -Blog -Hexo</code>那么生成的网页链接也会显示为</p><blockquote><p><a href="https://skyazure.top/Blog/Hexo/set-post-format/">https://skyazure.top/Blog/Hexo/set-post-format/</a></p></blockquote><p>如果标签中含有中文可以使用</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:year:month:day/:urlname/</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://skyazure.top/20200218/set-post-format/">https://skyazure.top/20200218/set-post-format/</a></p></blockquote><p>我要去修改之前的文章了 GG</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10和Manjaro双系统记录</title>
      <link href="/2020/0213/Win10-Manjaro-install/"/>
      <url>/2020/0213/Win10-Manjaro-install/</url>
      
        <content type="html"><![CDATA[<blockquote><p>疫情不能出门那就折腾win10和manjaro双系统吧！</p></blockquote><a id="more"></a><h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><ol><li><p>硬件信息</p><ul><li>UEFI+GPT 的架构</li><li>128G SSD(已装win10) + 1T HDD</li></ul></li><li><p>启动相关设置并分配空间</p><ul><li><p>禁用快速启动</p><p><strong>电源选项 &gt; 选择电源按钮的功能 &gt; 更改当前不可用的设置 &gt; 关机设置 &gt; [取消勾选] 启用快速启动 &gt; 保存修改</strong></p></li><li><p>禁用安全启动(Secure Boot)</p><p>如果你想在 Win 10 的电脑上双引导 Linux ，安全机制会阻止这样做。所以需要禁用 UEFI 安全引导，以支持 Linux 的双系统启动。<strong>进入bios中将安全启动关闭</strong></p></li><li><p>为Linux从HDD中划分80G未分配空间</p></li></ul></li></ol><fancybox>![](https://cdn.jsdelivr.net/gh/SkyAzure/ImgHosting/Azure-Img/article/20200213150126.png)</fancybox><ol start="3"><li><p>准备操作系</p><p>因为我的win10驱动出了问题，直接重装</p><ul><li><p>Win10：<code>LTSC 1909</code> <a href="https://onedrive.gimhoy.com/sharepoint/aHR0cHM6Ly9ob25va2EtbXkuc2hhcmVwb2ludC5jb20vOnU6L2cvcGVyc29uYWwvd2hhdGtfbGlseV9iZWVyL0VSVVZLdTdZdndST3Fod2ppbzQySE1NQlR5MVkybHZicWg0dlZTVVYxZDlmNnc/ZT1SYzd6MHQ=.esd" target="_blank" rel="noopener">OneDrive镜像</a> <a href="https://pan.baidu.com/s/1pLLL8oV#list/path=%2Fsharelink489539769-996643631769950%2FWindsys%20Win10%2FHHJLKK_191220" target="_blank" rel="noopener">百度网盘镜像</a></p></li><li><p>Linux：<code>Manjaro KDE Plasma 18.1.5</code> <a href="https://manjaro.org/download/official/kde/" target="_blank" rel="noopener">官方镜像</a></p></li></ul><p>win系统推荐镜像下载地址：<a href="https://windsys.whatk.me/" target="_blank" rel="noopener">Windsys</a>大量精简优化版本可供下载</p></li></ol><h1 id="二、安装系统"><a href="#二、安装系统" class="headerlink" title="二、安装系统"></a>二、安装系统</h1><ol><li>Windows10安装<ul><li>制作PE系统(这里推荐<a href="http://www.wepe.com.cn/" target="_blank" rel="noopener">微PE</a>)到U盘</li><li>U盘启动进入PE，使用PG格式化C盘</li><li>打开Winouws安装器，选择镜像文件，选择安装驱动器盘为C: ,<strong>选择引导驱动器盘为EFI分区盘符</strong>一般默认为Z:。挂载盘符随便选一个。</li><li>确定，重启即可进入系统</li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/SkyAzure/ImgHosting/Azure-Img/article/20200213153936.jpg" alt></p><ol start="2"><li><p>Manjaro安装</p><ul><li><p>使用镜像制作U盘启动盘(推荐<a href="https://rufus.ie/" target="_blank" rel="noopener">Rufus</a>、<a href="https://www.balena.io/etcher/" target="_blank" rel="noopener">Etcher</a>)</p></li><li><p>开始安装</p><p><img src="https://cdn.jsdelivr.net/gh/SkyAzure/ImgHosting/Azure-Img/article/20200213160732.png" alt></p><table><thead><tr><th align="center">CPU</th><th align="center">独显</th><th align="center">driver</th></tr></thead><tbody><tr><td align="center">Intel</td><td align="center">无</td><td align="center">free/intel</td></tr><tr><td align="center">Intel</td><td align="center">AMD</td><td align="center">free</td></tr><tr><td align="center">Intel</td><td align="center">NVDIA</td><td align="center">non free</td></tr><tr><td align="center">AMD</td><td align="center">NVDIA</td><td align="center">non free</td></tr><tr><td align="center">AMD</td><td align="center">无</td><td align="center">free</td></tr></tbody></table></li><li><p>选择手动分区，选择80G未分配空间</p></li><li><p>未分区磁盘72G，挂载点<code>根节点/</code>，文件系统<code>ext4</code></p><p>EFI分区100M，挂载点<code>/boot/efi</code>，文件系统<code>fat32</code>，<strong>内容：保留</strong></p><p>未分区磁盘8G，挂载点<code>swap</code></p><table><thead><tr><th align="center">RAM大小</th><th align="center">推荐的交换空间</th></tr></thead><tbody><tr><td align="center">&lt;=2G</td><td align="center">2倍RAM</td></tr><tr><td align="center">2G-8G</td><td align="center">=RAM</td></tr><tr><td align="center">&gt;8G</td><td align="center">8G</td></tr></tbody></table></li></ul></li></ol><h1 id="三、rEFInd管理启动引导"><a href="#三、rEFInd管理启动引导" class="headerlink" title="三、rEFInd管理启动引导"></a>三、rEFInd管理启动引导</h1><ol><li>进入manjaro，从<a href="http://www.rodsbooks.com/refind/" target="_blank" rel="noopener">官网</a>下载压缩包并解压</li><li>在解压好的文件目录打开终端，执行<code>./refind-install</code></li><li>调整refind配置文件，主题美化</li><li>调整启动顺序<ul><li>Manjaro<code>sudo efibootmgr</code></li><li>Win使用<code>BOOTICE</code></li></ul></li></ol><blockquote><p>注意事项：</p><ul><li>如果Win10大版本更新后，发现引导界面消失，直接进入Win10，这时需要替换引导文件，调整启动顺序即可</li><li>使用Linux某发行版一段时间后，如果想使用其他发行版，请务必将之前的引导文件删除</li><li>如果Manjaro更新内核后无法进入win10，这是不可以直接修复Win10引导，这会格式化EFI分区。应<a href="https://www.jianshu.com/p/5007e555ec12" target="_blank" rel="noopener">修复Windows引导</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Manjaro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Manjaro配置命令</title>
      <link href="/2020/0205/Manjaro-set-list/"/>
      <url>/2020/0205/Manjaro-set-list/</url>
      
        <content type="html"><![CDATA[<blockquote><center><font color="#1BC3FB" size="4">Manjaro初始化配置记录</font></center></blockquote><a id="more"></a><h1 id="换源并更新系统"><a href="#换源并更新系统" class="headerlink" title="换源并更新系统"></a>换源并更新系统</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syy</span><br><span class="line">sudo pacman-mirrors -i -c China -m rank</span><br><span class="line">sudo pacman -Syyu</span><br><span class="line">sudo pacman -Sy vim       # 安装vim</span><br><span class="line">sudo vim /etc/pacman.conf # 设定软件源分支</span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加</span></span><br><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel = Optional TrustedOnly</span><br><span class="line">Server =https://mirrors.ustc.edu.cn/archlinuxcn/$arch</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">sudo pacman -Syy &amp;&amp; sudo pacman -S archlinuxcn-keyring</span><br></pre></td></tr></table></figure><!--More--><h1 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h1><p>pacman -Sy  将本地的包数据库与远程的仓库进行了同步<br>pacman -Su  同步后的更新(<strong>与-Syu的差别是-Su只升级系统，-Syu除了升级系统还同步数据库</strong>）pacman -Syu 对整个系统进行更新<br>pacman -S 包名 安装包<br>pacman -Sy 包名 同步数据库后安装包<br>pacman -Sv 包名 在显示一些操作信息后执行安装<br>pacman -U 安装本地包,其扩展名为 pkg.tar.gz<br>pacman -U <a href="http://www.example.com/repo/example.pkg.tar.xz" target="_blank" rel="noopener">http://www.example.com/repo/example.pkg.tar.xz</a> 安装一个远程包（不在 pacman 配置的源里面）</p><h1 id="删除包"><a href="#删除包" class="headerlink" title="删除包"></a>删除包</h1><p>pacman -R 包名 该命令将只删除包，保留其全部已经安装的依赖关系<br>pacman -Rs 包名 在删除包的同时，删除其所有没有被其他已安装软件包使用的依赖关系<br>pacman -Rsc 包名 在删除包的同时，删除所有依赖这个软件包的程序<br>pacman -Rd 包名 在删除包时不检查依赖</p><h1 id="搜索包"><a href="#搜索包" class="headerlink" title="搜索包"></a>搜索包</h1><p>pacman -Ss 关键字：在仓库中搜索含关键字的包<br>pacman -Qs 关键字： 搜索已安装的包<br>pacman -Qi 包名：查看有关包的详尽信息<br>pacman -Ql 包名：列出该包的文件</p><p>pacman -Sw 包名：只下载包，不安装<br>pacman -Sc：清理未安装的包文件，包文件位于 /var/cache/pacman/pkg/ 目录<br>pacman -Scc：清理所有的缓存文件</p><h1 id="双系统统一时间"><a href="#双系统统一时间" class="headerlink" title="双系统统一时间"></a>双系统统一时间</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo timedatectl set-local-rtc true </span><br><span class="line"><span class="meta">#</span><span class="bash"> 统一linux和Windows时间方案，调整linux为本地时间</span></span><br></pre></td></tr></table></figure><h1 id="安装搜狗输入法"><a href="#安装搜狗输入法" class="headerlink" title="安装搜狗输入法"></a>安装搜狗输入法</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先安装中文语言包</span></span><br><span class="line">sudo pacman -Sy fcitx-im　# 默认全部安装　</span><br><span class="line">sudo pacman -Sy fcitx-configtool</span><br><span class="line">sudo pacman -Sy fcitx-sogoupinyin</span><br><span class="line">vim ~/.xprofile</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">export GTK_IM_MODULE=fcitx</span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line">export XMODIFIERS="@im=fcitx"</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">source ~/.xprofile</span><br><span class="line"><span class="meta">#</span><span class="bash">报错：sogou输入法异常！请删除～/.config/SougoPY并重启</span></span><br><span class="line"><span class="meta">#</span><span class="bash">尝试删除SouPY,SouPY.users,fcitx文件夹，依旧报错</span></span><br><span class="line">sogou-qimpanel # 报错</span><br><span class="line">sudo pacman -Sy fcitx-qt4  # 问题解决</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h1 id="安装chrome-Typora"><a href="#安装chrome-Typora" class="headerlink" title="安装chrome Typora"></a>安装chrome Typora</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Sy google-chorme</span><br><span class="line">sudo pacman -Ss Typora   # 查找Typora包</span><br><span class="line">sudo pacman -Sy Typora</span><br><span class="line"><span class="meta">#</span><span class="bash">yay -Sy depin-wine-tim</span></span><br></pre></td></tr></table></figure><h1 id="安装配置electron-ssr"><a href="#安装配置electron-ssr" class="headerlink" title="安装配置electron-ssr"></a>安装配置electron-ssr</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Ss electron-ssr</span><br><span class="line">sudo pacman -Sy electron-ssr</span><br><span class="line">sudo pacman -Ss proxychains # 全局模式无法使用请安装</span><br><span class="line">sudo pacman -Sy proxychains</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改系统设置－网络－代理－使用系统代理/使用手动配置的代理服务器</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> HTTP代理：127.0.0.1:12333</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> SOCKS代理：127.0.0.1:1080</span></span><br></pre></td></tr></table></figure><h1 id="终端美化"><a href="#终端美化" class="headerlink" title="终端美化"></a>终端美化</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sudo panman -Sy zsh # 默认已安装</span><br><span class="line">sudo vim /etc/passwd</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">修改user中/bin/bash为/bin/zsh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" # 安装oh-my-zsh</span><br><span class="line"></span><br><span class="line">sudo vim ~/.zshrc</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">export ZSH="/home/azure/.oh-my-zsh"</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"></span><br><span class="line">wget --no-check-certificate -O $ZSH_CUSTOM/themes/pi.zsh-theme https://raw.githubusercontent.com/tobyjamesthomas/pi/master/pi.zsh-theme # 下载Pi主题</span><br><span class="line"></span><br><span class="line">sudo vim ~/.zshrc</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">ZSH_THEME="pi"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启终端即可</span></span><br></pre></td></tr></table></figure><h1 id="AUR助手"><a href="#AUR助手" class="headerlink" title="AUR助手"></a>AUR助手</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Sy yay</span><br></pre></td></tr></table></figure><h1 id="配置SSH-Key到Github"><a href="#配置SSH-Key到Github" class="headerlink" title="配置SSH Key到Github"></a>配置SSH Key到Github</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~</span><br><span class="line">git config --global user.email "you@example.com"</span><br><span class="line">git config --global user.name "Your Name"</span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在github中添加～/.ssh/id_rsa.pub</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> Hi <span class="string">'user'</span> You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span></span><br></pre></td></tr></table></figure><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Sy nodejs</span><br><span class="line">sudo pacman -Sy npm</span><br><span class="line">node -v # v13.7.0</span><br><span class="line">npm -v # 6.13.6</span><br><span class="line">sudo npm或cnpm config set registry https://registry.npm.taobao.org # npm换淘宝源</span><br><span class="line">sudo npm install hexo-cli -g      </span><br><span class="line">sudo npm install hexo --save </span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure><h1 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -R $(pacman -Qdtq) # 清理系统中无用包</span><br><span class="line">sudo pacman -Scc #　清除已下载安装包</span><br><span class="line">du -t 100M /var # 查看日志垃圾</span><br><span class="line">journalctl --disk-usage # 查看日志垃圾</span><br><span class="line">sudo journalctl --vacuum-size=50M # 删除指定大小日志文件</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Manjaro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浙大数据结构笔记</title>
      <link href="/2019/1114/zju-DataStructures-notebook/"/>
      <url>/2019/1114/zju-DataStructures-notebook/</url>
      
        <content type="html"><![CDATA[<blockquote><center><font color="#1Bc3FB">Data Structures</font><center></center></center></blockquote><a id="more"></a><h1 id="●-基本概念"><a href="#●-基本概念" class="headerlink" title="● 基本概念"></a>● 基本概念</h1><h2 id="1-什么是数据结构"><a href="#1-什么是数据结构" class="headerlink" title="1  什么是数据结构"></a>1  什么是数据结构</h2><h3 id="1-1-其他定义"><a href="#1-1-其他定义" class="headerlink" title="1.1 其他定义"></a>1.1 其他定义</h3><ul><li>数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。 ——Sartaj Sahni 《数据结构、算法与应用》</li><li>数据结构是 ADT（Abstract Data Type，数据抽象类型）的物理实现。 ——Clifford A.Shaffer 《数据结构与算法分析》</li><li>数据结构（data structure）是计算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来最优效率的算法。 ——中文维基百科</li></ul><h3 id="1-2-解决问题方法的效率"><a href="#1-2-解决问题方法的效率" class="headerlink" title="1.2 解决问题方法的效率"></a>1.2 解决问题方法的效率</h3><ul><li>跟数组的组织方式有关</li><li>跟空间的利用效率有关</li><li>跟算法的巧妙程度有关</li></ul><h3 id="1-3-最终定义"><a href="#1-3-最终定义" class="headerlink" title="1.3 最终定义"></a>1.3 最终定义</h3><ul><li>数据对象在计算机中的组织方式<ul><li>逻辑结构</li><li>物理存储结构</li></ul></li><li>数据对象必定与一系列加在其上的操作相关联</li><li>完成这些操作所用的方法就是算法</li></ul><h3 id="1-4-抽象数据类型（Abstract-Data-Type）"><a href="#1-4-抽象数据类型（Abstract-Data-Type）" class="headerlink" title="1.4 抽象数据类型（Abstract Data Type）"></a>1.4 抽象数据类型（Abstract Data Type）</h3><ul><li><p>数据类型</p><ul><li>数据对象集</li><li>数据集合相关联的操作集</li></ul></li><li><p>抽象：描述数据类型的方法不依赖于具体实现</p><ul><li>与存放数据的机器无关</li><li>与数据存储的物理结构无关</li><li>与实现操作的算法和编程语言均无关</li></ul></li><li><p>只描述数据对象集和相关操作集“是什么”，并不涉及“如何做到”的问题</p></li></ul><h2 id="2-什么是算法"><a href="#2-什么是算法" class="headerlink" title="2 什么是算法"></a>2 什么是算法</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><ul><li>一个有限指令集</li><li>≥ 0 的输入</li><li>0 的输出</li><li>一定在有限步骤之后终止</li><li>每一条指令必须<ul><li>有充分明确的目标，不可以有歧义</li><li>计算机能处理范围内</li><li>描述应不依赖于任何一种计算机语言以及具体的实现手段</li></ul></li></ul><h3 id="2-2-描述算法的手段"><a href="#2-2-描述算法的手段" class="headerlink" title="2.2 描述算法的手段"></a>2.2 描述算法的手段</h3><ul><li><p>空间复杂度 S(n)</p><p>根据算法写成的程序在执行时占用存储空间的长度</p></li><li><p>时间复杂度 T(n)</p><p>根据算法写成的程序在执行时耗费的时间的长度</p></li></ul><h3 id="2-3-评价"><a href="#2-3-评价" class="headerlink" title="2.3 评价"></a>2.3 评价</h3><ul><li>在分析一般算法的效率时，常常关注</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structures </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客美化</title>
      <link href="/2019/1113/Hexo-beautify/"/>
      <url>/2019/1113/Hexo-beautify/</url>
      
        <content type="html"><![CDATA[<blockquote><center><font color="#1BC3FB" size="4">美美哒</font></center></blockquote><a id="more"></a><h1 id="【01】主题的选择"><a href="#【01】主题的选择" class="headerlink" title="【01】主题的选择"></a>【01】主题的选择</h1><p>将<del>NexT7.0</del>换为Material X</p><ol><li>下载<a href="https://github.com/xaoxuu/hexo-theme-material-x" target="_blank" rel="noopener">主题源码</a>到 <code>themes/</code> 文件夹</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/xaoxuu/hexo-theme-material-x themes/material-x</span><br></pre></td></tr></table></figure><ol start="2"><li>然后安装必要的依赖包</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S hexo-generator-search hexo-generator-json-content hexo-renderer-less</span><br></pre></td></tr></table></figure><ol start="3"><li>修改<strong>站点配置文件</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: material-x</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作技能</title>
      <link href="/2019/1019/Job-skill/"/>
      <url>/2019/1019/Job-skill/</url>
      
        <content type="html"><![CDATA[<blockquote><center><font color="#1Bc3FB">要变强 ！</font><center></center></center></blockquote><a id="more"></a><blockquote><p>嵌入式系统软件工程师-高通无线通信技术(中国)有限公司-北京</p></blockquote><ul><li><p>熟练掌握C/C++, Linux shell 编程语言，具有Python/Perl/Java/Makefile经验更佳；</p></li><li><p>熟悉Linux操作系统，驱动，内核开发。 例如以下领域，u-boot, PCIe/PCI, Ethernet, DDR, LCD,Camera, USB, and Power Management；</p></li><li><p>了解CPU架构，例如ARM，MIPS更佳；</p></li><li><p>了解机器学习更佳；</p></li><li><p>优秀的中英文沟通技巧；</p></li><li><p>快速学习能力；</p></li><li><p>基本的问题解决能力；</p></li><li><p>通信，计算机，电子等相关专业，本科及以上学历。</p></li></ul><blockquote><p>嵌入式系统工程师-阿里巴巴集团新零售技术事业群-杭州</p></blockquote><p>工作职责：</p><ul><li>参与工厂数字化改造方案中嵌入式IoT设备端的开发工作；</li><li>负责多个IoT设备系列的嵌入式端侧软件架构设计；</li><li>探索当前互联网主流框架与嵌入式IoT设备端侧架构的创新结合，如Flutter、Node.js等技术在嵌入式端侧的应用</li></ul><p>任职要求：</p><ul><li>5年以上嵌入式开发经验，精通C/C++编程语言，熟悉面向对象编程和常用的设计模式，具有良好的编码规范；</li><li>精通Node.js、Python、Lua等脚本语言，熟悉设计模式，具备架构能力；</li><li>有各类工业现场协议对接经验的优先；</li><li>沟通能力强，有较强的自我驱动力和快速学习能力。责任心强，具备良好团队合作精神；</li><li>具备极客精神，熟练使用常见数据结构，算法，熟悉队列、消息、多线程、网络编程、事件机制等技术的应用；</li><li>追求优雅的工程实现和问题解决</li></ul><p>加分项：</p><ul><li><p>精通基于linux的底层系统构建，如uboot,kernel等在不同方案上的移植、优化；</p></li><li><p>熟悉MTK/RK/TI/NXP等一家或多家主控芯片的产品化引用；</p></li><li><p>具备技术产品的设计、架构和实现能力，有强烈的进取心推进产品化实现；</p></li></ul><blockquote><p>嵌入式软件开发工程师-阿里巴巴</p></blockquote><p>岗位描述</p><ul><li><p>IoT芯片驱动、AI算法、面向领域的应用解决方案开发； </p></li><li><p>IoT芯片操作系统开发； </p></li><li><p>IoT芯片编译工具链、模拟器、调试器、IDE开发和性能优化</p></li></ul><p>岗位要求</p><ul><li>本科及以上学历，计算机、嵌入式等相关专业； </li><li>具有良好的算法基础及软件编程能力； </li><li>熟悉至少一门编程语言,ASM/C/C++/Python； </li><li>富有激情，有创新意识和能力，具有自我驱动和良好的团队合作能力； </li><li>良好的沟通和表达能力，能够主动发现并解决问题。<br>加分项： </li><li>有嵌入式系统或智能硬件开发经验； </li><li>有编译器开发经验； </li><li>熟悉Linux或RTOS操作系统内核； </li><li>熟悉一种以上物联网协议； </li><li>熟悉深度学习算法，量化算法</li></ul><blockquote><p>嵌入式软件开发工程师-天津深之蓝海洋设备科技有限公司-天津</p></blockquote><p>工作职责：</p><ul><li>STM32嵌入式软件开发。</li></ul><p>任职要求：</p><ul><li><p>本科及以上学历；</p></li><li><p>一年及以上嵌入式软件工作经验；</p></li><li><p>具有STM32嵌入式软件开发经验；</p></li><li><p>熟悉UCOSIIRTOS、FreeRTOS、RTX、RT-Thread至少一种嵌入式操作系统，具有掌握RTX、RT-Thread操作系统的优先考虑；</p></li></ul><blockquote><p>嵌入式软件工程师-科沃斯-苏州</p></blockquote><p>工作职责：</p><ul><li>参与软件系统的方案设计，负责公司机器人产品软件开发；</li><li>不同平台下软件分析规划、功能模块开发和技术难点攻关；</li><li>负责软件设计、代码编写和调试；</li><li>负责相关技术文档的编写；</li><li>负责指导助理软件工程师的开发工作，提供技术支持。</li></ul><p>任职要求：</p><ul><li>精通C/C++语言，精通数据结构，具有良好的代码编写习惯；</li><li>熟悉MCU/ARM处理器架构，熟练掌握软件编译环境和软件调试工具；</li><li>熟练各种常用硬件接口和传感器设备的驱动开发和调试，有网络通信（wifi、蓝牙、Zigbee等）相关经验；</li><li>有一定的算法学习研究、分析设计能力，对机器人技术感兴趣，具有创新思维；</li><li>有较强的分析和解决问题能力，有持续自我学习的能力和意愿，善于沟通和逻辑表达</li><li>工作积极主动，具有团队协作能力，服从领导安排。</li></ul><p>加分项：</p><ul><li><p>有FreeRTOS开发经验者优先；</p></li><li><p>有软件底层开发经验者优先。</p></li></ul><blockquote><p>机器人导航算法开发-石头科技-北京</p></blockquote><p>工作职责: </p><ul><li>负责开发机器人的行走，转向，脱困，避障等算法 </li></ul><p>职位要求： </p><ul><li><p>三年以上C++编程经验，精通常用算法和数据结构 </p></li><li><p>熟悉Linux编程和常用的调试工具 </p></li><li><p>有室内定位和运动控制开发经验的优先</p></li></ul><blockquote><p>机器人系统软件开发-石头科技-北京</p></blockquote><p>工作职责:</p><ul><li>负责开发优化机器人系统架构，系统升级和系统安全软件 </li></ul><p>职位要求:</p><ul><li><p>三年以上C++编程经验，熟悉常用算法和数据结构 </p></li><li><p>深入理解Linux操作系统，了解系统内核和文件系统 </p></li><li><p>了解常用的设计模式 </p></li></ul><blockquote><p>嵌入式系统工程师-Calmcar(天瞳威视)-天津</p></blockquote><p>工作职责：</p><ul><li>开发和优化基于DSP/ARM的视觉算法</li><li>配合硬件工程师及FPGA工程师完成相关的测试及接口定义</li><li>设计文档的整理、撰写及审核，做好转生产工作，确保产品的小批量、批量生产的顺利进行</li></ul><p>任职要求：</p><ul><li>计算机、电子通信等相关专业，具有相关项目开发3-5年经验</li><li>丰富的编程经验，C/C++ ，熟悉瑞萨、TI等平台</li><li>丰富的电子开发经验，Digital and Analog Design</li><li>熟悉DSP/ARM架构，能完成程序的移植及优化</li><li>具备较强的软件设计文档编写能力</li><li>工作认真负责，具有较强的承压能力</li><li>具有较强的沟通协调能力、学习能力以及良好的团队合作精神</li></ul><p>加分项：</p><ul><li>熟悉汽车电子，比如CAN，汽车线束</li><li>熟悉机器学习与模式识别技术</li><li>熟悉图像识别领域的常见工具，如OpenCV</li><li>熟悉CUDA</li><li>了解FMEA、Six Sigma流程</li><li>热爱汽车电子技术</li></ul><blockquote><p>高级嵌入式软件工程师(相机)-dji</p></blockquote><p>工作职责</p><ul><li>负责相机核心功能模块的设计、开发与调试；</li><li>负责新技术的调研与难题攻关；</li><li>负责产品功能、性能及稳定性等方面的调优；</li><li>负责指导新员工的开发工作。</li></ul><p>任职要求</p><ul><li>计算机、电子相关专业毕业，本科及以上学历；5年以上嵌入式软件开发经验，熟悉软件开发流程，具有较强的软件设计和开发能力；</li><li>精通C语言、数据结构，具有良好的代码编写习惯；</li><li>精通基于ARM的嵌入式软件开发和调试，精通编译工具及调试工具的使用；</li><li>精通Linux或者任意一款主流嵌入式操作系统的移植、裁剪、驱动开发和应用开发；</li><li>具有很强的独立开发能力，以及问题分析、解决能力；具有一定的硬件知识，能看懂原理图；具有良好的沟通能力和团队合作精神，具有较强的抗压能力；有相机相关开发经验者优先。</li></ul><blockquote><p>高级嵌入式软件工程师(Android系统方向) -dji</p></blockquote><p>工作职责</p><ul><li>负责Android系统ROM定制以及Android平台产品化开发；</li><li>负责系统UI裁剪和定制化开发，对Android HAL和Framework相关模块进行优化；</li><li>负责系统显示性能优化，提升产品体验；</li><li>根据公司的产品需求，开发相应的Framework服务及系统应用。</li></ul><p>任职要求</p><ul><li><p>统招本科及以上学历，计算机科学、电子工程、通信相关专业毕业；</p></li><li><p>5年以上Android系统开发经验，精通C/C++语言，熟悉Linux Kernel及驱动开发，了解Java编程；</p></li><li><p>熟悉Android系统框架，具备较强的开发、调试、性能优化能力，熟练使用Systrace、Traceview等工具；</p></li><li><p>熟悉Android系统的UI显示机制，有显示系统开发及性能调优的工作经验；</p></li><li><p>对ACodec、MediaCodec、OMX、SurfaceFlinger、HWC等有深入理解；</p></li><li><p>熟悉V4L2架构，熟悉Android系统的camera框架；</p></li><li><p>能熟练编写及阅读shell脚本，熟悉git版本管理工具，熟悉gerrit及jenkins环境者更佳；</p></li><li><p>具备丰富的Android手机产品系统开发经验者优先考虑；</p></li><li><p>能承担较大工作压力，工作认真负责，积极主动。</p></li></ul><blockquote><p>高级嵌入式软件优化工程师-dji</p></blockquote><p>工作职责</p><ul><li>感知算法在嵌入式平台上的资源消耗评估，指导算法工程师按嵌入式平台的限制优化算法；</li><li>感知算法在嵌入式处理器上的软件移植，优化，集成，调试；</li><li>感知算法硬件加速器的驱动，集成，调试。</li></ul><p>任职要求</p><ul><li><p>硕士及以上学历，5年以上相关工作经验；</p></li><li><p>精通C/C++；</p></li><li><p>精通DSP或NEON代码优化；熟悉vector C或intrinsic C编程；</p></li><li><p>熟悉cache，DMA等memory优化技能。</p></li></ul><blockquote><p>嵌入式软件架构师-dji</p></blockquote><p>工作职责</p><ul><li>收集并分析市场和产品需求，完成架构设计；</li><li>制定相关技术演进的roadmap，以及实施计划；</li><li>带领团队设计并开发复杂异构的操作系统以及多媒体系统解决方案，满足不同应用场景的需求；</li><li>设计要求高稳定性、低功耗、高性能、高安全性等的软硬件解决方案；</li><li>深入理解产品，参与产品的整个生命周期的开发过程，包括需求定义、设计、实现、测试、生产、售后等；</li><li>制定和改善软件的开发流程；</li><li>跟踪嵌入式领域最新的技术发展，对团队进行技术指导。</li></ul><p>任职要求</p><ul><li><p>EE，CE，CS或同等专业硕士及以上学位，6年以上相关开发经验，1年以上架构师经验；</p></li><li><p>深度参与至少1款产品的架构设计，对于设计简单、高复用、高扩展、高可靠、高性能、低功耗的架构有深入理解和体会；</p></li><li><p>丰富的嵌入式软件开发经验，如：操作系统（RTOS、Linux、Android）、安全、媒体链路、GPU等；</p></li><li><p>深入理解SoC架构，以及系统优化方法，如NEON、DSP、GPU等；</p></li><li><p>具有较强的开发和编程实践能力，以及良好的质量意识；</p></li><li><p>至少参与过一款产品的敏捷开发实践，如：Scrum、Kanban等；</p></li><li><p>良好的沟通协调能力，以及较好的驱动力；</p></li><li><p>良好的学习能力及团队领导力，喜欢挑战。</p></li></ul><blockquote><p>高级嵌入式软件工程师（感知）</p></blockquote><p>工作职责</p><ul><li>嵌入式软件开发流程和规范的梳理和把控；</li><li>视觉感知功能在嵌入式处理器上的方案设计、功能开发、性能分析与优化、系统级问题定位等；</li><li>RTOS在嵌入式处理器上的移植、开发、调试。</li></ul><p>任职要求</p><ul><li><p>本科及以上学历，五年以上相关工作经验；</p></li><li><p>精通C/C++；</p></li><li><p>精通至少一种嵌入式RTOS（如freeRTOS、threadx、nucleus、QNX…），有RTOS移植经验；</p></li><li><p>精通实时性、调度抢占、中断优先级、中断嵌套、优先级翻转等问题；</p></li><li><p>责任心强、有良好的合作精神、有较强的学习能力和沟通协调能力；</p></li><li><p>有图像处理或视觉感知相关工作者优先，有硬件开发调试经验者优先，有Linux编程开发经验者优先</p></li></ul><blockquote><p>高级嵌入式软件工程师（LinuxKernel方向）</p></blockquote><p>工作职责</p><ul><li>负责uboot、kernel和Android hal层的移植；</li><li>负责Linux应用、内核和设备驱动程序的开发；</li><li>负责Android APP、Framework和Native层的开发；</li><li>参与无线图传相关的业务代码的编写；</li><li>参与测试用例的制定及测试文档的编写。</li></ul><p>任职要求</p><ul><li><p>熟悉uboot、kernel和Android hal层的移植，有过不同芯片平台的移植经验；</p></li><li><p>熟悉Linux应用（多进程、多线程、网络等）、内核（内存管理、进程管理、中断、锁、文件系统等）的开发及调试方法；</p></li><li><p>熟悉Linux设备驱动的开发（USB、EMMC、HDMI、Audio等），具备定位硬件问题的能力；</p></li><li><p>熟悉Android Framework和Native层的工作原理，能对AMS/WMS/SurfaceFlinger等进行优化，具备添加新组件的能力；</p></li><li><p>熟悉Android APP层的开发，能对系统应用进行定制和优化，能开发简单的用户应用；</p></li><li><p>具备Android系统性能优化的经验，能充分发挥CPU、GPU、DDR、VPU等硬件的极限性能，提升系统流畅度和稳定性；</p></li><li><p>了解音视频编解码算法和无线通信原理（WIFI/SDR）的优先。</p></li></ul><blockquote><p>高级嵌入式软件工程师（导航）</p></blockquote><p>工作职责</p><ul><li>负责职能功能模块的设计、开发和调试；</li><li>负责产品功能、性能和稳定性等方面的优化；</li><li>负责指导组内软件同事的开发和技术深度的提高。</li></ul><p>任职要求</p><ul><li>计算机、电子相关专业毕业，本科及以上学历；5年以上嵌入式软件开发经验，熟悉软件开发流程，具有较强的软件设计和开发能力；</li><li>精通C&amp;C++语言、数据结构，具有良好的代码编写习惯；</li><li>丰富的Linux应用开发经验，有嵌入式软件架构设计相关经验优先考虑；</li><li>精通基于ARM的嵌入式软件开发和调试，精通编译工具以及调试工具的使用；</li><li>具有很强的独立开发能力，以及问题分析、解决能力；</li><li>具有良好的沟通能力和团队合作能力，具有较强的抗压能能力；有计算机视觉系统相关开发经验者优先。</li></ul><blockquote><p>嵌入式软件开发工程师（BSP）-海康威视-杭州</p></blockquote><p>工作职责：</p><ul><li>根据产品和业务需求开发嵌入式系统底层软件，设计和实现软件功能，并编写相应开发文档；</li><li>开发、测试和维护产品中各种芯片驱动软件；</li><li>对系统软件进行优化，提升系统性能、可靠性和稳定性。</li></ul><p>任职资格：</p><ul><li>本科及以上学历，计算机、电子信息、通信等相关专业，对英文技术文档有较好的阅读理解能力；</li><li>熟练使用C语言，有汇编语言或脚本语言的使用经验；</li><li>熟悉常用总线和接口协议，如I2C、SPI、UART，了解基本网络知识；</li><li>了解单片机、ARM、DSP、X86等至少一种芯片架构及组成；</li><li>了解操作系统原理，理解中断、进程、内存等基本概念，有Linux/RTOS上驱动或应用程序开发经验优先。</li></ul><blockquote><p>嵌入式软件开发工程师（算法应用）-海康威视-杭州</p></blockquote><p>工作职责：</p><p>1、负责嵌入式算法组件在嵌入式芯片上的系统集成和系统性能调优；<br>2、负责嵌入式算法组件后处理算法的开发和结合产品应用的功能开发和调优。</p><p>任职资格：</p><p>1、数学/计算机相关专业，研究生及其以上学历，2年算法开发或者偏算法应用的开发经验，有智能驾驶算法、机器人比赛等开发经验者优先；<br>2、熟悉视频/雷达/IMU/GPS等传感和定位的基本原理和应用；<br>3、了解并熟练应用FMEA/FTA者优先；<br>4、具备一定的嵌入式SOC开发经验，理解基本操作系统线程、进程任务调度，了解ISO26262功能安全；<br>5、具备较强的学习能力、良好团队合作意识和抗压性。</p><blockquote><p>智能传感算法工程师（传感器\深度感知\三维重建\VSLAM\AR\移动机器人\计算光学成像等）-海康威视-杭州</p></blockquote><p>工作职责：</p><ul><li>负责传感器、深度感知（TOF、双目、结构光等）、三维重建、VSLAM、AR、移动机器人、计算光学成像的算法或者系统的设计及开发。</li></ul><p>任职资格：</p><ul><li>硕士及以上学历，计算机、光学、电子、仪器、通信、自控、数学等相关专业；</li><li>有较好的系统思维，知识面丰富，熟悉计算机视觉、传感器、信号处理、光学设计、嵌入式、硬件等相关技术之一；</li><li>具备较强的全局观，良好的沟通与协作能力，能够系统、全面地看待及分析问题；</li><li>具备下述项目经验之一者优先：<ul><li>具备雷达、激光雷达、多传感器系统设计或算法开发经验；</li><li>具备深度感知（双目/TOF/结构光等）、三维重建、VSLAM等系统设计或算法开发经验之一；</li><li>具备AR/VR、移动机器人、计算光学（高光谱等）等系统设计或算法开发经验之一；</li><li>具备光学系统设计和开发经验；</li><li>具备DSP、ARM等软硬件系统开发优化经验。</li></ul></li></ul><blockquote><p>运动控制算法工程师</p></blockquote><p>工作职责：</p><ul><li>参与机械臂及足式机器人的控制系统的搭建； </li><li>参与总体结构方案设计，关键元器件选型等；</li><li>对机械臂或足式机器人进行运动学、动力学建模，完成误差标定、参数辨识、轨迹规划等基本功能。</li><li>负责机械臂或足式机器人算法应用的开发。</li></ul><p>任职资格：</p><ul><li>硕士及以上学历，计算机、机器人、自动化等相关专业；</li><li>具备机械臂或足式机器人运动规划算法以及算法应用开发的经验，掌握机器人运动学，动力学，轨迹规划等相关知识；</li><li>熟悉ROS系统，了解MOVEIT、Gazebo等常用相关工具，熟练使用C/C++等编程语言；</li><li>沟通表达协调能力好，能无障碍阅读英文文献；</li><li>有足式机器人相关竞赛经验者优先。</li></ul><blockquote><p>2020届C/C++软件工程师（linux、嵌入式）-大华股份-杭州</p></blockquote><p>工作职责：</p><p>你将和业界优秀的软件工程师前辈、专家一起，研发功能领先、性能卓越的产品，接触、参与到前沿技术，不断突破、快速成长，包括但不限于： </p><ul><li>负责产品软件的设计、编码、调试等工作，相关技术文档撰写；</li><li>负责产品软件研发及商用过程中的功能、性能、可靠性等问题的定位解决； </li><li>负责产品软件关键技术、前沿技术的预研和产品化，提升产品优势与核心价值，为客户提供持续领先解决方案；</li><li>探索、洞察业界技术新方向，持续创新，与前辈、技术专家技术交流、合作。</li></ul><p>任职资格：</p><ul><li>全日制本科及以上学历，计算机、电子信息、软件工程、自动化等相关专业；</li><li>热爱编程、基础扎实，熟悉C/C++语言，对操作系统原理、Linux、CPU等有一定的了解；</li><li>参加竞赛获奖者、国际期刊发表论文者、有实际项目经验者优先考虑。</li></ul><blockquote><p>嵌入式工程师-小米集团-北京</p></blockquote><p>岗位描述：</p><ul><li>负责手机各种外设驱动的开发优化工作，比如Camera、LCD、Touch、Audio、Charger、Sensor等；</li><li>负责Linux Kernel相关开发优化工作，如稳定性优化、性能优化等。</li></ul><p>任职要求：</p><ul><li><p>计算机、软件、电子、通信等相关专业本科及以上学历；</p></li><li><p>熟悉C/C++语言编程，有一定的硬件功底；</p></li><li><p>熟悉数据结构和算法，了解操作系统原理；</p></li><li><p>学习能力强，思路清晰，团队合作能力好，适应快节奏、高效率工作；</p></li><li><p>熟练读懂英文文档，并能进行英语交流；</p><p>优先条件：</p><ul><li>熟悉Linux kernel原理，有相关产品开发优化经验；</li><li>熟悉Linux驱动模型，有相关设备驱动开发经验；</li><li>参加过大学生电子设计竞赛（或同类型竞赛）并获奖者；</li><li>有嵌入式/单片机开发经验。</li></ul></li></ul><blockquote><p>嵌入式软件工程师-小米集团</p></blockquote><p>工作职责：</p><ul><li><p>负责小米智能语音产品嵌入式Linux平台搭建；</p></li><li><p>负责集成小米智能语音算法并封装SDK,提供给所有小米智能语音产品使用；</p></li><li><p>负责将小米智能语音算法移植到各嵌入式平台；</p></li></ul><p>职位要求：</p><ul><li><p>精通C/C++编程和数据结构；</p></li><li><p>熟悉嵌入式Linux系统开发和算法移植；</p></li><li><p>熟悉Linux多线程、多进程编程；</p></li><li><p>熟悉Linux/Unix下的网络编程；</p></li></ul><blockquote><p>嵌入式高级研发软件工程师</p></blockquote><p>岗位职责：</p><ul><li><p>小米智能家居IoT-WIFI平台研发工作</p></li><li><p>负责/参与IoT-WIFI平台需求分析，方案设计，功能开发，调试以及性能优化等工作 </p></li></ul><p>岗位要求：</p><ul><li><p>计算机、通信、自动化等相关专业，硕士5年以上、本科8年以上嵌入式软件开发经验 </p></li><li><p>精通802.11、Wi-Fi相关协议和TCP/IP协议，精通网络编程</p></li><li><p>精通C/C++语言，熟悉设计模式，具有良好的编程风格和文档编制习惯 </p></li><li><p>熟悉LINUX或者RTOS，精通多线程编程</p></li><li><p>熟悉网络安全和系统安全设计者优先</p></li><li><p>具备嵌入式软硬件协同能力者优先</p></li><li><p>积极主动、善于沟通、良好的团队合作意识</p></li></ul><blockquote><p>嵌入式系统工程师-美团-北京</p></blockquote><p>岗位职责</p><ul><li>承担无人车系统中底层嵌入式控制系统开发工作，侧重底层信号采集处理与控制决策、执行机控制，或域控制器开发。</li><li>在ARM或FPGA平台上，构建完备的信号采集、计算处理、执行部件实时控制系统。涉及各器件及功能模块的接口与驱动、通讯、控制算法实现与优化。</li><li>控制算法开发，涉及传感器融合、移动机器人学/车辆控制、电机控制；实现同时需要顾及响应实时性，可靠性，以及容错机制设计。</li><li>配合控制单元测试、集成测试、整车测试。</li><li>产品/技术文档。</li></ul><p>任职要求</p><ul><li><p>控制工程、电子工程、机电工程、车辆工程或其他相关专业硕士及以上学历。</p></li><li><p>熟悉ARM或FPGA，熟悉常用总线与接口技术，具备电路原理图阅读能力。</p></li><li><p>熟悉RTOS、运动控制技术；或熟悉Linux、有ROS开发经验。</p></li><li><p>有实际项目研发经历，调试经验丰富。</p></li><li><p>工作自驱动，责任心强，良好的团队合作精神。</p><p>具备以下者优先：</p><ul><li>有创新证明（获奖、论文、专利等）。</li></ul></li></ul><p>岗位亮点：</p><ul><li>较好的跨专业（机械、电子、控制系统）工作机会。</li><li>涉及车辆控制、机器人技术、无人驾驶技术。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Job </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skill </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MPU6050姿态结算</title>
      <link href="/2019/1013/Mpu6050-calculation/"/>
      <url>/2019/1013/Mpu6050-calculation/</url>
      
        <content type="html"><![CDATA[<p><strong>IMU</strong>（Inertial measurement unit），中文翻译为惯性测量单元，是一种能够测量物体三轴加速度和角速度进而解算出物体姿态的装置。一般的，一个IMU包含了三个单轴的加速度计和三个单轴的陀螺仪，加速度计检测物体在载体坐标系统独立三轴的加速度信号，而陀螺仪检测载体相对于导航坐标系的角速度信号，测量物体在三维空间中的角速度和加速度，并以此解算出物体的姿态。在导航中有着很重要的应用价值。为了提高可靠性，还可以为每个轴配备更多的传感器，例如地磁传感器。<br>MPU6050属于IMU的一种，包含了三个单轴的加速度计和三个单轴的陀螺仪。</p><ol><li><p><a href="https://www.jianshu.com/p/69dd18638b8e" target="_blank" rel="noopener">加速度计原理与姿态解算</a></p></li><li><p><a href="https://www.jianshu.com/p/3c03b7fb7b38" target="_blank" rel="noopener">陀螺仪原理与姿态解算</a></p></li><li><p><a href="https://www.jianshu.com/p/5ff8de66bcaf" target="_blank" rel="noopener">融合加速度计和陀螺仪的数据</a></p><a id="more"></a></li></ol><h1 id="需要姿态融合的原因"><a href="#需要姿态融合的原因" class="headerlink" title="需要姿态融合的原因"></a>需要姿态融合的原因</h1><p>为什么要有同时具备加速度计和陀螺仪。<br>看了上面的介绍，我们发现单单通过加速度计或者陀螺仪就能解算出物体姿态，为什么IMU要同时具备两种功能相似的仪器呢？</p><p>答案很简单：<strong>加速度计</strong>的数据不是100%准确的。有几个原因，还记加速度计测量的是惯性力，这个力可以由重力引起（理想情况只受重力影响），当也可能由设备的加速度（运动）引起。因此，就算加速度计处于一个相对比较平稳的状态，它对一般的震动和机械噪声很敏感。这就是为什么大部分的IMU系统都需要陀螺仪来使加速度计的输出更平滑。但是怎么办到这点呢？陀螺仪不受噪声影响吗？</p><p><strong>陀螺仪</strong>也会有噪声，但由于它检测的是旋转，因此对线性机械运动没那么敏感，不过陀螺仪有另外一种问题，比如漂移（当选择停止的时候电压不会回到零速率电压）并且陀螺仪是通过对旋转角度的累加进行姿态解算，所以长时间工作会有极大的误差。然而，通过计算加速度计和陀螺仪的平均值我们能得到一个相对更准确的当前设备的倾角值，这比单独使用加速度计更好。</p><p>通过上面的分析我们可以发现，<strong>加速度计短时间内精度较差，而长时间稳定性好，陀螺仪短时间内精度高，但会累计误差，只要将两者的数据进行互补，就能解算出正确的姿态。</strong></p><h1 id="姿态融合"><a href="#姿态融合" class="headerlink" title="姿态融合"></a><a href="https://www.cnblogs.com/dchipnau/p/5310088.html" target="_blank" rel="noopener">姿态融合</a></h1><p>MPU6050 是一款姿态传感器，使用它就是为了得到待测物体（如四轴、平衡小车） x、y、z 轴的倾角（俯仰角 Pitch、滚转角 Roll、偏航角 Yaw） 。我们通过 I2C 读取到 MPU6050 的六个数据（三轴加速度 AD 值、三轴角速度 AD 值）经过姿态融合后就可以得到 Pitch、Roll、Yaw 角。<br>本帖主要介绍三种姿态融合算法：</p><ul><li><p>四元数法 </p></li><li><p>一阶互补算法</p></li><li><p>卡尔曼滤波算法。</p></li></ul><ol><li><p>四元数法</p><p>关于四元数的一些概念和计算就不写上来了，我也不懂。我能告诉你的是：通过下面的算法，可以把六个数据转化成四元数（q0、q1、q2、q3），然后四元数转化成欧拉角（P、R、Y 角）。</p><p>​    虽然 MPU6050 自带的 DMP库可以直接输出四元数，减轻 STM32 的运算负担， 这里在此没有使用，因为我是用 STM32 的硬件 I2C 读取 MPU6050 数据的（<a href="http://bbs.elecfans.com/forum.php?mod=viewthread&tid=485014&page=1#pid3625735" target="_blank" rel="noopener">http://bbs.elecfans.com/forum.ph … 4&amp;page=1#pid3625735</a>）</p><p>DMP库需要对 I2C 函数进行修改，如 DMP 库中的 I2C 写：i2c_write(st.hw-&gt;addr, st.reg-&gt;pwr_mgmt_1, 1, &amp;(data[0]))；有4个输入变量，而 STM32 硬件 I2C 的 I2C 写为：void MPU6050_I2C_ByteWrite(u8 slaveAddr, u8 pBuffer, u8 writeAddr)，只有 3 个输入量（这之间的差异好像是由于 MPU6050 的 DMP 库是针对 MSP430 <a href="http://bbs.elecfans.com/zhuti_mcu_1.html" target="_blank" rel="noopener">单片机</a>写的），所以必须进行修改，但是改固件库是一件很痛苦的事，你们应该都懂。当然，如果你用模拟 I2C 的话，是容易实现的，网上的 DMP 移植几乎都是基于模拟 I2C 的。</p><p><strong>要注意的的是，四元数算法输出的是三个量 Pitch、Roll 和 Yaw，运算量很大。而像平衡小车这样的例子只需要一个角（Pitch 或 Roll ）就可以满足工作要求，个人觉得做平衡小车最好不用四元数法。</strong></p></li><li><p>一阶互补算法</p><p>MPU6050 可以输出三轴的加速度和角速度。通过加速度和角速度都可以得到 Pitch 和 Roll 角（<strong><em>加速度不能得到 Yaw 角</em></strong>），就是说有两组 Pitch、Roll 角，到底应该选哪组呢？别急，先分析一下。<strong>MPU6050 的加速度计和陀螺仪各有优缺点</strong>，三轴的加速度值没有累积误差，且通过算 tan() 可以得到倾角，但是它包含的噪声太多（因为待测物运动时会产生加速度，电机运行时振动会产生加速度等），不能直接使用；陀螺仪对外界振动影响小，精度高，通过对角速度积分可以得到倾角，但是会产生累积误差。所以，不能单独使用 MPU6050 的加速度计或陀螺仪来得到倾角，需要互补。一阶互补算法的思想就是给加速度和陀螺仪不同的权值，把它们结合到一起，进行修正。得到 Pitch 角的程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一阶互补滤波</span></span><br><span class="line"><span class="keyword">float</span> K1 =<span class="number">0.1</span>; <span class="comment">// 对加速度计取值的权重</span></span><br><span class="line"><span class="keyword">float</span> dt=<span class="number">0.001</span>;<span class="comment">//注意：dt的取值为滤波器采样时间</span></span><br><span class="line"><span class="keyword">float</span> angle_P,angle_R;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//angle_ax=atan(ax/az)*57.3;     //加速度得到的角度</span></span><br><span class="line"><span class="comment">//gy=(float)gyo[1]/7510.0;       //陀螺仪得到的角速度</span></span><br><span class="line">Pitch = yijiehubu_P(angle_ax,gy);</span><br><span class="line">Roll = yijiehubu_R(angle_ax,gy);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">yijiehubu_P</span><span class="params">(<span class="keyword">float</span> angle_m, <span class="keyword">float</span> gyro_m)</span><span class="comment">//采集后计算的角度和角加速度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     angle_P = K1 * angle_m + (<span class="number">1</span>-K1) * (angle_P + gyro_m * dt);</span><br><span class="line">         <span class="keyword">return</span> angle_P;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">yijiehubu_R</span><span class="params">(<span class="keyword">float</span> angle_m, <span class="keyword">float</span> gyro_m)</span><span class="comment">//采集后计算的角度和角加速度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     angle_R = K1 * angle_m + (<span class="number">1</span>-K1) * (angle_R + gyro_m * dt);</span><br><span class="line">         <span class="keyword">return</span> angle_R;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>互补算法只能得到一个倾角，这在平衡车项目中够用了，而在四轴飞行器设计中还需要 Roll 和 Yaw，就需要两个 互补算法。<strong>单靠 MPU6050 无法准确得到 Yaw 角，需要和地磁传感器结合使用。</strong></p></li><li><p>卡尔曼滤波</p><p>其实卡尔曼滤波和一阶互补有些相似，输入也是一样的。在此给出具体程序，和一阶互补算法一样，每次卡尔曼滤波只能得到一个方向的角度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f10x.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Kalman_Filter.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//卡尔曼滤波参数与函数</span></span><br><span class="line"><span class="keyword">float</span> dt=<span class="number">0.001</span>;<span class="comment">//注意：dt的取值为kalman滤波器采样时间</span></span><br><span class="line"><span class="keyword">float</span> angle, angle_dot;<span class="comment">//角度和角速度</span></span><br><span class="line"><span class="keyword">float</span> P[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123; <span class="number">1</span>, <span class="number">0</span> &#125;,</span><br><span class="line">                 &#123; <span class="number">0</span>, <span class="number">1</span> &#125;&#125;;</span><br><span class="line"><span class="keyword">float</span> Pdot[<span class="number">4</span>] =&#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">float</span> Q_angle=<span class="number">0.001</span>, Q_gyro=<span class="number">0.005</span>; <span class="comment">//角度数据置信度,角速度数据置信度</span></span><br><span class="line"><span class="keyword">float</span> R_angle=<span class="number">0.5</span> ,C_0 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">float</span> q_bias, angle_err, PCt_0, PCt_1, E, K_0, K_1, t_0, t_1;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//卡尔曼滤波</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Kalman_Filter</span><span class="params">(<span class="keyword">float</span> angle_m, <span class="keyword">float</span> gyro_m)</span><span class="comment">//angleAx 和 gyroGy </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        angle+=(gyro_m-q_bias) * dt;</span><br><span class="line">        angle_err = angle_m - angle;</span><br><span class="line">        Pdot[<span class="number">0</span>]=Q_angle - P[<span class="number">0</span>][<span class="number">1</span>] - P[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        Pdot[<span class="number">1</span>]=- P[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        Pdot[<span class="number">2</span>]=- P[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        Pdot[<span class="number">3</span>]=Q_gyro;</span><br><span class="line">        P[<span class="number">0</span>][<span class="number">0</span>] += Pdot[<span class="number">0</span>] * dt;</span><br><span class="line">        P[<span class="number">0</span>][<span class="number">1</span>] += Pdot[<span class="number">1</span>] * dt;</span><br><span class="line">        P[<span class="number">1</span>][<span class="number">0</span>] += Pdot[<span class="number">2</span>] * dt;</span><br><span class="line">        P[<span class="number">1</span>][<span class="number">1</span>] += Pdot[<span class="number">3</span>] * dt;</span><br><span class="line">        PCt_0 = C_0 * P[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        PCt_1 = C_0 * P[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        E = R_angle + C_0 * PCt_0;</span><br><span class="line">        K_0 = PCt_0 / E;</span><br><span class="line">        K_1 = PCt_1 / E;</span><br><span class="line">        t_0 = PCt_0;</span><br><span class="line">        t_1 = C_0 * P[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        P[<span class="number">0</span>][<span class="number">0</span>] -= K_0 * t_0;</span><br><span class="line">        P[<span class="number">0</span>][<span class="number">1</span>] -= K_0 * t_1;</span><br><span class="line">        P[<span class="number">1</span>][<span class="number">0</span>] -= K_1 * t_0;</span><br><span class="line">        P[<span class="number">1</span>][<span class="number">1</span>] -= K_1 * t_1;</span><br><span class="line">        angle += K_0 * angle_err; <span class="comment">//最优角度</span></span><br><span class="line">        q_bias += K_1 * angle_err;</span><br><span class="line">        angle_dot = gyro_m-q_bias;<span class="comment">//最优角速度</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> angle；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>三种融合算法都能够输出姿态角（Pitch 和 Roll ），一次四元数法可以输出 P、R、Y 三个倾角，计算量比较大。一阶互补和卡尔曼滤波每次只能输出一个轴的姿态角。</p><h2 id="陀螺仪漂移的解决方法"><a href="#陀螺仪漂移的解决方法" class="headerlink" title="陀螺仪漂移的解决方法"></a>陀螺仪漂移的解决方法</h2><p>横滚角和俯仰角的偏差可以通过卡尔曼滤波或者一阶互补滤波即可消除漂移量.</p><p>但是<strong>航向角存在的偏差很难由自身来校准,</strong>这是由于:<br>Z轴在静止状态下没有漂移，运动情况下有累积误差。因为Z轴角度是通过对角速度积分计算出来的，没有观测量滤波，所以漂移是不可避免的。X、Y轴的角度是根据重力加速度分量计算，X，Y轴是有重力场滤波，所以不会有漂移。Z轴只能用短时间内的相对测量量。 就是相邻两次的角度差来计算转过的角度。</p><p>可以采用带地磁的9轴陀螺仪来降低漂移量,但是仍然无法完全解决这个问题.而且地磁计对周围磁场的变化敏感,多磁场和多电机的工作环境都会导致地磁计不准.</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IMU传感器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ sizeof函数总结</title>
      <link href="/2019/1012/C-sizeof/"/>
      <url>/2019/1012/C-sizeof/</url>
      
        <content type="html"><![CDATA[<blockquote><center><font color="#1BC3FB" size="4">解决sizeof求结构体大小的问题</font></center></blockquote><a id="more"></a><h1 id="一、C-C-中不同数据类型所占用的内存大小"><a href="#一、C-C-中不同数据类型所占用的内存大小" class="headerlink" title="一、C/C++中不同数据类型所占用的内存大小"></a>一、C/C++中不同数据类型所占用的内存大小</h1><table><thead><tr><th>数据类型</th><th>32位</th><th>64位</th></tr></thead><tbody><tr><td>char</td><td>1</td><td>1</td></tr><tr><td>int</td><td>4</td><td>大多数4(少数8)</td></tr><tr><td>short</td><td>2</td><td>2</td></tr><tr><td><em>long</em></td><td>4</td><td>8</td></tr><tr><td>float</td><td>4</td><td>4</td></tr><tr><td>double</td><td>8</td><td>8</td></tr><tr><td><em>*指针</em></td><td>4</td><td>8</td></tr></tbody></table><p>（单位都为字节） </p><p>结构体(struct)：比较复杂，对齐问题需要考虑清楚。</p><p>联合(union)：取所有成员中最长的作为联合的长度。</p><p>枚举(enum)：根据数据类型。</p><h1 id="二、sizeof计算单层结构体大小"><a href="#二、sizeof计算单层结构体大小" class="headerlink" title="二、sizeof计算单层结构体大小"></a>二、sizeof计算单层结构体大小</h1><p>运算符sizeof可以计算出给定类型的大小，<strong>对于32位系统来说</strong>，</p><p><code>sizeof(char) = 1; sizeof(int) = 4。</code></p><p>基本数据类型的大小很好计算，我们来看一下如何计算构造数据类型的大小。</p><p>C语言中的构造数据类型有三种</p><ul><li><p>数组</p></li><li><p>结构体</p></li><li><p>共用体</p></li></ul><ol><li><p><font color="#1BC3FB">数组</font>是相同类型的元素的集合，只要会计算单个元素的大小，<strong>整个数组所占空间等于基础元素大小乘上元素的个数</strong>。</p></li><li><p><font color="#1BC3FB">结构体</font>中的成员可以是不同的数据类型，成员按照定义时的顺序依次存储在连续的内存空间。和数组不一样的是，结构体的大小不是所有成员大小简单的相加，<strong>需要考虑到系统在存储结构体变量时的地址对齐问题</strong>。看下面这样的一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用sizeof求该结构体的大小，发现值为<strong>12</strong>。int占4个字节，char占1个字节，结果应该是9个字节才对啊，为什么呢？</p><p>先介绍一个相关的概念——<strong><em>偏移量</em></strong>。偏移量<strong>指的是结构体变量中成员的地址和结构体变量地址的差</strong>。<em>结构体大小**</em>等于最后一个成员的偏移量加上最后一个成员的大小**。显然，结构体变量中第一个成员的地址就是结构体变量的首地址。因此，第一个成员i的偏移量为0。第二个成员c的偏移量是第一个成员的偏移量加上第一个成员的大小（0+4）,其值为4；第三个成员j的偏移量是第二个成员的偏移量加上第二个成员的大小（4+1）,其值为5。</p><p>然而，在实际中，<strong>存储变量时地址要求对齐</strong>，编译器在编译程序时会遵循两条<strong>原则</strong>：</p><ul><li><strong>结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍）</strong></li><li><strong>结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。</strong></li></ul><p>上面的例子中前两个成员的偏移量都满足要求，但第三个成员的偏移量为5，并不是自身(int)大小的整数倍。编译器在处理时会在第二个成员后面补上3个空字节，使得第三个成员的偏移量变成8。结构体大小等于最后一个成员的偏移量加上其大小，上面的例子中计算出来的大小为12，满足要求。</p><p><strong>再来看另外一个例子：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> k;</span><br><span class="line">  <span class="keyword">short</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员k的偏移量为0；成员t的偏移量为4，都不需要调整。但计算出来的大小为6，显然不是成员k大小的整数倍。因此，编译器会在成员t后面补上2个字节，使得结构体的大小变成8从而满足第二个要求。</p><p>由此可见，结构体类型需要考虑到字节对齐的情况.</p><p><strong>不同的顺序也会影响结构体的大小</strong></p><p> 对比下面两种定义顺序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu3</span>  </span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">       <span class="keyword">char</span> c1;   </span><br><span class="line">       <span class="keyword">int</span> i;  </span><br><span class="line">       <span class="keyword">char</span> c2;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu4</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">       <span class="keyword">char</span> c1;  </span><br><span class="line">       <span class="keyword">char</span> c2;  </span><br><span class="line">       <span class="keyword">int</span> i;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>虽然结构体stu3和stu4中成员都一样，但sizeof(struct stu3)的值为12而sizeof(struct stu4)的值为8</p></li><li><p><font color="#1BC3FB">共用体</font>中的成员公用同一段内存，所以整个联合体的sizeof是所有成员中占用内存最大的成员的sizeof，联合体要考虑<em>内存对齐</em>，整<strong>体空间长度要是公用体中长度最大的数据类型的整数倍</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> st&#123;</span><br><span class="line">  <span class="keyword">char</span> a[<span class="number">9</span>];</span><br><span class="line">  <span class="keyword">int</span> b[<span class="number">2</span>];</span><br><span class="line">&#125;s</span><br></pre></td></tr></table></figure><p>结果分析：</p><p><code>sizeof(a)=9*1=9</code></p><p><code>sizeof(b)=2*4=8</code></p><p>选两者中最大的一个，即9，考虑内存对齐，整体空间长度要是公用体中长度最大的数据类型的整数倍，在这里是int占用空间的整数倍，比9大的且是4的整数倍的最小数是12</p></li></ol><p>拓展<strong>枚举类enum型空间计算</strong></p><p>enum只是定义了一个常量集合，里面没有“元素”，而枚举类型是当做int来存储的，所以枚举类型的sizeof值都为4</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">enum</span> <span class="title">color</span><span class="params">(red,pink,white,black)</span>c</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">enum</span>);   <span class="comment">//值为4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、sizeof计算嵌套的结构体大小"><a href="#三、sizeof计算嵌套的结构体大小" class="headerlink" title="三、sizeof计算嵌套的结构体大小"></a>三、sizeof计算嵌套的结构体大小</h2><p>对于<strong>嵌套的结构体</strong>，<strong>需要将其展开</strong>。对结构体求sizeof时，上述两种<strong>原则</strong>变为：</p><ul><li><p><strong>展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大的成员的整数倍。</strong></p></li><li><p><strong>结构体大小必须是所有成员大小的整数倍，这里所有成员计算的是展开后的成员，而不是将嵌套的结构体当做一个整体。</strong></p></li><li><p>被展开的结构体的规则同单结构体sizeof计算规则。</p></li></ul><p>原则1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu5</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">      <span class="keyword">short</span> i;  </span><br><span class="line">      <span class="class"><span class="keyword">struct</span>   </span></span><br><span class="line"><span class="class">      &#123;</span>  </span><br><span class="line">           <span class="keyword">char</span> c;  </span><br><span class="line">           <span class="keyword">int</span> j;  </span><br><span class="line">      &#125; ss;   </span><br><span class="line">      <span class="keyword">int</span> k;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体stu5的成员<code>ss.c</code>的偏移量应该是4，而不是2。整个结构体大小应该是16，即4+（4+4）+4，第二个4是 <code>char c</code> 的扩展(由后面<code>int j</code>导致)。</p><p>原则2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu5</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">      <span class="keyword">char</span> i;  </span><br><span class="line">      <span class="class"><span class="keyword">struct</span>   </span></span><br><span class="line"><span class="class">      &#123;</span>  </span><br><span class="line">           <span class="keyword">char</span> c;  </span><br><span class="line">           <span class="keyword">int</span> j;  </span><br><span class="line">      &#125; ss;   </span><br><span class="line">      <span class="keyword">char</span> a;  </span><br><span class="line">      <span class="keyword">char</span> b;  </span><br><span class="line">      <span class="keyword">char</span> d;  </span><br><span class="line">      <span class="keyword">char</span> e;  </span><br><span class="line">      <span class="keyword">char</span> f;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体<code>ss</code>单独计算占用空间为8，而<code>stu5</code>的sizeof则是20（<strong>由17扩展至20，而不是扩展到24）</strong>，不是8的整数倍，这说明在计算<code>sizeof(stu5)</code>时，将嵌套的结构体<code>ss</code>展开了，这样stu5中最大的成员为<code>ss.j</code>，占用4个字节，20为4的整数倍。如果将<code>ss</code>当做一个整体，结果应该是24了。</p><p><strong>另一个常见的例子：</strong></p><p>结构体中包含数组，其sizeof应当和处理嵌套结构体一样，将其展开</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ss</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">float</span> f;  </span><br><span class="line">    <span class="keyword">char</span> p;  </span><br><span class="line">    <span class="keyword">int</span> adf[<span class="number">3</span>];  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>补充另外一个涉及数据类型以及内存存储的问题</p></blockquote><p>内存中的数据并非保存在任意地址。处理器通常按照和其字大小相同的块读取内存数据；那么考虑到效率因素，<strong>编译器会按照块大小的整数倍对内存中的实体进行地址对齐</strong>。因此在 32 位的处理器上，一个 4 字节整型数据肯定<strong>存放在内存地址能被4整除的地方</strong>。 下面，假设系统中整型数据和指针大小均为 4 字节。<br>现在有一个指向整型的指针。如上所述，整型数据可以存放在内存地址 0×1000 或者 0×1004 或者 0×1008，但是决不会存放在 0×1001 或者0×1002 或者 0×1003 或者其他不能被4整除的任何地址。所有是4整数倍的二进制数都是以 00 结尾。实际上，这意味着对于所有指向整型的指针，它的最后两位总是 0。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法知识点</title>
      <link href="/2019/1011/DataStructures-knowledge-list/"/>
      <url>/2019/1011/DataStructures-knowledge-list/</url>
      
        <content type="html"><![CDATA[<blockquote><center><font color="#1Bc3FB">知识点整理</font><center></center></center></blockquote><a id="more"></a><h1 id="●-完全二叉树与满二叉树的区别"><a href="#●-完全二叉树与满二叉树的区别" class="headerlink" title="● 完全二叉树与满二叉树的区别"></a>● 完全二叉树与满二叉树的区别</h1><p><strong>满二叉树</strong>是<strong>完全二叉树</strong>的特例，因为满二叉树已经满了，而完全并不代表满。所以形态你也应该想象出来了吧，满指的是出了叶子节点外每个节点都有两个孩子，而完全的含义则是最后一层没有满，并没有满。</p><h1 id="●-已知二叉树的前序遍历和中序遍历求后续遍历"><a href="#●-已知二叉树的前序遍历和中序遍历求后续遍历" class="headerlink" title="● 已知二叉树的前序遍历和中序遍历求后续遍历"></a>● 已知二叉树的前序遍历和中序遍历求后续遍历</h1><p>现有二叉搜索树（BST）前序遍历结果序列为abdefgc，中序遍历结果序列为debgfac，请问后序遍历结果序列?</p><p>答：前序遍历结果序列为<strong>abdefgc</strong>，中序遍历结果序列为<strong>debgfac</strong><br>以此为条件，根据前序知道a是根，根据中知道debgf为左子树，c为右子树。<br>根据前知道b为左子树中的根，根据中知道de为b的左，gf为右，根据前和中判断d为根，e为右，f为根，g为左，<br>树成型，得出后序结果<strong>edgfbca</strong></p><h1 id="●-已知啊a-b-c，求系统进制"><a href="#●-已知啊a-b-c，求系统进制" class="headerlink" title="● 已知啊a * b = c，求系统进制"></a>● 已知啊a * b = c，求系统进制</h1><p>如果某系统15*4=112成立，则系统采用的是几进制？</p><p>将原式转为X进制：<br>1 5 * 4 = 1 1 2<br>（X+5）* 4 = X^2+X+2<br>解方程即可x=6</p><h1 id="●-栈"><a href="#●-栈" class="headerlink" title="● 栈"></a>● 栈</h1><ol><li><p>设栈S和队列Q的初始状态均为空，元素啊，a,b,c,d,e,f,g依次进入栈S。若每个元素出栈后立即进入推列Q，且7个元素出队的顺序是b,d,,c,f,e,a,g，则栈S的容量至少是？</p><p>栈是先进后出，队列是先进先出，所以元素出队列的顺序就是出栈的顺序。<br>出栈的顺序为b,d,c,f,e,a,g，这意味着</p><ol><li><p>a,b进入，b出；</p></li><li><p>c,d进入，此时栈中有a,d,c，出来d,c；</p></li><li><p>e,f进入， 此时栈中有a,e,f，出来f,e,a；</p></li><li><p>g进入，此时栈中有g，出来g；</p><p><strong>由此看出整个过程中栈中存在的元素最多有3个，所以栈S的容量至少是3</strong></p></li></ol></li><li><p>一个栈的入栈序列是a,b,c,d,e,f,则栈的不可能的输出序列是（）</p><p>A:fedcba     <strong>B:defbca</strong>     C:defcba     D:abcdef</p><p>A可以 全进栈 然后依次出栈<br>B不可以<br>C先进adcd 然后d出 再进e e出 再进f f出 剩下的依次cba出<br>D一个进 一个出</p></li></ol><h1 id="●-网络延迟"><a href="#●-网络延迟" class="headerlink" title="●  网络延迟"></a>●  网络延迟</h1><p>网络延迟是指在传输介质中传输所用的时间，即从报文开始进入网络到它开始离开网络之间的时间。</p><h1 id="●-完全二叉树的存储"><a href="#●-完全二叉树的存储" class="headerlink" title="● 完全二叉树的存储"></a>● 完全二叉树的存储</h1><p>完全二叉树由于其结构上的特点，通常采用顺序存储方式存储(数组)。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识点随笔</title>
      <link href="/2019/1011/job-knowledge-list/"/>
      <url>/2019/1011/job-knowledge-list/</url>
      
        <content type="html"><![CDATA[<blockquote><center><font color="#1Bc3FB">知识点整理</font><center></center></center></blockquote><a id="more"></a><h1 id="●-黑盒测试与白盒测试"><a href="#●-黑盒测试与白盒测试" class="headerlink" title="● 黑盒测试与白盒测试"></a>● 黑盒测试与白盒测试</h1><p>任何工程产品(注意是任何工程产品)都可以使用以下两种方法之一进行测试。</p><ul><li>黑盒测试：已知产品的功能设计规格，可以进行测试证明每个实现了的功能是否符合要求。 </li><li>白盒测试：已知产品的内部工作过程，可以通过测试证明每种内部操作是否符合设计规格要求，所有内部成分是否以经过检查。</li></ul><p>软件的黑盒测试意味着测试要在软件的接口处进行。这种方法是把测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。因此黑盒测试又叫功能测试或数据驱动测试。</p><p><strong>黑盒测试主要是为了发现以下几类错误：</strong></p><ul><li>是否有不正确或遗漏的功能?</li><li>在接口上，输入是否能正确的接受?能否输出正确的结果?</li><li>是否有数据结构错误或外部信息(例如数据文件)访问错误?</li><li>性能上是否能够满足要求?</li><li>是否有初始化或终止性错误?</li></ul><p>软件的白盒测试是对软件的过程性细节做细致的检查。这种方法是把测试对象看做一个打开的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。通过在不同点检查程序状态，确定实际状态是否与预期的状态一致。因此白盒测试又称为结构测试或逻辑驱动测试。</p><p><strong>白盒测试主要是想对程序模块进行如下检查：</strong></p><ul><li>对程序模块的所有独立的执行路径至少测试一遍。</li><li>对所有的逻辑判定，取“真”与取“假”的两种情况都能至少测一遍。</li><li>在循环的边界和运行的界限内执行循环体。</li><li>测试内部数据结构的有效性，等等。</li></ul><p><strong>以上事实说明</strong>，软件测试有一个致命的缺陷，即测试的不完全、不彻底性。由于任何程序只能进行少量(相对于穷举的巨大数量而言)的有限的测试，在未发现错误时，不能说明程序中没有错误。</p><blockquote><p>如果能够执行完美的黑盒测试，还需要进行白盒测试吗?</p></blockquote><p>从以上可以看出就算完美的黑盒测试也是无法测试程序内部特定部位，另外当规格说明本身有误，也不能发现问题。而白盒测试能对程序的内部特定部位进行覆盖测试，所以黑盒和白盒测试为互补关系，结合起来测试用例的设计更为合理。</p><p>经验表明，通常在进行单元测试时采用白盒测试方法，集成测试采用灰盒测试方法，系统测试采用黑盒测试方法。</p><h1 id="●-简述单工、半双工、全双工的区别"><a href="#●-简述单工、半双工、全双工的区别" class="headerlink" title="● 简述单工、半双工、全双工的区别"></a>● 简述单工、半双工、全双工的区别</h1><p>网络的领域内，单工、半双工、全双工是经常会遇见的名称，下面简单的讲述一下他们的区别。</p><ul><li><p>单工：简单的说就是一方只能发信息，另一方则只能收信息，通信是单向的。</p></li><li><p>半双工：比单工先进一点，就是双方都能发信息，但同一时间则只能一方发信息。</p></li><li><p>全双工：比半双工再先进一点，就是双方不仅都能发信息，而且能够同时发送。</p></li></ul><h1 id="●-笔试面试知识整理"><a href="#●-笔试面试知识整理" class="headerlink" title="● 笔试面试知识整理"></a>● 笔试面试知识整理</h1><p>​    <a href="https://hit-alibaba.github.io/interview/" target="_blank" rel="noopener">参考链接</a></p><h1 id="●-设计模式"><a href="#●-设计模式" class="headerlink" title="● 设计模式"></a>● 设计模式</h1><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。<br>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。<br>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>]]></content>
      
      
      <categories>
          
          <category> Job </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux及计算机网络知识点汇总</title>
      <link href="/2019/1011/Linux-net-knowledge-list/"/>
      <url>/2019/1011/Linux-net-knowledge-list/</url>
      
        <content type="html"><![CDATA[<blockquote><center><font color="#1Bc3FB">知识点整理</font><center></center></center></blockquote><a id="more"></a><h1 id="●-Linux内核五大模块"><a href="#●-Linux内核五大模块" class="headerlink" title="● Linux内核五大模块"></a>● Linux内核五大模块</h1><ul><li>进程调度模块</li><li>内存管理模块</li><li>文件系统模块</li><li>进程间通信模块</li><li>网络接口模块</li></ul><h1 id="●-死锁"><a href="#●-死锁" class="headerlink" title="● 死锁"></a>● 死锁</h1><ol><li><p>掌握死锁的概念和产生死锁的根本原因。</p></li><li><p>理解产生死锁的必要条件–以下四个条件同时具备：互斥条件、不可抢占条件、占有且申请条件、循环等待条件。</p></li><li><p>记住解决死锁的一般方法，掌握死锁的预防和死锁的避免二者的基本思想。</p></li><li><p>掌握死锁的预防策略中资源有序分配策略。</p></li><li><p>理解进程安全序列的概念，理解死锁与安全序列的关系。</p></li><li><p>了解银行家算法。</p></li><li><p>了解资源分配图。</p></li><li><p>了解死锁的检测及恢复的思想。</p><p>————————————————</p><blockquote><p>原文链接：<a href="https://blog.csdn.net/abigale1011/article/details/6450845" target="_blank" rel="noopener">https://blog.csdn.net/abigale1011/article/details/6450845</a></p></blockquote></li></ol><p>死锁产生的原因：</p><ul><li>竞争资源</li><li>进程推进顺序不当</li></ul><h1 id="●-TCP-IP协议详解"><a href="#●-TCP-IP协议详解" class="headerlink" title="● TCP/IP协议详解"></a>● TCP/IP协议详解</h1><blockquote><p><a href="https://zhuanlan.zhihu.com/p/33889997" target="_blank" rel="noopener">参考文章</a></p></blockquote><h1 id="●-最受欢迎的Linux发行版-现第2-Manjaro折腾全记录（超长超详细）"><a href="#●-最受欢迎的Linux发行版-现第2-Manjaro折腾全记录（超长超详细）" class="headerlink" title="● 最受欢迎的Linux发行版(现第2), Manjaro折腾全记录（超长超详细）"></a>● 最受欢迎的Linux发行版(现第2), Manjaro折腾全记录（超长超详细）</h1><blockquote><p><a href="https://cloud.tencent.com/developer/article/1390999" target="_blank" rel="noopener">参考文章</a></p></blockquote><h1 id="●-对于一个分布式计算系统来说3个指标不能同时完成"><a href="#●-对于一个分布式计算系统来说3个指标不能同时完成" class="headerlink" title="● 对于一个分布式计算系统来说3个指标不能同时完成"></a>● 对于一个分布式计算系统来说3个指标不能同时完成</h1><ul><li><p>一致性</p></li><li><p>可用性</p></li><li><p>分区容错性</p></li></ul><h1 id="●-OSI参考模型中各层作用"><a href="#●-OSI参考模型中各层作用" class="headerlink" title="● OSI参考模型中各层作用"></a>● OSI参考模型中各层作用</h1><p><fancybox><img src="https://cdn.jsdelivr.net/gh/SkyAzure/ImgHosting/Azure-Img/article/20200217185844.jpg"></fancybox><br>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）<br>数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br>会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）<br>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p><p>网络层：</p><ul><li>IP协议</li><li>ICMP协议</li><li>ARP协议</li><li>RARP协议。 </li></ul><p>传输层：</p><ul><li>UDP协议</li><li>TCP协议。</li></ul><p>应用层：</p><ul><li>FTP（文件传送协议）</li><li>Telenet（远程登录协议）</li><li>DNS（域名解析协议）</li><li>SMTP（邮件传送协议）</li><li>POP3协议（邮局协议）</li><li>HTTP协议</li><li>SNMP协议</li><li>TFTP</li></ul><h1 id="●-OSI七层模型和TCP-IP四层模型"><a href="#●-OSI七层模型和TCP-IP四层模型" class="headerlink" title="● OSI七层模型和TCP/IP四层模型"></a>● OSI七层模型和TCP/IP四层模型</h1><h2 id="OSI七层模型各层协议："><a href="#OSI七层模型各层协议：" class="headerlink" title="OSI七层模型各层协议："></a>OSI七层模型各层协议：</h2><ul><li><p>物理层：RJ45、CLOCK、IEEE802.3</p></li><li><p>数据链路层：PPP、FR、HDLC、VLAN、MAC</p></li><li><p>网络层：IP、IPX、OSPF、RIP、IGRP、ICMP、ARP、RARP</p></li><li><p>传输层：TCP、UDP、SPX</p></li><li><p>会话层：NFS、SQL、NETBIOS、RPC</p></li><li><p>表示层：JPEG、MPEG、ASII</p></li><li><p>应用层：Telnet、HTTP、FTP、WWW、NFS、SMTP</p></li></ul><h2 id="TCP-IP四层模型："><a href="#TCP-IP四层模型：" class="headerlink" title="TCP/IP四层模型："></a>TCP/IP四层模型：</h2><p> 一- TCP/IP四层模型名称：<br>网络接口层（Network Access）【又分为物理层（Physical）和数据链路层（Datalink）】→网络互联层（Internet）→传输层（Transport）→应用层（Application）</p><p> 二、TCP/IP四层模型各层的功能：</p><ul><li><p>网络接口层：负责实际数据的传输</p></li><li><p>网络互联层：负责网络间的寻址数据传输</p></li><li><p>传输层：负责提供可靠的传输服务</p></li><li><p>应用层：负责实现一切与应用程序相关的功能</p><p>三、TCP/IP四层模型各层的协议：</p></li><li><p>网络接口层：HDLC（高级链路控制协议）、PPP（点对点协议）、SLIP（串行线路接口协议）</p></li><li><p>网络互联层：IP（网际协议）、ICMP（网际控制消息协议）、ARP（地址解析协议）、RARP（反向地址解析协议）</p></li><li><p>传输层：TCP（控制传输协议）、UDP（用户数据报协议）</p></li><li><p>应用层：FTP（文件传输协议）、HTTP（超文本传输协议）、DNS（域名服务器协议）、SMTP（简单邮件传输协议）、NFS（网络文件系统协议）</p><p>四、OSI七层模型和TCP/IP四层模型的区别：</p></li></ul><p>OSI七层模型和TCP/IP四层模型最大的区别在于：OSI七层模型是一个理论上的网络通信模型，而TCP/IP四层模型则是实际运行的网络协议。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python知识点整理</title>
      <link href="/2019/1011/Python-knowledge-list/"/>
      <url>/2019/1011/Python-knowledge-list/</url>
      
        <content type="html"><![CDATA[<blockquote><center><font color="#1Bc3FB">知识点整理</font><center></center></center></blockquote><a id="more"></a><h1 id="●-正则表达式的贪婪与非贪婪匹配"><a href="#●-正则表达式的贪婪与非贪婪匹配" class="headerlink" title="● 正则表达式的贪婪与非贪婪匹配"></a>● 正则表达式的贪婪与非贪婪匹配</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">"abcaxc"</span>;</span><br><span class="line">Patter p=<span class="string">"ab*c"</span>;</span><br></pre></td></tr></table></figure><ul><li><p>贪婪匹配(<code>.*</code>)：正则表达式一般趋向于最大长度匹配，也就是所谓的贪婪匹配。如上面使用模式p匹配字符串str，结果就是匹配到：abcaxc(ab*c)。</p></li><li><p>非贪婪匹配(<code>.*?</code>)：就是匹配到结果就好，就少的匹配字符。如上面使用模式p匹配字符串str，结果就是匹配到：abc(ab*c)。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python str和list排序并删除重复数据</title>
      <link href="/2019/0630/Python-str-sort/"/>
      <url>/2019/0630/Python-str-sort/</url>
      
        <content type="html"><![CDATA[<blockquote><p>排序并删除重复数据</p></blockquote><a id="more"></a><h1 id="一、排序函数sort-和sorted"><a href="#一、排序函数sort-和sorted" class="headerlink" title="一、排序函数sort()和sorted()"></a>一、排序函数sort()和sorted()</h1><p>sort() 是Python列表的一个内置的排序方法，<code>list.sort()</code> 方法排序时直接修改原列表，返回None；</p><p>sorted() 是Python内置的一个排序函数，它会从一个<strong>迭代器</strong>返回一个排好序的新列表。</p><p>相比于 sort()，sorted() 使用的范围更为广泛，但是如果不需要保留原列表，sort更有效一点。另外，sort() 只是列表的一个方法，只适用于列表，而<code>sorted()</code> 函数接受一切迭代器，返回新列表。</p><p>这两个方法有以下 2 个共同的参数：</p><ul><li>key 是带一个参数的<strong>函数</strong>，返回一个值用来排序，默认为 None。这个函数只调用一次，所以fast。</li><li>reverse 表示排序结果是否反转</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>)        <span class="comment"># a 是元组，故不能用sort() 排序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.sort()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"> File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'tuple'</span> object has no attribute <span class="string">'sort'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(a)              <span class="comment"># sorted() 可以为元组排序，返回一个新有序列表</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="string">'1'</span>,<span class="number">1</span>,<span class="string">'a'</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="string">'n'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(a)</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="string">'1'</span>, <span class="string">'a'</span>, <span class="string">'n'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a                      <span class="comment"># sorted() 不改变原列表</span></span><br><span class="line">[<span class="string">'1'</span>, <span class="number">1</span>, <span class="string">'a'</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="string">'n'</span>]     </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> a.sort()</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a                      <span class="comment"># a.sort()直接修改原列表</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="string">'1'</span>, <span class="string">'a'</span>, <span class="string">'n'</span>]</span><br></pre></td></tr></table></figure><p>因此如果实际应用过程中需要保留原有列表，使用 sorted() 函数较为适合，否则可以选 择 sort() 函数，因为 sort() 函数不需要复制原有列表，消耗的内存较少，效率也较高。</p><p>sorted() 函数功能非常强大，它可以方便地针对不同的数据结构进行排序，从而满足不同需求。例子如下：</p><ul><li>对字典进行排序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(&#123;<span class="number">1</span>: <span class="string">'D'</span>, <span class="number">2</span>: <span class="string">'B'</span>, <span class="number">3</span>: <span class="string">'B'</span>, <span class="number">4</span>: <span class="string">'E'</span>, <span class="number">5</span>: <span class="string">'A'</span>&#125;)    </span><br><span class="line"><span class="comment"># 根据字典键排序[1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(&#123;<span class="number">1</span>: <span class="string">'D'</span>, <span class="number">2</span>: <span class="string">'B'</span>, <span class="number">3</span>: <span class="string">'B'</span>, <span class="number">4</span>: <span class="string">'E'</span>, <span class="number">5</span>: <span class="string">'A'</span>&#125;.values())   </span><br><span class="line"><span class="comment"># 根据字典值排序['A', 'B', 'B', 'D', 'E']</span></span><br></pre></td></tr></table></figure><ul><li>对多维列表排序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>student_tuples = [(<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>),(<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>),(<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(student_tuples, key = <span class="keyword">lambda</span> student: student[<span class="number">0</span>]) <span class="comment"># 对姓名排序</span></span><br><span class="line">[(<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>), (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>), (<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(student_tuples, key = <span class="keyword">lambda</span> student: student[<span class="number">2</span>])  <span class="comment"># 年龄排序</span></span><br><span class="line">[(<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>), (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>), (<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>)]</span><br></pre></td></tr></table></figure><ul><li>调用operator模块中的 itemgetter() 可以实现根据多个参数排序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(student_tuples, key = itemgetter(<span class="number">2</span>))  <span class="comment"># 根据年龄排序</span></span><br><span class="line">[(<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>), (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>), (<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(student_tuples, key = itemgetter(<span class="number">1</span>, <span class="number">2</span>))  <span class="comment"># 根据成绩和年龄排序</span></span><br><span class="line">[(<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>), (<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>), (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(student_tuples, key = itemgetter(<span class="number">1</span>, <span class="number">2</span>), reverse=<span class="literal">True</span>) <span class="comment"># 反转排序结果</span></span><br><span class="line">[(<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>), (<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>), (<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>)]</span><br></pre></td></tr></table></figure><p>ps: itemgetter 返回一个函数，实现取元素的功能。比如<br>      f = itemgetter(2)，调用 f(r) 返回 r[2];<br>      f = itemgetter(2, 5, 3)，调用 f(r) 返回元组 (r[2], r[5], r[3]).</p><h1 id="二、python集合-set-操作"><a href="#二、python集合-set-操作" class="headerlink" title="二、python集合(set)操作"></a>二、python集合(set)操作</h1><p>python的set和其他语言类似, 是一个无序不重复元素集, 基本功能包括关系测试和消除重复元素. 集合对象还支持union(联合), intersection(交), difference(差)和sysmmetric difference(对称差集)等数学运算.</p><ul><li>下面来点简单的小例子说明</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = set(<span class="string">'spam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = set([<span class="string">'h'</span>,<span class="string">'a'</span>,<span class="string">'m'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y</span><br><span class="line">(set([<span class="string">'a'</span>, <span class="string">'p'</span>, <span class="string">'s'</span>, <span class="string">'m'</span>]), set([<span class="string">'a'</span>, <span class="string">'h'</span>, <span class="string">'m'</span>]))</span><br></pre></td></tr></table></figure><ul><li>再来些小应用。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x &amp; y <span class="comment"># 交集</span></span><br><span class="line">set([<span class="string">'a'</span>, <span class="string">'m'</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x | y <span class="comment"># 并集</span></span><br><span class="line">set([<span class="string">'a'</span>, <span class="string">'p'</span>, <span class="string">'s'</span>, <span class="string">'h'</span>, <span class="string">'m'</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x - y <span class="comment"># 差集</span></span><br><span class="line">set([<span class="string">'p'</span>, <span class="string">'s'</span>])</span><br></pre></td></tr></table></figure><p>记得以前个网友提问怎么去除海量列表里重复元素，用hash来解决也行，只不过感觉在性能上不是很高，用set解决还是很不错的，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">11</span>,<span class="number">22</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = set(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">set([<span class="number">33</span>, <span class="number">11</span>, <span class="number">44</span>, <span class="number">22</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = [i <span class="keyword">for</span> i <span class="keyword">in</span> b]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">[<span class="number">33</span>, <span class="number">11</span>, <span class="number">44</span>, <span class="number">22</span>]</span><br></pre></td></tr></table></figure><p><strong>集合</strong>用于包含一组无序的对象。要创建集合，可使用set()函数并像下面这样提供一系列的项：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = set([<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>])      <span class="comment">#创建一个数值集合</span></span><br><span class="line"></span><br><span class="line">t = set(<span class="string">"Hello"</span>)         <span class="comment">#创建一个唯一字符的集合</span></span><br></pre></td></tr></table></figure><p>与列表和元组不同，集合是无序的，也无法通过数字进行索引。此外，集合中的元素不能重复。例如，如果检查前面代码中t集合的值，结果会是：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">set([<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>])</span><br></pre></td></tr></table></figure><p>注意只出现了一个’l’。</p><p>集合支持一系列标准操作，包括并集、交集、差集和对称差集，例如：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = t | s          <span class="comment"># t 和 s的并集</span></span><br><span class="line">b = t &amp; s          <span class="comment"># t 和 s的交集</span></span><br><span class="line">c = t – s          <span class="comment"># 求差集（项在t中，但不在s中）</span></span><br><span class="line">d = t ^ s          <span class="comment"># 对称差集（项在t或s中，但不会同时出现在二者中）</span></span><br></pre></td></tr></table></figure><h3 id="基本操作："><a href="#基本操作：" class="headerlink" title="基本操作："></a>基本操作：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">t.add(<span class="string">'x'</span>)            <span class="comment"># 添加一项</span></span><br><span class="line">s.update([<span class="number">10</span>,<span class="number">37</span>,<span class="number">42</span>])  <span class="comment"># 在s中添加多项</span></span><br><span class="line"></span><br><span class="line">t.remove(<span class="string">'H'</span>)</span><br><span class="line"><span class="comment">#使用remove()可以删除一项</span></span><br><span class="line"></span><br><span class="line">len(s)</span><br><span class="line"><span class="comment">#set 的长度</span></span><br><span class="line"></span><br><span class="line">x <span class="keyword">in</span> s</span><br><span class="line"><span class="comment">#测试 x 是否是 s 的成员</span></span><br><span class="line"></span><br><span class="line">x <span class="keyword">not</span> <span class="keyword">in</span> s</span><br><span class="line"><span class="comment">#测试 x 是否不是 s 的成员</span></span><br><span class="line"></span><br><span class="line">s.issubset(t)</span><br><span class="line">s &lt;= t</span><br><span class="line"><span class="comment">#测试是否 s 中的每一个元素都在 t 中</span></span><br><span class="line"></span><br><span class="line">s.issuperset(t)</span><br><span class="line">s &gt;= t</span><br><span class="line"><span class="comment">#测试是否 t 中的每一个元素都在 s 中</span></span><br><span class="line"></span><br><span class="line">s.union(t)</span><br><span class="line">s | t</span><br><span class="line"><span class="comment">#返回一个新的 set 包含 s 和 t 中的每一个元素</span></span><br><span class="line"></span><br><span class="line">s.intersection(t)</span><br><span class="line">s &amp; t</span><br><span class="line"><span class="comment">#返回一个新的 set 包含 s 和 t 中的公共元素</span></span><br><span class="line"></span><br><span class="line">s.difference(t)</span><br><span class="line">s - t</span><br><span class="line"><span class="comment">#返回一个新的 set 包含 s 中有但是 t 中没有的元素</span></span><br><span class="line"></span><br><span class="line">s.symmetric_difference(t)</span><br><span class="line">s ^ t</span><br><span class="line"><span class="comment">#返回一个新的 set 包含 s 和 t 中不重复的元素</span></span><br><span class="line"></span><br><span class="line">s.copy()</span><br><span class="line"><span class="comment">#返回 set “s”的一个浅复制</span></span><br><span class="line"></span><br><span class="line">hash(s)</span><br><span class="line"><span class="comment">#返回 s 的 hash 值</span></span><br><span class="line"></span><br><span class="line">s.update(t)</span><br><span class="line">s |= t</span><br><span class="line"><span class="comment">#返回增加了 set “t”中元素后的 set “s”</span></span><br><span class="line"></span><br><span class="line">s.intersection_update(t)</span><br><span class="line">s &amp;= t</span><br><span class="line"><span class="comment">#返回只保留含有 set “t”中元素的 set “s”</span></span><br><span class="line"></span><br><span class="line">s.difference_update(t)</span><br><span class="line">s -= t</span><br><span class="line"><span class="comment">#返回删除了 set “t”中含有的元素后的 set “s”</span></span><br><span class="line"></span><br><span class="line">s.symmetric_difference_update(t)</span><br><span class="line">s ^= t</span><br><span class="line"><span class="comment">#返回含有 set “t”或者 set “s”中有而不是两者都有的元素的 set “s”</span></span><br><span class="line"></span><br><span class="line">s.remove(x)</span><br><span class="line"><span class="comment">#从 set “s”中删除元素 x, 如果不存在则引发 KeyError</span></span><br><span class="line"></span><br><span class="line">s.discard(x)</span><br><span class="line"><span class="comment">#如果在 set “s”中存在元素 x, 则删除</span></span><br><span class="line"></span><br><span class="line">s.pop()</span><br><span class="line"><span class="comment">#删除并且返回 set “s”中的一个不确定的元素, 如果为空则引发 KeyError</span></span><br><span class="line"></span><br><span class="line">s.clear()</span><br><span class="line"><span class="comment">#删除 set “s”中的所有元素</span></span><br></pre></td></tr></table></figure><h1 id="三、str和list排序-删除重复数据"><a href="#三、str和list排序-删除重复数据" class="headerlink" title="三、str和list排序 删除重复数据"></a>三、str和list排序 删除重复数据</h1><ul><li>List排序并删除重复值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a =[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b =sorted(set(a)) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(b)</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><ul><li>List排序不删除重复值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (a)</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><ul><li>String排序不删除重复值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="string">"abchabcgesdfaad"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=list(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">""</span>.join(b)</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">print</span> (s)</span><br><span class="line">aaaabbccddefghs</span><br></pre></td></tr></table></figure><ul><li>String排序删除重复值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="string">"abchabcgesdfaad"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=list(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=sorted(set(b))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'s'</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python获取当前目录，上级目录，上上级目录</title>
      <link href="/2019/0630/Python-get-dir/"/>
      <url>/2019/0630/Python-get-dir/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> <span class="string">'***获取当前目录***'</span></span><br><span class="line"><span class="keyword">print</span> os.getcwd()</span><br><span class="line"><span class="keyword">print</span> os.path.abspath(os.path.dirname(__file__))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> <span class="string">'***获取上级目录***'</span></span><br><span class="line"><span class="keyword">print</span> os.path.abspath(os.path.dirname(os.path.dirname(__file__)))</span><br><span class="line"><span class="keyword">print</span> os.path.abspath(os.path.dirname(os.getcwd()))</span><br><span class="line"><span class="keyword">print</span> os.path.abspath(os.path.join(os.getcwd(), <span class="string">".."</span>))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> <span class="string">'***获取上上级目录***'</span></span><br><span class="line"><span class="keyword">print</span> os.path.abspath(os.path.join(os.getcwd(), <span class="string">"../.."</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora取消继承上一行格式</title>
      <link href="/2019/0627/Typora-cancel-inherit/"/>
      <url>/2019/0627/Typora-cancel-inherit/</url>
      
        <content type="html"><![CDATA[<blockquote><center><font color="#1Bc3FB">Debug !</font><center></center></center></blockquote><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>使用Typora写列表时，换行会继承上一行的格式</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p><strong>Mac</strong></p><p><code>command+[</code></p><p><strong>windows</strong></p><p><code>ctrl+[</code></p><p>即可取消继承</p><blockquote><p><strong>补充</strong>：直接按方向键时不自动继承上一行的，按Enter会继承上一行</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git安装及Github基本使用</title>
      <link href="/2019/0627/Git-Github-Mac/"/>
      <url>/2019/0627/Git-Github-Mac/</url>
      
        <content type="html"><![CDATA[<h1 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h1><p>在Mac上安装git</p><p>首先在终端输入<code>git</code>查看是否已安装过git</p><h2 id="通过homebrew安装git"><a href="#通过homebrew安装git" class="headerlink" title="通过homebrew安装git"></a>通过homebrew安装git</h2><ul><li>未安装homebrew，先安装homebrew</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure><ul><li>安装git</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure><h1 id="创建ssh-key、配置git"><a href="#创建ssh-key、配置git" class="headerlink" title="创建ssh key、配置git"></a>创建ssh key、配置git</h1><ol><li>设置username和email（github每次commit都会记录他们）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"你的用户名"</span></span><br><span class="line">git config --global user.email <span class="string">"你的邮箱地址"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>生成ssh key</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"你的邮箱地址"</span></span><br></pre></td></tr></table></figure><p>然后直接三个回车即可，默认不需要设置密码</p><p>然后找到~/下生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制</p><ol start="3"><li>打开<a href="https://github.com/settings/keys" target="_blank" rel="noopener">GitHub_Settings_keys</a>页面，新建new SSH Key</li></ol><p><img src="https://cdn.jsdelivr.net/gh/SkyAzure/ImgHosting/Azure-Img/article/20200306220648.png" alt></p><p>Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。<br>在Git Bash中检测GitHub公钥设置是否成功，终端输入 <code>ssh git@github.com</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Last login: Sat Jan  6 14:42:55 on ttys000</span><br><span class="line">你的主机名:~ 你的用户名$ ssh git@github.com </span><br><span class="line">Hi 你刚刚设置的user.name! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure><p>说明已经链接成功。</p><h1 id="提交本地项目到Github"><a href="#提交本地项目到Github" class="headerlink" title="提交本地项目到Github"></a>提交本地项目到Github</h1><ol><li><p>在GitHub上新创建一个 repository或者<strong>Start a Project</strong></p></li><li><p>填写项目信息，填写完成后点击<strong>Create repository</strong></p></li><li><p>Clone工程到本地，首先复制ssh 地址</p><p>然后克隆项目,终端输入</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 你复制的ssh地址</span><br></pre></td></tr></table></figure><p>这时，工程已经被克隆到所在文件夹</p><ol start="4"><li>进入clone下来的文件夹，使用编辑器等修改并保存代码</li><li>提交修改，首先切换到文件夹所在目录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="built_in">clone</span>下来的文件夹的地址</span><br><span class="line">//文件添加到仓库（.代表提交所有文件）</span><br><span class="line">git add .</span><br><span class="line">//把文件提交到仓库</span><br><span class="line">git commit -m <span class="string">"First Commit"</span></span><br><span class="line">//上传到github</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>查看GitHub上的项目，就已经上传成功啦</p><p>参考文章:</p><ol><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git教程</a></li><li><a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">GitHub+Hexo 搭建个人网站详细教程</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo不解析Markdown标题</title>
      <link href="/2019/0622/Typora-Markdown-title/"/>
      <url>/2019/0622/Typora-Markdown-title/</url>
      
        <content type="html"><![CDATA[<blockquote><center><font color="#1Bc3FB">Debug !</font><center></center></center></blockquote><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>发布文章后标题没有被解析显示<code>#标题</code> ，但是在我编辑器(Typora)里面显示没有问题</p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>Markdown标题标准写法需要在”#”和后面字符之间加一个空格</p><p>不加空格一些引擎就解析不了</p><p>Typora编辑器中在行首有#，就会自动识别为标题</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>需要注意写Markdown文档时要严格遵守Markdowm标准</p><blockquote><p>拓展</p></blockquote><p><strong>Markdown</strong>诞生自 <a href="https://link.zhihu.com/?target=http%3A//daringfireball.net/" target="_blank" rel="noopener">Daring Fireball</a>之手，点击<a href="https://link.zhihu.com/?target=http%3A//daringfireball.net/projects/markdown/syntax" target="_blank" rel="noopener">这里</a>可以找到最早版本的语法标准。然而，它的语法标准因解析器和编辑器而异，<strong>Typora</strong>使用的是<a href="https://link.zhihu.com/?target=https%3A//help.github.com/articles/github-flavored-markdown/" target="_blank" rel="noopener">GitHub Flavored Markdown</a>标准。</p><p>需要注意的是在Markdown中的HTML代码块可以被识别但并不会被解析和编译。同样要注意的是，保存之后的文档格式可能会对最初的编写的文档格式有所微调。</p>]]></content>
      
      
      <categories>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> Typore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo generate报错TypeError: Cannot read property &amp;#39utcOffset&amp;#39 of null</title>
      <link href="/2019/0622/Hexo-g-Debug/"/>
      <url>/2019/0622/Hexo-g-Debug/</url>
      
        <content type="html"><![CDATA[<blockquote><center><font color="#1Bc3FB">Debug !</font><center></center></center></blockquote><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>最近刚刚开始使用Hexo，新建了一篇文章，运行<code>hexo g</code>时报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: Cannot <span class="built_in">read</span> property <span class="string">'utcOffset'</span> of null</span><br></pre></td></tr></table></figure><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>研究一番后发现是因为最初设置_config.yml中的时区时，我把<code>timezone: Asia/Shanghai</code>修改为<code>timezone: Asia/Beijing</code></p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>在_config.yml中设置<code>timezone: Asia/Shanghai</code></p><blockquote><p>拓展</p></blockquote><p>常用的程序语言支持的时区属于中国的有六个 …</p><ul><li>Asia/Chongqing</li><li>Asia/Shanghai</li><li>Asia/Urumqi</li><li>Asia/Macao</li><li>Asia/Hong_Kong</li><li>Asia/Taipei</li></ul><p>1949年以前，中国一共分了5个时区，以哈尔滨、上海、重庆、乌鲁木齐和喀什为代表，分别是：</p><ul><li>长白时区GMT+8:30</li><li>中原标准时区GMT+8</li><li>陇蜀时区GMT+7</li><li>新藏时区GMT+6</li><li>昆仑时区GMT+5:30。 </li></ul><p>它是1912年北京观象台制订，后由内政部批准过.北京也是GMT+8。可能是为了兼容旧的标准，没有新增<code>Asia/Beijing</code></p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo删除&amp;#34Hello Word&amp;#34</title>
      <link href="/2019/0620/Hexo-delete-helloword/"/>
      <url>/2019/0620/Hexo-delete-helloword/</url>
      
        <content type="html"><![CDATA[<blockquote><center><font color="#1BC3FB" size="4">hexo如何删除初始文章</font></center></blockquote><a id="more"></a><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>Hexo初始有一篇”Hello World”文章，我准备先删除掉它来开始我的blog生涯。但是一波操作之后，<a href="/">刷新界面</a>并没有起作用。</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>一般文章的删除步骤为：</p><ul><li><p>删除本地文件  </p><p><code>location:本地博客目录位置/source/_posts/你的文章</code></p></li><li><p>生成</p></li><li><p>部署</p><!-- more --></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>但是我试过一次发现本地删掉了，<code>hexo g</code>报错，博客上还是存在这篇文章的。网上查阅后发现原因是_post文件夹不能为空，新建一篇就好了</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p><code>hexo n &quot;博客名字&quot;</code></p><p><strong>保证_post文件夹不为空就好了</strong></p><blockquote><p>拓展</p></blockquote><p>在使用hexo写文章时，如果文章的title中包含双引号”abc”、&#36;符号时会编译出错，文章无法渲染。<br>由于这里的写法是yml语法，”、$这些都是特殊符号，执行hexo -s时到编译title这里就会出现错误</p><p>这里我们需要对特殊符号进行转义，用对应的HTML字符实体进行替换<br>附录：各种常用特殊字符对应的HTML字符实体</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">! &amp;#33; — 惊叹号 Exclamation mark</span><br><span class="line">" &amp;#34; &amp;quot; — 双引号 Quotation mark</span><br><span class="line"># &amp;#35; — 数字标志 Number sign</span><br><span class="line">$ &amp;#36; — 美元标志 Dollar sign</span><br><span class="line">% &amp;#37; — 百分号 Percent sign</span><br><span class="line">&amp; &amp;#38; &amp;amp; — 与符号(&amp;) Ampersand</span><br><span class="line">' &amp;#39; — 单引号 Apostrophe</span><br><span class="line">( &amp;#40; — 小括号左边部分 Left parenthesis</span><br><span class="line">) &amp;#41; — 小括号右边部分 Right parenthesis</span><br><span class="line">* &amp;#42; — 星号 Asterisk</span><br><span class="line">+ &amp;#43; — 加号 Plus sign</span><br><span class="line"><span class="tag">&lt; &amp;#<span class="attr">60</span>; &amp;<span class="attr">lt</span>; 小于号 <span class="attr">Less</span> <span class="attr">than</span></span></span><br><span class="line"><span class="tag">= <span class="string">&amp;#61;</span> — 等于符号 <span class="attr">Equals</span> <span class="attr">sign</span></span></span><br><span class="line"><span class="tag"><span class="attr">-</span> &amp;#<span class="attr">45</span>; &amp;<span class="attr">minus</span>; — 减号</span></span><br><span class="line"><span class="tag">&gt;</span> &amp;#62; &amp;gt; — 大于号 Greater than</span><br><span class="line">? &amp;#63; — 问号 Question mark</span><br><span class="line">@ &amp;#64; — Commercial at</span><br><span class="line">[ &amp;#91; — 中括号左边部分 Left square bracket</span><br><span class="line">\ &amp;#92; — 反斜杠 Reverse solidus (backslash)</span><br><span class="line">] &amp;#93; — 中括号右边部分 Right square bracket</span><br><span class="line">&#123; &amp;#123; — 大括号左边部分 Left curly brace</span><br><span class="line">| &amp;#124; — 竖线Vertical bar</span><br><span class="line">&#125; &amp;#125; — 大括号右边部分 Right curly brace</span><br><span class="line">空格 &amp;nbsp;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
